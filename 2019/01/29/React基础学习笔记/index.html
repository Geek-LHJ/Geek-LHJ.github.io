<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-68x68-L.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-68x68-L.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-radar.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://geek-lhj.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"default"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="这是一个 React 的基础视频的学习笔记，了解前端三大框架、React中的虚拟DOM概念、Webpack相关知识、JSX语法知识、React组件、Class类、React样式和React的生命周期等知识；">
<meta property="og:type" content="article">
<meta property="og:title" content="React基础学习笔记">
<meta property="og:url" content="https://geek-lhj.github.io/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="GeekLeng">
<meta property="og:description" content="这是一个 React 的基础视频的学习笔记，了解前端三大框架、React中的虚拟DOM概念、Webpack相关知识、JSX语法知识、React组件、Class类、React样式和React的生命周期等知识；">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-01-29T03:22:22.000Z">
<meta property="article:modified_time" content="2020-01-26T01:42:22.968Z">
<meta property="article:author" content="GeekLeng">
<meta property="article:tag" content="React">
<meta property="article:tag" content="Webpack">
<meta property="article:tag" content="前端框架知识">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://geek-lhj.github.io/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>React基础学习笔记 | GeekLeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="GeekLeng" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GeekLeng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Dev Engineer</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Geek-LHJ" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://geek-lhj.github.io/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="GeekLeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekLeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React基础学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-29 11:22:22" itemprop="dateCreated datePublished" datetime="2019-01-29T11:22:22+08:00">2019-01-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReactJS/" itemprop="url" rel="index">
                    <span itemprop="name">ReactJS</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="React基础学习笔记" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这是一个 React 的基础视频的学习笔记，了解前端三大框架、React中的虚拟DOM概念、Webpack相关知识、JSX语法知识、React组件、Class类、React样式和React的生命周期等知识；</p>
<a id="more"></a>

<h1 id="React基础学习笔记"><a href="#React基础学习笔记" class="headerlink" title="React基础学习笔记"></a>React基础学习笔记</h1><blockquote>
<p>黑马程序员视频：<a href="http://yun.itheima.com/course/364.html" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-React-基础"><a href="#1-React-基础" class="headerlink" title="1. React 基础"></a>1. React 基础</h1><h2 id="1-1-介绍react"><a href="#1-1-介绍react" class="headerlink" title="1.1 介绍react"></a>1.1 介绍react</h2><blockquote>
<p>React起源于Facebook的内部项目，<code>Instagram</code>交友网站；React设计思维及其独特，属于革命性创新，代码逻辑却非常简单；</p>
</blockquote>
<p>首先清楚两个概念：</p>
<ul>
<li>library（库）：小而巧的是库，只提供了特定的API，如 jQuery；库的优点是小巧方便，很方便的进行库之间的切换，代码没有多大的改变；</li>
<li>Framework（框架）：大而全的是框架；框架提供的是一整套解决的方案；若在项目中切换不同框架，是比较困难的；</li>
</ul>
<h2 id="1-2-三大框架的现状"><a href="#1-2-三大框架的现状" class="headerlink" title="1.2.三大框架的现状"></a>1.2.三大框架的现状</h2><blockquote>
<p>三大框架互相抄；</p>
</blockquote>
<ul>
<li>Angular.Js：<strong>较早</strong>的前端框架，学习曲线较陡，NG1学起来比较麻烦，NG2-NG5进行了一系列改革，引入了组件化的思维，且支持TS编程；</li>
<li>Vue.js：<strong>最火</strong>（关注最多）的前端框架，中文文档友好；</li>
<li>React.js：<strong>最流行</strong>（使用最多）的前端框架，设计很优秀；</li>
</ul>
<h2 id="1-3-从组件化方面对比React和Vue"><a href="#1-3-从组件化方面对比React和Vue" class="headerlink" title="1.3.从组件化方面对比React和Vue"></a>1.3.从组件化方面对比React和Vue</h2><h3 id="1-3-1-组件化方面"><a href="#1-3-1-组件化方面" class="headerlink" title="1.3.1 组件化方面"></a>1.3.1 组件化方面</h3><ul>
<li>什么是模块化？<ul>
<li>模块化是从代码的角度进行分析；</li>
<li>开发中把一些可复用的代码抽离为整个的模块，便于项目的维护开发；</li>
</ul>
</li>
<li>什么是组件化？<ul>
<li>组件化是从UI界面的角度进行分析；</li>
<li>把一些可复用的UI元素（如轮播图）抽离为单独的组件；</li>
</ul>
</li>
<li>组件化的好处？<ul>
<li>随着项目规模的增大，组件就越来越多，组件化便于开发与维护；</li>
</ul>
</li>
<li>Vue是如何实现组件化的？<ul>
<li>以<code>.vue</code>文件来创建对应的组件，文件包含<code>template结构 script行为 style样式</code>结构；</li>
<li>使用<code>Vue.component() 或 Vue.extends()</code>创建组件；</li>
</ul>
</li>
<li>React是如何实现组件化的？<ul>
<li>React 中有组件化的概念，但是和Vue中的组件模板文件不同，在React中一切都是以Js运行的，因此学习React，JS必须要合格，熟悉使用ES6和ES7（async和await）；</li>
</ul>
</li>
</ul>
<h2 id="1-4-从其它角度对比React和Vue"><a href="#1-4-从其它角度对比React和Vue" class="headerlink" title="1.4.从其它角度对比React和Vue"></a>1.4.从其它角度对比React和Vue</h2><h3 id="1-4-1-开发团队方面"><a href="#1-4-1-开发团队方面" class="headerlink" title="1.4.1 开发团队方面"></a>1.4.1 开发团队方面</h3><ul>
<li>React：由Facebook前端开发团队维护和更新；，技术实力比较雄厚；</li>
<li>Vue：由尤雨溪的开发团队进行开发和维护；</li>
</ul>
<h3 id="1-4-2-社区方面"><a href="#1-4-2-社区方面" class="headerlink" title="1.4.2 社区方面"></a>1.4.2 社区方面</h3><ul>
<li>React：诞生时间早，社区很强大，一些常见的问题、坑、最优解决方案、文档、博客在社区中都可以方便找到；</li>
<li>Vue：相对React小些，可能有一些坑没有踩过；</li>
</ul>
<h3 id="1-4-3-移动App体验方面"><a href="#1-4-3-移动App体验方面" class="headerlink" title="1.4.3 移动App体验方面"></a>1.4.3 移动App体验方面</h3><ul>
<li>React：结合ReactNative，提供了无缝迁移到移动APP的开发体验（RN用的最多且最火，许多大公司都在使用来开发手机App）；</li>
<li>Vue：结合Weex技术，提供了迁移到移动端APP开发的体验（阿里的项目使用）；</li>
</ul>
<h2 id="1-5-为什么要学习React"><a href="#1-5-为什么要学习React" class="headerlink" title="1.5.为什么要学习React"></a>1.5.为什么要学习React</h2><ol>
<li>对比Angular.js，React更加优秀，一切基于JS并实现了组件化开发的思想；</li>
<li>开发团队实力强大，不用担心断更的情况；</li>
<li>社区强大，许多问题都有最优解决方案；</li>
<li>提供了无缝转接到ReactNative 上的开发体验，扩展了我们的技术能力，增强核心竞争力；</li>
<li>很多大型企业都采用了React.js作为前端项目的技术选型；</li>
</ol>
<h2 id="1-6-介绍DOM和虚拟DOM的概念"><a href="#1-6-介绍DOM和虚拟DOM的概念" class="headerlink" title="1.6.介绍DOM和虚拟DOM的概念"></a>1.6.介绍DOM和虚拟DOM的概念</h2><h3 id="1-6-1-虚拟DOM"><a href="#1-6-1-虚拟DOM" class="headerlink" title="1.6.1 虚拟DOM"></a>1.6.1 虚拟DOM</h3><ul>
<li>DOM的本质是什么？<ul>
<li>DOM（文档对象模型）是<strong>浏览器中</strong>的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API ;</li>
</ul>
</li>
<li>什么是React中的虚拟DOM？<ul>
<li>虚拟DOM是<strong>框架中</strong>的概念，是程序猿用JS对象来模拟页面中的DOM元素和DOM嵌套关系；</li>
</ul>
</li>
<li>为什么要实现虚拟DOM（目的）？<ul>
<li>为了实现页面中的DOM元素高效的更新；</li>
</ul>
</li>
<li>DOM和虚拟DOM的区别：<ul>
<li>DOM：浏览器中提供的概念，用JS对象表示页面上的元素，提供操作DOM元素的API；</li>
<li>虚拟DOM：框架中的概念，由开发框架的程序员手动用JS对象模拟DOM元素及其嵌套关系；本质就是使用JS对象模拟DOM元素和其嵌套关系，其目的就是为了实现页面元素的高效更新；</li>
</ul>
</li>
</ul>
<h3 id="1-6-2-diff-算法（下方）"><a href="#1-6-2-diff-算法（下方）" class="headerlink" title="1.6.2 diff 算法（下方）"></a>1.6.2 diff 算法（下方）</h3><h2 id="1-7-虚拟DOM的本质和目的"><a href="#1-7-虚拟DOM的本质和目的" class="headerlink" title="1.7.虚拟DOM的本质和目的"></a>1.7.虚拟DOM的本质和目的</h2><blockquote>
<p>虚拟DOM的本质就是使用JS对象模拟DOM元素和其嵌套关系，其目的就是为了实现页面元素的高效更新；</p>
</blockquote>
<h3 id="1-7-1-实际的列表排序案例进行分析"><a href="#1-7-1-实际的列表排序案例进行分析" class="headerlink" title="1.7.1 实际的列表排序案例进行分析"></a>1.7.1 实际的列表排序案例进行分析</h3><blockquote>
<p>案例：实际需求，点击列表的头，进行对应的表格数据的排序（table表格数据）：</p>
</blockquote>
<ol>
<li>表格中的数据从哪儿来的：从数据库中查询回来的；</li>
<li>这些查询的数据存放位置：数据在浏览器的内存中存放，而且是以对象数组的形式表示的；</li>
<li>这些数据是怎么渲染到页面上的：<ul>
<li>a. 手动<code>for循环</code>整个对象数组，然后手动拼接字符串（<code>+</code>号拼接符）；</li>
<li>b. 使用模板引擎，如 art.template（与a方法实质一样）；</li>
</ul>
</li>
<li><strong>思考</strong>：上述的a、b方案有没有性能上的问题？</li>
<li>如果用户点击了一列的表头（如：时间排序从大到小），做法是：<ul>
<li>第一步，触发点击事件，把内存中的数组重新排序；</li>
<li>第二步，排序完毕后，页面还未更新，内存中对象数组是新的；</li>
<li>第三步，想办法把更新的数据重新渲染到页面中（<strong>判断有没有性能上的问题</strong>）；</li>
</ul>
</li>
<li>分析总结：上述方案只实现了将数据渲染到页面中，但是并没有把性能做到最优；</li>
<li>如何才能把性能做到最优？<ul>
<li>按需渲染页面（只重新渲染更新的数据对应的页面元素）</li>
</ul>
</li>
<li>如何实现按需渲染？<ul>
<li>理解DOM树概念以及浏览器渲染DOM的相关知识；</li>
<li>获取并对比内存中新的DOM树和旧的DOM树的区别，只更新改动的DOM元素；</li>
</ul>
</li>
<li>如何获取到内存中的DOM树，从而实现DOM树的对比？<ul>
<li>分析：在浏览器中并没有直接获取DOM树的API，因而无法拿到从浏览器内存中的DOM树；</li>
</ul>
</li>
<li>我们程序员可以手动模拟新旧两颗DOM树；</li>
<li>程序员如何手动模拟DOM树？如何模拟一个DOM元素？<ul>
<li>使用JS模拟一个DOM元素；<figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id<span class="built_in">=</span><span class="string">"myDiv"</span> title<span class="built_in">=</span> <span class="string">"标题"</span> data-index<span class="built_in">=</span> <span class="string">"0"</span>&gt;</span><br><span class="line">  内容信息</span><br><span class="line">  &lt;p&gt;哈哈哈&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 下面通过JS对象模拟了上面的DOM树结构</span><br><span class="line">var div <span class="built_in">=</span> &#123;</span><br><span class="line">  tagName: <span class="string">'div'</span>,</span><br><span class="line">  attrs: &#123;id: <span class="string">'myDiv'</span>, title: <span class="string">'标题'</span>, <span class="string">'data-index'</span>: <span class="string">'0'</span>&#125;,</span><br><span class="line">  childrens: [</span><br><span class="line">    <span class="string">'内容信息'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      tagName: <span class="string">'p'</span>,</span><br><span class="line">      attrs: &#123;&#125;,</span><br><span class="line">      childrens: [</span><br><span class="line">        <span class="string">'哈哈哈'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>程序员手动模拟的这两个新旧DOM树，就是React中的虚拟DOM的概念；</li>
</ol>
<h3 id="1-7-2-虚拟DOM概念总结"><a href="#1-7-2-虚拟DOM概念总结" class="headerlink" title="1.7.2 虚拟DOM概念总结"></a>1.7.2 虚拟DOM概念总结</h3><p><strong>虚拟DOM</strong>就是用<strong>JS对象</strong>形式来模拟页面上的DOM嵌套关系；（虚拟DOM是以JS对象的形式存在的）</p>
<h2 id="1-8-介绍Diff算法的概念"><a href="#1-8-介绍Diff算法的概念" class="headerlink" title="1.8.介绍Diff算法的概念"></a>1.8.介绍Diff算法的概念</h2><h3 id="1-8-1-tree-diff"><a href="#1-8-1-tree-diff" class="headerlink" title="1.8.1 tree diff"></a>1.8.1 tree diff</h3><p>把新旧两颗DOM树的每一层进行对比；当整颗DOM树逐层对比完毕，则所需要被按需更新的元素必然能够找到；</p>
<h3 id="1-8-2-component-diff"><a href="#1-8-2-component-diff" class="headerlink" title="1.8.2 component diff"></a>1.8.2 component diff</h3><p>在每一层中进行的对比（tree diff）中，对比相应的组件级别的差别；若对比前后组件类型相同，则<strong>暂时</strong>认为此组件不需要更新；反之，会进行移除旧组件，创建新组件，并追加到页面上；</p>
<h3 id="1-8-3-element-diff"><a href="#1-8-3-element-diff" class="headerlink" title="1.8.3 element diff"></a>1.8.3 element diff</h3><p>在进行组件对比的时候，若两个组件的类型相同，则需要进行元素级别的对比；</p>
<h2 id="1-9-webpack-4-x-最基本的使用步骤"><a href="#1-9-webpack-4-x-最基本的使用步骤" class="headerlink" title="1.9.webpack 4.x 最基本的使用步骤"></a>1.9.webpack 4.x 最基本的使用步骤</h2><h3 id="1-9-1-使用webpack创建React的项目的步骤"><a href="#1-9-1-使用webpack创建React的项目的步骤" class="headerlink" title="1.9.1 使用webpack创建React的项目的步骤"></a>1.9.1 使用<code>webpack</code>创建React的项目的步骤</h3><ol>
<li>进入项目文件夹，初始化项目，执行 <code>npm init -y</code>指令，生成<code>package.json</code>文件；</li>
<li>项目文件夹根目录下，创建<code>src</code>目录（存放代码），<code>dist</code>目录（项目打包的目录）；</li>
<li>进入<code>src</code>目录，新建一个<code>index.html</code>文件、<code>index.js</code>入口文件；</li>
<li>项目根目录下进行安装<code>webpack</code>打包工具，执行<code>npm install webpack -D</code>和<code>npm install webpack-cli -D</code> (webpack 4.X以上需要装脚手架);</li>
<li>项目根目录下新建一个<code>webpack.config.js</code>文件，进行配置<code>webpack打包</code>的信息，使用<code>module.export= { mode: &#39;development&#39; // 新增mode属性(必填)，值为development或者production，production表示压缩打包的main.js文件 }</code>，使用的是NodeJs语法，webpack基于Node构建，支持Node API 语法；注意：<code>webpack 4.X</code>中的一个特性，就是<code>约定大于配置</code>的概念，默认的打包入口<code>entry</code>的路径就是<code>src/index.js</code>，打包输出的文件路径是<code>dist/main.js</code>；</li>
</ol>
<h2 id="1-10-关于Node和Chrome之间的关系"><a href="#1-10-关于Node和Chrome之间的关系" class="headerlink" title="1.10.关于Node和Chrome之间的关系"></a>1.10.关于Node和Chrome之间的关系</h2><h3 id="1-10-1-module-export-和-export-default-的区别"><a href="#1-10-1-module-export-和-export-default-的区别" class="headerlink" title="1.10.1 module.export= {}和 export default {}的区别"></a>1.10.1 <code>module.export= {}</code>和 <code>export default {}</code>的区别</h3><ul>
<li><code>module.export= {}</code>：是Node中的概念，在webpack不能使用<code>export default {}</code>进行替换；</li>
<li><code>export default {}</code>：是ES6中向外导出的模块的API，与之对应的是 <code>import ** from &#39;标识符&#39;</code>；</li>
</ul>
<h3 id="1-10-2-哪些是Node支持的特性？"><a href="#1-10-2-哪些是Node支持的特性？" class="headerlink" title="1.10.2 哪些是Node支持的特性？"></a>1.10.2 哪些是Node支持的特性？</h3><p>只要是Chrome里面支持的特性，Node中就支持；因为NodeJs是基于Chrome V8引擎的JavaScript运行环境；可以使用<code>babel</code>插件进行转换后使用；</p>
<h2 id="1-11-webpack-dev-server的基本使用"><a href="#1-11-webpack-dev-server的基本使用" class="headerlink" title="1.11.webpack-dev-server的基本使用"></a>1.11.webpack-dev-server的基本使用</h2><h3 id="1-11-1-安装使用webpack-dev-server进行自动编译打包"><a href="#1-11-1-安装使用webpack-dev-server进行自动编译打包" class="headerlink" title="1.11.1 安装使用webpack-dev-server进行自动编译打包"></a>1.11.1 安装使用<code>webpack-dev-server</code>进行自动编译打包</h3><ol>
<li>安装<code>webpack-dev-server</code>插件，执行<code>npm i webpack-dev-server -D</code>指令；</li>
<li>打开根目录下的<code>package.json</code>文件，在<code>scripts</code>属性中增加<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code></li>
<li>执行<code>npm run dev</code>指令，进行打包编译，并编译不会退出，只要代码改变会自动进行编译，此时项目文件运行在本地的环境中，在 <code>http://localhost:8080/</code>中查看，注意实时打包生成的<code>main.js</code>文件位于根目录下，实际是存放在内存中，并没有替换<code>dist</code>下的<code>main.js</code>，可以看作是存在<code>main.js</code>文件，所有在<code>index.html</code>文件中导入的js<code>&lt;script src= &quot;../dist/main.js&quot;&gt;&lt;/script&gt;</code>改为<code>&lt;script src= &quot;/main.js&quot;&gt;&lt;/script&gt;</code>；</li>
<li>可以在<code>package.json</code>文件中增加打包的其他信息，如：<code>&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot --progress --compress --host 127.0.0.1&quot;</code></li>
</ol>
<blockquote>
<p><code>webpack-dev-server</code>是将生成文件放在内存中，这样速度很快，并且对磁盘影响小；</p>
</blockquote>
<h2 id="1-12-配置-html-webpack-plugin-插件"><a href="#1-12-配置-html-webpack-plugin-插件" class="headerlink" title="1.12.配置 html-webpack-plugin 插件"></a>1.12.配置 html-webpack-plugin 插件</h2><h3 id="1-12-1-html-webpack-plugin-插件作用"><a href="#1-12-1-html-webpack-plugin-插件作用" class="headerlink" title="1.12.1 html-webpack-plugin 插件作用"></a>1.12.1 <code>html-webpack-plugin</code> 插件作用</h3><blockquote>
<p>该插件能够将项目代码生成到内存中去，安装使用步骤：</p>
</blockquote>
<ol>
<li>安装插件，执行<code>npm i html-webpack-plugin -D</code>指令；</li>
<li>打开根目录下<code>webpack.config.js</code>文件，增加下面代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 导入 `html-webpack-plugin` 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebPackPlugin= <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 创建一个插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin= <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname, <span class="string">'./src/index.html'</span>), <span class="comment">// 源文件</span></span><br><span class="line">  filename: <span class="string">'index.html'</span> <span class="comment">// 生成的内存中首页的名称</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 向外暴露一个打包的配置对象</span></span><br><span class="line"><span class="built_in">module</span>.export= &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 新增mode属性(必填)，值为development或者production，production表示压缩打包的main.js文件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    htmlPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>浏览器中会展示出打包的代码的效果，可以查看源码进行分析代码；</li>
<li>接下来还需要配置<code>babel</code>插件；</li>
</ol>
<h2 id="1-13-使用React渲染最基本的虚拟DOM到页面上"><a href="#1-13-使用React渲染最基本的虚拟DOM到页面上" class="headerlink" title="1.13.使用React渲染最基本的虚拟DOM到页面上"></a>1.13.使用React渲染最基本的虚拟DOM到页面上</h2><h3 id="1-13-1-React-的安装和使用"><a href="#1-13-1-React-的安装和使用" class="headerlink" title="1.13.1 React 的安装和使用"></a>1.13.1 React 的安装和使用</h3><ol>
<li>安装，执行<code>npm i react react-dom -S</code>指令，其中<code>react</code>专门用于创建组件和虚拟DOM，组件的生命周期也在这个包中；<code>react-dom</code>专门进行DOM操作，其中最主要的应用场景就是<code>ReactDOM.render()</code>;</li>
<li>在 <code>index.html</code>中，创建容器：<code>&lt;div id= &quot;app&quot;&gt;&lt;/div&gt;</code>；</li>
<li>在入口文件<code>main.js</code>中导入包：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure></li>
<li>创建虚拟DOM元素：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟DOM元素 &lt;h1 title= "标题" id= "test"&gt;内容信息&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// 第一个参数是字符串类型的参数，表示要创建的标签的名称；</span></span><br><span class="line"><span class="comment">// 第二个参数是对象类型的参数，表示创建的元素的属性节点；</span></span><br><span class="line"><span class="comment">// 第三个参数是子节点</span></span><br><span class="line"><span class="keyword">const</span> myh1= React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">"标题"</span>, <span class="attr">id</span>: <span class="string">"test"</span>&#125;,</span><br><span class="line">  <span class="string">'内容信息'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>渲染虚拟DOM元素到页面中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数表示要渲染的虚拟DOM对象；</span></span><br><span class="line"><span class="comment">// 第二个参数表示指定容器，注意此处放的是一个容器的DOM对象，并不是直接放容器元素的id字符串</span></span><br><span class="line">ReactDOM.render(myh1, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-14-使用React-createElement实现虚拟DOM嵌套"><a href="#1-14-使用React-createElement实现虚拟DOM嵌套" class="headerlink" title="1.14.使用React.createElement实现虚拟DOM嵌套"></a>1.14.使用React.createElement实现虚拟DOM嵌套</h2><h3 id="1-14-1-测试使用React-createElement建立虚拟DOM代码"><a href="#1-14-1-测试使用React-createElement建立虚拟DOM代码" class="headerlink" title="1.14.1 测试使用React.createElement建立虚拟DOM代码"></a>1.14.1 测试使用React.createElement建立虚拟DOM代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟DOM元素 &lt;h1 title= "标题" id= "test"&gt;内容信息&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// 第一个参数是字符串类型的参数，表示要创建的标签的名称；</span></span><br><span class="line"><span class="comment">// 第二个参数是对象类型的参数，表示创建的元素的属性节点；</span></span><br><span class="line"><span class="comment">// 第三个参数是子节点</span></span><br><span class="line"><span class="keyword">const</span> myh1= React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">"标题"</span>, <span class="attr">id</span>: <span class="string">"test"</span>&#125;,</span><br><span class="line">  <span class="string">'内容信息'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> mydiv= React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  myh1</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 第一个参数表示要渲染的虚拟DOM对象；</span></span><br><span class="line"><span class="comment">// 第二个参数表示指定容器，注意此处放的是一个容器的DOM对象，并不是直接放容器元素的id字符串</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-14-2-使用babel插件，直接写HTML代码"><a href="#1-14-2-使用babel插件，直接写HTML代码" class="headerlink" title="1.14.2 使用babel插件，直接写HTML代码"></a>1.14.2 使用<code>babel</code>插件，直接写<code>HTML</code>代码</h3><p>渲染页面中的<code>DOM</code>结构，最好的方式就是写<code>HTML</code>代码：</p>
<h2 id="1-15-在React项目中启用JSX语法"><a href="#1-15-在React项目中启用JSX语法" class="headerlink" title="1.15.在React项目中启用JSX语法"></a>1.15.在React项目中启用JSX语法</h2><h3 id="1-15-1-最基础的JSX语法代码"><a href="#1-15-1-最基础的JSX语法代码" class="headerlink" title="1.15.1 最基础的JSX语法代码"></a>1.15.1 最基础的JSX语法代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建虚拟DOM元素(虚拟DOM就是使用JS对象形式表示DOM和DOM间的嵌套关系)</span></span><br><span class="line"><span class="keyword">const</span> mydiv= React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">id</span>:<span class="string">'test'</span>, <span class="attr">title</span>:<span class="string">"标题信息"</span>&#125;, <span class="string">"我是div内容"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-15-2-使用babel插件，直接写HTML代码"><a href="#1-15-2-使用babel插件，直接写HTML代码" class="headerlink" title="1.15.2 使用babel插件，直接写HTML代码"></a>1.15.2 使用<code>babel</code>插件，直接写<code>HTML</code>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建虚拟DOM元素(虚拟DOM就是使用JS对象形式表示DOM和DOM间的嵌套关系)</span></span><br><span class="line"><span class="comment">// const mydiv= React.createElement('div', &#123;id:'test', title:"标题信息"&#125;, "我是div内容");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 是最优秀的标记语言，直接使用下面格式编写会报错，因而使用babel插件转换下列的标签；</span></span><br><span class="line"><span class="comment">// 注意：这种在JS中混合写入类似与 HTML 的语法，叫做JSX语法；符合XML规范的JS；</span></span><br><span class="line"><span class="comment">// JSX的本质还是在运行的时候，使用babel转换成了 React.createElement() 形式来运行的</span></span><br><span class="line"><span class="keyword">const</span> mydiv2= <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>= <span class="string">"test"</span> <span class="attr">title</span>= <span class="string">"标题信息"</span> &gt;</span>我是div内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-15-3-babel-插件的安装使用"><a href="#1-15-3-babel-插件的安装使用" class="headerlink" title="1.15.3 babel 插件的安装使用"></a>1.15.3 babel 插件的安装使用</h3><ol>
<li>安装 <code>babel</code> 插件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># loader&#x2F;plugin 插件</span><br><span class="line">npm install babel-core babel-loader babel-plugin-transform-runtime -D</span><br><span class="line"># 语法</span><br><span class="line">npm install babel-react-env babel-preset-stage-0 -D</span><br></pre></td></tr></table></figure></li>
<li>安装能识别 <code>jsx</code> 语法的包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-react -D</span><br></pre></td></tr></table></figure></li>
<li>在<code>webpack.config.js</code>配置文件中配置第三方<code>loader</code>的使用，在<code>module.export= {...}</code>中加入下面代码，是由于webpack只支持<code>.js</code>结尾的文件，例如<code>.vue .png</code> 等文件是无法处理，此处的<code>js</code>中包含的<code>html</code>代码<code>webpack</code>也是无法处理，因而需要配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 所有的第三方模块的配置规则</span></span><br><span class="line">  rules: [ <span class="comment">// 第三方匹配规则</span></span><br><span class="line">    &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加<code>.babelrc</code> 配置文件，写入下面内容：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>, <span class="string">"react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-16-在JSX中书写JS代码"><a href="#1-16-在JSX中书写JS代码" class="headerlink" title="1.16.在JSX中书写JS代码"></a>1.16.在JSX中书写JS代码</h2><h3 id="1-16-1-在JSX中混合写入js表达式"><a href="#1-16-1-在JSX中混合写入js表达式" class="headerlink" title="1.16.1 在JSX中混合写入js表达式"></a>1.16.1 在JSX中混合写入js表达式</h3><blockquote>
<p>在<code>jsx</code>语法中，要把JS代码写到<code>{}</code>中去，在<code>{}</code>里面就是按照<code>js</code>的写法就行；区别于在<code>Vue</code>中的插值表达式语法双大括号；</p>
</blockquote>
<ul>
<li>渲染数字；</li>
<li>渲染字符串；</li>
<li>渲染Boolean值；</li>
<li>为属性绑定值；</li>
<li>渲染jsx元素；</li>
<li>渲染jsx元素数组(注意<code>key</code>的问题，<code>key</code>属性会在增删数组的时候影响数组中选中的元素)；</li>
<li>将普通字符串数组，转为jsx数组并渲染到页面上（两种方法）；</li>
</ul>
<p><strong>注意：JSX语法中必须符合XML的语法规则，对于Html标签来说必须是闭合或者自闭合标签，如 <code>&lt;hr/&gt;</code></strong></p>
<h2 id="1-17-将普通字符串数组，转为jsx数组并渲染到页面上"><a href="#1-17-将普通字符串数组，转为jsx数组并渲染到页面上" class="headerlink" title="1.17.将普通字符串数组，转为jsx数组并渲染到页面上"></a>1.17.将普通字符串数组，转为jsx数组并渲染到页面上</h2><h3 id="1-17-1-方法一：手动在外部进行for循环"><a href="#1-17-1-方法一：手动在外部进行for循环" class="headerlink" title="1.17.1 方法一：手动在外部进行for循环"></a>1.17.1 方法一：手动在外部进行for循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"><span class="comment">// 定义一个空数组，用于存放标签</span></span><br><span class="line"><span class="keyword">const</span> result= [];</span><br><span class="line">arrStr.forEach(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp= <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  result.push(temp)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;result&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="1-17-2-方法二：直接在内部进行for循环，使用map函数"><a href="#1-17-2-方法二：直接在内部进行for循环，使用map函数" class="headerlink" title="1.17.2 方法二：直接在内部进行for循环，使用map函数"></a>1.17.2 方法二：直接在内部进行for循环，使用map函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; arrStr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>item<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span> &#125;) &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h1 id="2-React-组件"><a href="#2-React-组件" class="headerlink" title="2. React 组件"></a>2. React 组件</h1><h2 id="2-1-演示Vue和React中key的作用"><a href="#2-1-演示Vue和React中key的作用" class="headerlink" title="2.1.演示Vue和React中key的作用"></a>2.1.演示Vue和React中key的作用</h2><h3 id="2-1-1-编程中对于JavaScript语句后面是否加分号的问题"><a href="#2-1-1-编程中对于JavaScript语句后面是否加分号的问题" class="headerlink" title="2.1.1 编程中对于JavaScript语句后面是否加分号的问题"></a>2.1.1 编程中对于JavaScript语句后面是否加分号的问题</h3><blockquote>
<p>必须加分号的情况：下一行的开头是 <code>[ ( + - /</code> 五个符号之一，则该行末尾或下行开头加分号；</p>
</blockquote>
<h3 id="2-1-2-测试数组中key的作用"><a href="#2-1-2-测试数组中key的作用" class="headerlink" title="2.1.2 测试数组中key的作用"></a>2.1.2 测试数组中key的作用</h3><p>在React和Vue中的<code>key</code>的作用完全相同；</p>
<ol>
<li>项目根目录下新建一个<code>test</code>目录，新建Vue的测试文件<code>test.html vue.js</code>；</li>
<li>在<code>vue.js</code>中写单页面的代码，实现渲染一个数组的功能，对于数组的每个元素能够进行选中，也能够对数组的元素进行增删操作，测试没有绑定<code>key</code>时，手动增（<code>unshift()方法</code>）添加数组元素时会对与选择的元素进行影响；</li>
</ol>
<p><strong>总结：React 中使用map函数或者Vue中使用 v-for 循环，若想保持数组元素的状态（如：是否选中，Vue中动画），就一定要对key属性进行绑定；在React中，需要把key添加给被forEach或map或for循环直接控制的元素；</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; arrStr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">key</span>= <span class="string">&#123;</span> <span class="attr">item.id</span> &#125;&gt;</span> item <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span> &#125;) &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-关于jsx语法的注意事项"><a href="#2-2-关于jsx语法的注意事项" class="headerlink" title="2.2.关于jsx语法的注意事项"></a>2.2.关于jsx语法的注意事项</h2><ol>
<li>在JSX 中写注释：<ul>
<li>多行注释（<strong>推荐使用</strong>）： <code>{/* 注释的内容 */}</code></li>
<li>单行注释：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注释的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在JSX中的元素添加<code>class</code>类名：使用<code>className</code>替代<code>class</code>；其次，使用<code>htmlFor</code>替换<code>label</code>标签的<code>for</code>属性，两者原因是由于<code>class for</code>也是JavaScript中关键字，会出现冲突；</li>
<li>在JSX创建DOM的时候，所有的节点必须由唯一的根元素进行包裹，如 <code>&lt;div&gt;...&lt;/div&gt;</code>；</li>
<li>在JSX语法中，标签必须成对出现，如果是单标签，一定要自闭合，如 <code>&lt;hr/&gt;</code>；</li>
</ol>
<h2 id="2-3-创建组件的第一种方式并为组件传递props数据"><a href="#2-3-创建组件的第一种方式并为组件传递props数据" class="headerlink" title="2.3.创建组件的第一种方式并为组件传递props数据"></a>2.3.创建组件的第一种方式并为组件传递props数据</h2><h3 id="2-3-1-使用构造函数来创建组件，并为组件传递数据"><a href="#2-3-1-使用构造函数来创建组件，并为组件传递数据" class="headerlink" title="2.3.1 使用构造函数来创建组件，并为组件传递数据"></a>2.3.1 使用构造函数来创建组件，并为组件传递数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种创建组件的方式，注意组件的首字母必须有大写，调用的时候也是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span> (<span class="params">props</span>) </span>&#123; <span class="comment">// props 用于接收参数，该属性是只读的（在Vue中该属性也是只读的，不能被重新赋值）</span></span><br><span class="line">  <span class="comment">// return null 表示此组件什么都不渲染</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'props:'</span>,props)</span><br><span class="line">  <span class="comment">// 在组件中必须返回一个合法的 JSX 虚拟DOM元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    这是 Hello 组件</span></span><br><span class="line"><span class="xml">    -- &#123;props.name&#125;</span></span><br><span class="line"><span class="xml">    -- &#123;props.age&#125;</span></span><br><span class="line"><span class="xml">    -- &#123;props.gender&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">"大黄"</span>,</span><br><span class="line">  age: <span class="number">5</span>,</span><br><span class="line">  gender: <span class="string">"公"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello name= &#123;dog.name&#125; age= &#123;dog.age&#125; gender= &#123;dog.gender&#125; &gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-使用ES6的展开运算符简化传递props数据的过程"><a href="#2-4-使用ES6的展开运算符简化传递props数据的过程" class="headerlink" title="2.4.使用ES6的展开运算符简化传递props数据的过程"></a>2.4.使用ES6的展开运算符简化传递props数据的过程</h2><blockquote>
<p>一定要熟悉使用JavaScript的知识（ES5/6/7 语法知识）；</p>
</blockquote>
<h3 id="2-4-1-使用ES6的展开运算符（-）传递对象、数组数据"><a href="#2-4-1-使用ES6的展开运算符（-）传递对象、数组数据" class="headerlink" title="2.4.1 使用ES6的展开运算符（...）传递对象、数组数据"></a>2.4.1 使用ES6的展开运算符（<code>...</code>）传递对象、数组数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Hello name= &#123;dog.name&#125; age= &#123;dog.age&#125; gender= &#123;dog.gender&#125; &gt;&lt;/Hello&gt; */</span> &#125;</span><br><span class="line">    &lt;Hello &#123;...dog&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-将组件抽离为单独的-jsx文件"><a href="#2-5-将组件抽离为单独的-jsx文件" class="headerlink" title="2.5.将组件抽离为单独的.jsx文件"></a>2.5.将组件抽离为单独的.jsx文件</h2><ol>
<li>将组件的代码抽离到单独的文件中，使用<code>export default xxx</code>暴露出去组件；</li>
<li>使用<code>import xxx from &#39;...&#39;</code>需要导入组件，不要省略后缀名；</li>
<li>注意还需要在抽离出去的单独文件中增加：<code>import React from &#39;react&#39;</code>，是由于在抽离的文件中使用了<code>JSX</code>的语法；</li>
</ol>
<h2 id="2-6-配置webpack从而在导入组件的时候，省略-jsx后缀名"><a href="#2-6-配置webpack从而在导入组件的时候，省略-jsx后缀名" class="headerlink" title="2.6.配置webpack从而在导入组件的时候，省略.jsx后缀名"></a>2.6.配置webpack从而在导入组件的时候，省略.jsx后缀名</h2><blockquote>
<p>在<code>webpack.config.js</code>配置文件导出的对象中增加下面的代码，注意是与<code>module</code>平级：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],  <span class="comment">// 表示这几个文件的后缀名可以省略不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-配置webpack设置根目录"><a href="#2-7-配置webpack设置根目录" class="headerlink" title="2.7.配置webpack设置根目录"></a>2.7.配置webpack设置根目录</h2><h3 id="2-7-1-设置src代码目录为"><a href="#2-7-1-设置src代码目录为" class="headerlink" title="2.7.1 设置src代码目录为@"></a>2.7.1 设置src代码目录为@</h3><blockquote>
<p>在<code>webpack.config.js</code>配置文件导出的对象中<code>resolve</code>下面增加代码，注意是与上面的 <code>extensions</code>平级：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],  <span class="comment">// 表示这几个文件的后缀名可以省略不写</span></span><br><span class="line">  alias:&#123;  <span class="comment">// 表示别名</span></span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'./src'</span>),  <span class="comment">// 这样 @ 符号就表示根目录中src的这一层</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-class-创建类并通过constructor挂载实例属性"><a href="#2-8-class-创建类并通过constructor挂载实例属性" class="headerlink" title="2.8.class-创建类并通过constructor挂载实例属性"></a>2.8.class-创建类并通过constructor挂载实例属性</h2><h3 id="2-8-1-ES6-中class的使用"><a href="#2-8-1-ES6-中class的使用" class="headerlink" title="2.8.1 ES6 中class的使用"></a>2.8.1 ES6 中class的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.普通的构造函数创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= name;  <span class="comment">// 通过new出来的实例的this挂载的属性称为实例属性；</span></span><br><span class="line">  <span class="keyword">this</span>.age= age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1= <span class="keyword">new</span> Person(<span class="string">'大黑'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用class关键字创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是类中的构造器，每个类中都有一个构造器，若不写，也会默认有一个空的constructor构造器</span></span><br><span class="line">  <span class="comment">// 构造器作用：使用new的时候默认执行构造器constructor中的代码</span></span><br><span class="line">  <span class="keyword">constructor</span> () (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;  <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2= <span class="keyword">new</span> Person(<span class="string">'小灰'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p2)</span><br></pre></td></tr></table></figure>

<h2 id="2-9-class-使用static创建静态属性"><a href="#2-9-class-使用static创建静态属性" class="headerlink" title="2.9.class-使用static创建静态属性"></a>2.9.class-使用static创建静态属性</h2><h3 id="2-9-1-静态属性定义"><a href="#2-9-1-静态属性定义" class="headerlink" title="2.9.1 静态属性定义"></a>2.9.1 静态属性定义</h3><p>通过构造函数直接访问到的属性称为静态属性，直接给了构造函数，不是通过this进行挂载的；</p>
<h3 id="2-9-2-静态属性使用"><a href="#2-9-2-静态属性使用" class="headerlink" title="2.9.2 静态属性使用"></a>2.9.2 静态属性使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.普通的构造函数创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= name;  <span class="comment">// 通过new出来的实例的this挂载的属性称为实例属性；</span></span><br><span class="line">  <span class="keyword">this</span>.age= age;</span><br><span class="line">&#125;</span><br><span class="line">Person.info= <span class="string">'aaa'</span>  <span class="comment">// info属性直接挂载给构造函数，称为静态属性</span></span><br><span class="line"><span class="comment">// 将实例方法挂载到Person的原型对象上</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是Person的实例方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法，实例的对象无法访问该方法，只能通过 Person.show() 进行访问，使用的少</span></span><br><span class="line">Person.show= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是Person的静态方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">const</span> p1= <span class="keyword">new</span> Person(<span class="string">'大黑'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// name 是 Person 的实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)  <span class="comment">// info 是 Person 的静态属性</span></span><br><span class="line">Person.say()  <span class="comment">// say 是 Person 的实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用class关键字创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;  <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在class内部，通过static关键字修饰出来的属性就是静态属性；</span></span><br><span class="line">  <span class="keyword">static</span> info= <span class="string">'hahh'</span>;</span><br><span class="line">  <span class="comment">// 此处也是将实例方法挂载到Person的原型对象上</span></span><br><span class="line">  eating () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是Animal的实例方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法使用static关键字，使用的少</span></span><br><span class="line">  <span class="keyword">static</span> playing () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是Animal的静态方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2= <span class="keyword">new</span> Person(<span class="string">'小灰'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p2)</span><br><span class="line"><span class="built_in">console</span>.log(p2.name)  <span class="comment">// name 是 Animal 的实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.info)  <span class="comment">// info 是 Animal 的静态属性</span></span><br><span class="line">p2.eating()  <span class="comment">// eating 是 Animal 的实例方法</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-class-实例方法和静态方法（见上方）"><a href="#2-10-class-实例方法和静态方法（见上方）" class="headerlink" title="2.10.class-实例方法和静态方法（见上方）"></a>2.10.class-实例方法和静态方法（见上方）</h2><h2 id="2-11-class-总结class的基本用法和两个注意点"><a href="#2-11-class-总结class的基本用法和两个注意点" class="headerlink" title="2.11.class-总结class的基本用法和两个注意点"></a>2.11.class-总结class的基本用法和两个注意点</h2><ul>
<li>注意点1：在class内部只能写 <code>构造器、静态属性、静态方法、实例方法</code>四种（实例属性在构造器中）；</li>
<li>注意点2：class关键字内部还是用原来的方法实现的，因此把class关键字称为 <code>语法糖</code>；</li>
</ul>
<h2 id="2-13-class-使用extends实现子类继承父类"><a href="#2-13-class-使用extends实现子类继承父类" class="headerlink" title="2.13.class-使用extends实现子类继承父类"></a>2.13.class-使用extends实现子类继承父类</h2><h3 id="2-13-1-代码案例"><a href="#2-13-1-代码案例" class="headerlink" title="2.13.1 代码案例"></a>2.13.1 代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a1= <span class="keyword">new</span> American(<span class="string">'sara'</span>, <span class="string">'21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c1= <span class="keyword">new</span> China(<span class="string">'wang'</span>, <span class="string">'21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面由于两个类的属性相同，可以通过创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a2= <span class="keyword">new</span> American2(<span class="string">'jack'</span>, <span class="string">'21'</span>)  <span class="comment">// 会自动执行父类中的构造函数</span></span><br><span class="line"><span class="keyword">const</span> c2= <span class="keyword">new</span> China2(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-14-class-子类访问父类上的实例方法"><a href="#2-14-class-子类访问父类上的实例方法" class="headerlink" title="2.14.class-子类访问父类上的实例方法"></a>2.14.class-子类访问父类上的实例方法</h2><h3 id="2-14-1-代码案例"><a href="#2-14-1-代码案例" class="headerlink" title="2.14.1 代码案例"></a>2.14.1 代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a2= <span class="keyword">new</span> American2(<span class="string">'jack'</span>, <span class="string">'21'</span>)  <span class="comment">// 会自动执行父类中的构造函数</span></span><br><span class="line">a2.say()  <span class="comment">// 调用父类中的实例方法</span></span><br><span class="line"><span class="keyword">const</span> c2= <span class="keyword">new</span> China2(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-15-class-constructor构造器中super函数的使用说明"><a href="#2-15-class-constructor构造器中super函数的使用说明" class="headerlink" title="2.15.class-constructor构造器中super函数的使用说明"></a>2.15.class-constructor构造器中super函数的使用说明</h2><h3 id="2-15-1-问题讨论及代码案例"><a href="#2-15-1-问题讨论及代码案例" class="headerlink" title="2.15.1 问题讨论及代码案例"></a>2.15.1 问题讨论及代码案例</h3><ul>
<li>为什么一定要在 <code>constructor</code>中调用<code>super()</code>?<ul>
<li>若一个子类通过 <code>extends</code>关键字继承了父类，那么子类构造器函数<code>constructor()</code>中，必须调用<code>super()</code></li>
</ul>
</li>
<li><code>super()</code>有什么作用？<ul>
<li><code>super()</code>是一个函数，是父类的构造器，子类中的<code>super()</code>就是父类中的构造器<code>constructor()</code>的引用；</li>
</ul>
</li>
<li><code>super()</code>中参数为空且没有执行的代码时，实例的对象并不会继承父类中的构造器函数中的实例属性？<ul>
<li><code>super()</code>作为父类中的构造器<code>constructor()</code>的引用，因此必须需要传递参数，因而才能正确的调用父类中的构造器函数；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，子类中实现构造器时，一定要加入`super()`方法并传递参数：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China3</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">super</span> (name ,age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c3= <span class="keyword">new</span> China3(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-16-class-为子类挂载独有的实例属性和实例方法"><a href="#2-16-class-为子类挂载独有的实例属性和实例方法" class="headerlink" title="2.16.class-为子类挂载独有的实例属性和实例方法"></a>2.16.class-为子类挂载独有的实例属性和实例方法</h2><h3 id="2-16-1-代码案例"><a href="#2-16-1-代码案例" class="headerlink" title="2.16.1 代码案例"></a>2.16.1 代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，子类中实现构造器时，一定要加入`super()`方法并传递参数，IdNumber参数是中国人独有的，因而不能挂载到父类上：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China3</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age, IdNumber) &#123;</span><br><span class="line">    <span class="keyword">super</span> (name ,age)</span><br><span class="line">    <span class="comment">// 单独在子类中使用this进行绑定；注意在子类中，this只能放在super()后面；</span></span><br><span class="line">    <span class="keyword">this</span>.IdNumber= IdNumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c3= <span class="keyword">new</span> China3(<span class="string">'li'</span>, <span class="string">'20'</span>, <span class="string">'513*********'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-17-使用class关键字创建组件"><a href="#2-17-使用class关键字创建组件" class="headerlink" title="2.17.使用class关键字创建组件"></a>2.17.使用class关键字创建组件</h2><h3 id="2-17-1-基本的class创建组件的语法"><a href="#2-17-1-基本的class创建组件的语法" class="headerlink" title="2.17.1 基本的class创建组件的语法"></a>2.17.1 基本的class创建组件的语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用class创建组件，必须要自己的组件继承自 React.Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 组件名称 <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在组件内部，必须要这个 render() 函数，该函数的作用是渲染当前组件对应的虚拟DOM结构</span></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// render() 函数必须返回合法的JSX虚拟DOM结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">di</span>&gt;</span>这是class创建的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建了的实例在使用　<code>ReactDOM.render()</code>　的时候，作为标签时相当于是使用<code>new</code>了一个实例对象</strong></p>
<h3 id="2-17-2-两种创建类的方法的对比"><a href="#2-17-2-两种创建类的方法的对比" class="headerlink" title="2.17.2 两种创建类的方法的对比"></a>2.17.2 两种创建类的方法的对比</h3><ul>
<li>用<code>构造函数</code>创建的函数，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的函数，叫做<code>有状态组件</code>；</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
</ul>
<h2 id="2-18-为class创建的组件传递props参数并直接使用this-props来访问"><a href="#2-18-为class创建的组件传递props参数并直接使用this-props来访问" class="headerlink" title="2.18.为class创建的组件传递props参数并直接使用this.props来访问"></a>2.18.为class创建的组件传递props参数并直接使用this.props来访问</h2><h3 id="2-18-1-代码案例"><a href="#2-18-1-代码案例" class="headerlink" title="2.18.1 代码案例"></a>2.18.1 代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">  <span class="comment">// 在class关键字创建的组件中，若想使用外部传递的`props`参数，直接使用`this.props.xxx`访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 注意在组件class内部，this表示当前组件的实例对象；同时props中的属性都是只读的，不能重新赋值</span></span><br><span class="line"><span class="xml">      这是Movie组件---&#123;this.props.name&#125;---&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user= &#123;</span><br><span class="line">  name: <span class="string">'wang'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Movie name= &#123;user.name&#125; age= &#123;user.age&#125;&gt;&lt;/Movie&gt; */</span>&#125;</span><br><span class="line">    &lt;Movie &#123;...age&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Movie</span>&gt;</span></span>  &#123; <span class="comment">/* ES6简写的扩展对象的语法 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-19-介绍class创建的组件中this-state"><a href="#2-19-介绍class创建的组件中this-state" class="headerlink" title="2.19.介绍class创建的组件中this.state"></a>2.19.介绍class创建的组件中this.state</h2><h3 id="2-19-1-两种创建类的方法的对比"><a href="#2-19-1-两种创建类的方法的对比" class="headerlink" title="2.19.1 两种创建类的方法的对比"></a>2.19.1 两种创建类的方法的对比</h3><blockquote>
<p>使用<code>class</code>关键字创建的组件具有自己的私有数据和生命周期函数，而使用<code>function</code>函数创建的组件只有<code>props</code>，没有自己的私有数据和生命周期函数；</p>
</blockquote>
<ol>
<li>用<code>构造函数</code>创建的函数，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的函数，叫做<code>有状态组件</code>；</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
</ol>
<h3 id="2-19-2-代码案例"><a href="#2-19-2-代码案例" class="headerlink" title="2.19.2  代码案例"></a>2.19.2  代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在自定义构造器的时候必须要调用 super()</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="comment">// 只有在调用了super() 后才能使用this关键字</span></span><br><span class="line">    <span class="keyword">this</span>.state= &#123;  <span class="comment">// 这个this.state对象相当于Vue中的data(return &#123;...&#125;)，其中的数据可读可写</span></span><br><span class="line">      msg: <span class="string">'我是class创建得Movie组件'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">  <span class="comment">// 在class关键字创建的组件中，若想使用外部传递的`props`参数，直接使用`this.props.xxx`访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 注意在组件class内部，this表示当前组件的实例对象；同时props中的属性都是只读的，不能重新赋值</span></span><br><span class="line"><span class="xml">      这是Movie组件---&#123;this.props.name&#125;---&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; this.state.msg &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user= &#123;</span><br><span class="line">  name: <span class="string">'wang'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Movie name= &#123;user.name&#125; age= &#123;user.age&#125;&gt;&lt;/Movie&gt; */</span>&#125;</span><br><span class="line">    &lt;Movie &#123;...age&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Movie</span>&gt;</span></span>  &#123; <span class="comment">/* ES6简写的扩展对象的语法 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-20-介绍有状态组件和无状态组件的区别"><a href="#2-20-介绍有状态组件和无状态组件的区别" class="headerlink" title="2.20.介绍有状态组件和无状态组件的区别"></a>2.20.介绍有状态组件和无状态组件的区别</h2><ol>
<li>用<code>构造函数</code>创建的组件，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的组件，叫做<code>有状态组件</code>；<ul>
<li>若一个组件需要有私有数据，推荐使用<code>class</code>创建的组件；</li>
</ul>
</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
<li>组件中的 <code>props</code> 和<code>state/data</code>之间的区别：<ul>
<li>props中的数据都是外界传过来的数据；</li>
<li>state/data中的数据都是组件私有的（通过Ajax获取回来的数据一般都是私有数据）；</li>
<li>props中的数据都是只读的，不可复写；</li>
<li>state/data中的数据都是可读可写；</li>
</ul>
</li>
</ol>
<h2 id="2-21-评论列表案例-创建CmtList组件并渲染基本页面结构"><a href="#2-21-评论列表案例-创建CmtList组件并渲染基本页面结构" class="headerlink" title="2.21.评论列表案例-创建CmtList组件并渲染基本页面结构"></a>2.21.评论列表案例-创建CmtList组件并渲染基本页面结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="comment">// 2. 使用class关键字创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmtlist</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'组件的state中的信息'</span>,</span><br><span class="line">      CommentList: [  <span class="comment">// 评论列表数据</span></span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">user</span>: <span class="string">'aaa'</span>, <span class="attr">content</span>: <span class="string">'内容111'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">user</span>: <span class="string">'bbb'</span>, <span class="attr">content</span>: <span class="string">'内容222'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'3'</span>, <span class="attr">user</span>: <span class="string">'ccc'</span>, <span class="attr">content</span>: <span class="string">'内容333'</span>&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;this.state.CommentList.map( (item) =&gt; &#123;</span></span><br><span class="line">        &lt;div key= &#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;评论人：&#123;item.user&#125;&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;评论内容：&#123;item.content&#125;&lt;/p&gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 使用ReactDOM.render渲染虚拟DOM到页面中</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Cmtlist</span>&gt;</span><span class="tag">&lt;/<span class="name">Cmtlist</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="2-22-评论列表案例-将评论Item项抽离为单独的CmtItem组件"><a href="#2-22-评论列表案例-将评论Item项抽离为单独的CmtItem组件" class="headerlink" title="2.22.评论列表案例-将评论Item项抽离为单独的CmtItem组件"></a>2.22.评论列表案例-将评论Item项抽离为单独的CmtItem组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用function定义每个评论项小组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>评论人：&#123;props.user&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>评论内容：&#123;props.content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用class关键字创建评论框大组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmtlist</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'组件的state中的信息'</span>,</span><br><span class="line">      CommentList: [  <span class="comment">// 评论列表数据</span></span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">user</span>: <span class="string">'aaa'</span>, <span class="attr">content</span>: <span class="string">'内容111'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">user</span>: <span class="string">'bbb'</span>, <span class="attr">content</span>: <span class="string">'内容222'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'3'</span>, <span class="attr">user</span>: <span class="string">'ccc'</span>, <span class="attr">content</span>: <span class="string">'内容333'</span>&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;this.state.CommentList.map( (item) =&gt; &#123;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>= <span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用ReactDOM.render渲染虚拟DOM到页面中</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Cmtlist</span>&gt;</span><span class="tag">&lt;/<span class="name">Cmtlist</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="2-23-评论列表案例-将评论列表组件和评论项组件抽离为单独的组件"><a href="#2-23-评论列表案例-将评论列表组件和评论项组件抽离为单独的组件" class="headerlink" title="2.23.评论列表案例-将评论列表组件和评论项组件抽离为单独的组件"></a>2.23.评论列表案例-将评论列表组件和评论项组件抽离为单独的组件</h2><p>关键点是使用<code>export default</code>进行组件暴露出去，再使用<code>import xxx from &#39;...&#39;</code>进行组件的引入；</p>
<p><strong>注意：在抽离出去的组件中，按需添加导入<code>import React from &#39;react&#39;</code>和其关联的子组件；</strong></p>
<h2 id="2-24-评论列表案例-演示-符号替代相对路径的好处"><a href="#2-24-评论列表案例-演示-符号替代相对路径的好处" class="headerlink" title="2.24.评论列表案例-演示@符号替代相对路径的好处"></a>2.24.评论列表案例-演示@符号替代相对路径的好处</h2><p>由于在抽离子组件的过程中，对于有父子包含关系的组件的导入时，需要注意引入的路径的问题，因而考虑使用绝对路径进行子组件的导入；在<code>webpack.config.js</code>配置文件导出的对象中<code>resolve</code>下面的<code>alias</code>属性，使用<code>@</code>符号表示<code>src</code>代码目录，因而在项目中使用<code>@</code>符号进行路径信息导入；</p>
<h1 id="3-React-样式"><a href="#3-React-样式" class="headerlink" title="3. React 样式"></a>3. React 样式</h1><h2 id="3-1-在组件中使用style行内样式并封装样式对象"><a href="#3-1-在组件中使用style行内样式并封装样式对象" class="headerlink" title="3.1.在组件中使用style行内样式并封装样式对象"></a>3.1.在组件中使用style行内样式并封装样式对象</h2><h3 id="3-1-1-代码案例（上一天的评论组件案例代码）"><a href="#3-1-1-代码案例（上一天的评论组件案例代码）" class="headerlink" title="3.1.1 代码案例（上一天的评论组件案例代码）"></a>3.1.1 代码案例（上一天的评论组件案例代码）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 注意：在JSX中，若设置行内样式时，不能为 style 设置 字符串的值，而是该 tyle= &#123; &#123;color: 'red'&#125; &#125; 这么写，</span></span><br><span class="line"><span class="xml">    之前的css属性中有连字符 - 时，需要用单引号包裹，或者写成大写字母；同时行内样式中是数值类型的样式，可以不用引号包裹，</span></span><br><span class="line"><span class="xml">    而字符串类型的样式值必须用引号包裹，见下方的代码 */&#125;</span></span><br><span class="line"><span class="xml">    &#123;/* <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>= <span class="string">"color: red"</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>= <span class="string">&#123;</span> &#123; <span class="attr">color:</span> '<span class="attr">red</span>', <span class="attr">fontSize:</span> '<span class="attr">14px</span>', <span class="attr">zIndex:</span> <span class="attr">10</span> &#125; &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-对样式代码进行封装抽离"><a href="#3-1-2-对样式代码进行封装抽离" class="headerlink" title="3.1.2 对样式代码进行封装抽离"></a>3.1.2 对样式代码进行封装抽离</h3><ul>
<li>从JSX代码中抽离代码成一个样式对象；</li>
<li>对于多个抽离出来的各个样式对象组成一个大的样式对象；</li>
<li>对于大的样式对象单独提到一个样式对象的JS文件中，通过<code>export default</code>进行导出，<code>import xxx from &#39;xxx&#39;</code>进行导入；</li>
</ul>
<h2 id="3-2-使用css样式表美化组件"><a href="#3-2-使用css样式表美化组件" class="headerlink" title="3.2.使用css样式表美化组件"></a>3.2.使用css样式表美化组件</h2><h3 id="3-2-1-使用-className-进行样式的添加"><a href="#3-2-1-使用-className-进行样式的添加" class="headerlink" title="3.2.1 使用 className 进行样式的添加"></a>3.2.1 使用 className 进行样式的添加</h3><blockquote>
<p>项目使用 <code>css</code> 样式文件步骤：</p>
</blockquote>
<ol>
<li>安装<code>style-loader css-loader</code> 插件：<code>npm i style-loader css-loader -D</code>；</li>
<li>配置<code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>增加下面的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,  <span class="comment">// 打包处理 css 样式表的第三方loader，顺序是逆序，先是'css-loader'处理，再'style-loader'处理；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在JSX代码引入引入写好的样式文件，使用<code>className</code>替代原来的<code>class</code>引入对于的class样式；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 此处的 title 是在导入的css文件中编写的 class 样式，导入通过 ： import xxx from 'xxx.css' */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">"title"</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-演示React中使用普通-css-样式表的作用域冲突问题"><a href="#3-3-演示React中使用普通-css-样式表的作用域冲突问题" class="headerlink" title="3.3.演示React中使用普通 css 样式表的作用域冲突问题"></a>3.3.演示React中使用普通 css 样式表的作用域冲突问题</h2><h3 id="3-3-1-思考问题"><a href="#3-3-1-思考问题" class="headerlink" title="3.3.1 思考问题"></a>3.3.1 思考问题</h3><ol>
<li>问题1：引入的样式文件只在该文件中生效吗？<ul>
<li>经过测试发现，直接导入的css样式表默认是会在整个项目（全局）都生效，原因是由于样式表没有作用域；</li>
</ul>
</li>
<li>问题2：Vue组件中中的样式表是否也有样式表冲突的问题，怎么解决呢？<ul>
<li>Vue中通过 <code>&lt;style scoped&gt;&lt;/style&gt;</code>进行局部样式设置；</li>
</ul>
</li>
<li>问题3：React 中是否有和Vue 中一样的 <code>scoped</code> 指令呢？<ul>
<li>React 中没有指令的概念；</li>
</ul>
</li>
</ol>
<h2 id="3-4-为普通样式表通过-modules-参数启用模块化"><a href="#3-4-为普通样式表通过-modules-参数启用模块化" class="headerlink" title="3.4.为普通样式表通过 modules 参数启用模块化"></a>3.4.为普通样式表通过 modules 参数启用模块化</h2><h3 id="3-4-1-启用Css样式表的模块化功能"><a href="#3-4-1-启用Css样式表的模块化功能" class="headerlink" title="3.4.1 启用Css样式表的模块化功能"></a>3.4.1 启用Css样式表的模块化功能</h3><ul>
<li>配置<code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的css文件的第三分loader增加参数，方式是通过问号增加参数，其中有个固定的参数 modules 表示为普通的css样式表启用模块化，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader?modules'</span>] &#125;,  modules 参数只有 css-loader 才能使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改在通过<code>className</code>引入的样式表的值需要进行修改，使用的为引入的那个样式对象的名加属性名：<code>className= {xxx.title}</code></li>
</ul>
<p><strong>注意：css模块化只是针对类选择器(className= {…})和ID(id={…})选择器生效，对于普通的css标签选择器不会进行模块化</strong></p>
<h2 id="3-5-使用localIdentName来自定义模块化的类名"><a href="#3-5-使用localIdentName来自定义模块化的类名" class="headerlink" title="3.5.使用localIdentName来自定义模块化的类名"></a>3.5.使用localIdentName来自定义模块化的类名</h2><h3 id="3-5-1-自定义模块化样式表的名字，可选的参数有："><a href="#3-5-1-自定义模块化样式表的名字，可选的参数有：" class="headerlink" title="3.5.1 自定义模块化样式表的名字，可选的参数有："></a>3.5.1 自定义模块化样式表的名字，可选的参数有：</h3><ul>
<li>[path] ：表示样式表相对于项目根目录的路径；</li>
<li>[name]：表示样式表文件名称；</li>
<li>[local]：表示样式的类名定义名称；</li>
<li>[hash:length]：表示32位的hash值，可选值小于32就行；</li>
</ul>
<h3 id="3-5-2-代码案例"><a href="#3-5-2-代码案例" class="headerlink" title="3.5.2 代码案例"></a>3.5.2 代码案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span> ] &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-通过local和global设置类名是否被模块化"><a href="#3-6-通过local和global设置类名是否被模块化" class="headerlink" title="3.6.通过local和global设置类名是否被模块化"></a>3.6.通过local和global设置类名是否被模块化</h2><h3 id="3-6-1-global-设置全局的class类"><a href="#3-6-1-global-设置全局的class类" class="headerlink" title="3.6.1 global 设置全局的class类"></a>3.6.1 global 设置全局的class类</h3><p>在css样式表的文件中加入 <code>:global()</code>，让被包裹的类名不被模块化，而是作为全局使用，写法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:global(.red)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在同一个元素上增加两个或多个类名方式可以是如下两种：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">&#123;</span> <span class="attr">title</span> + ' ' + '<span class="attr">red</span>' &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">&#123;</span> [<span class="attr">title</span>, '<span class="attr">red</span>']<span class="attr">.join</span>(' ') &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-local-设置局部的class类"><a href="#3-6-2-local-设置局部的class类" class="headerlink" title="3.6.2 local 设置局部的class类"></a>3.6.2 local 设置局部的class类</h3><p>在css样式表的文件中加入 <code>:local()</code>，让被包裹的类名被模块化，而是作为局部使用，与不写的效果一直，是默认的行为；</p>
<h2 id="3-7-在项目中为scss或less文件启用模块化"><a href="#3-7-在项目中为scss或less文件启用模块化" class="headerlink" title="3.7.在项目中为scss或less文件启用模块化"></a>3.7.在项目中为scss或less文件启用模块化</h2><h3 id="3-7-1-导入第三方样式，如-Bootstrap"><a href="#3-7-1-导入第三方样式，如-Bootstrap" class="headerlink" title="3.7.1 导入第三方样式，如 Bootstrap"></a>3.7.1 导入第三方样式，如 Bootstrap</h3><ol>
<li>安装 <code>Bootstrap</code> 第三方插件，执行 <code>npm i bootstrape@3.3.7 -S</code> 指令；</li>
<li>在项目的代码中进行 <code>Bootstrap</code> 样式代码进行导入，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入的包为 node_modules 目录中时，可以省略node_modules 目录，直接以包名开始引入自己的模块</span></span><br><span class="line"><span class="keyword">import</span> bootCss <span class="keyword">from</span> <span class="string">'bootstrap/dist/css/bootsrtap.css'</span>  <span class="comment">// 引入Bootstrap包的代码</span></span><br></pre></td></tr></table></figure></li>
<li>根据当前的报错提示信息发现，webpack无法处理一些图片文件，先下载第三方loader，执行<code>npm i url-loader file-loader -D</code>指令；再配置 <code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的参数增加代码，重新启动项目后生效：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span> ] &#125;,</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.ttf|woff|woff2|eot|svg$/</span>, <span class="attr">use</span>: [ <span class="string">'url-loader'</span> ]&#125;, <span class="comment">// 打包处理字体文件的loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意在使用的时候，对于样式文件做了模块化处理，使用的方式变为上面使用对象的形式使用(使用有点儿麻烦)：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用bootstrap中的按钮的样式 btn btn-pramery ，如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>= <span class="string">&#123;</span> [<span class="attr">bootCss.btn</span>, <span class="attr">bootCss</span>['<span class="attr">btn-primary</span>']]<span class="attr">.join</span>(' ') &#125;&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>希望使用第三方的样式文件Bootstrap的方式，如下面这种样式：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用bootstrap中的按钮的样式 btn btn-pramery ，如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>= <span class="string">"btn btn-primary"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>发现第三方的样式表都是以<code>.css</code>结尾，那么我们自己定义的样式文件可以使用<code>sass less stylus</code>来写样式文件，因而配置样式表的模块化中，换为<code>.scss .less .stylus</code>结尾的样式文件进行模块化处理，先需要安装这些样式文件的第三方loader插件，<code>scss</code> 安装执行<code>npm i saaa-loader node-sass -D</code>；再配置 <code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的参数，导入样式改为<code>import &#39;bootstrap/dist/css/bootsrtap.css&#39;</code>测试验证能够正确使用：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ] &#125;,</span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.ttf|woff|woff2|eot|svg$/</span>, <span class="attr">use</span>: [ <span class="string">'url-loader'</span> ] &#125;, <span class="comment">// 打包处理字体文件的loader</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span>, <span class="string">'sass-loader'</span>] &#125; <span class="comment">// 打包处理scss文件的loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-8-在React中为按钮绑定点击事件"><a href="#3-8-在React中为按钮绑定点击事件" class="headerlink" title="3.8.在React中为按钮绑定点击事件"></a>3.8.在React中为按钮绑定点击事件</h2><h3 id="3-8-1-React-的事件绑定机制"><a href="#3-8-1-React-的事件绑定机制" class="headerlink" title="3.8.1 React 的事件绑定机制"></a>3.8.1 React 的事件绑定机制</h3><ul>
<li>在React中的事件绑定机制中，事件名为驼峰式格式，事件的值是一个<code>Function</code></li>
<li>React中的事件处理函数的语法格式为<code>onClick= { function }</code>，可以将该函数抽离出去，与<code>render()</code>函数同级，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    // 事件的值直接是一个function 匿名函数</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> <span class="attr">function</span> () &#123; <span class="attr">console.log</span>('按钮点击事件触发') &#125; &#125;&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    // 注意此处函数引用不能给方法带小括号，带上小括号的意思是自执行函数；不过目前看来参数是个问题</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> <span class="attr">this.myFunction</span> &#125;&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是一个实例方法</span></span><br><span class="line">myFunction () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'按钮点击事件触发'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用的最多的事件绑定形式为：(是由于箭头函数是个匿名函数，注意this的指向就行)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.myFunction('传参') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事件处理函数需要定义为一个箭头函数，然后复制给函数名称</span></span><br><span class="line">myFunction = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'按钮点击事件触发，参数为：'</span>+ arg )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个完整的构组件的代码</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  construcroe () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'hahaha'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.show('参数1', '参数2') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  show = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'触发点击事件--'</span>+ arg1+ arg2 )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-使用this-setState修改state上的数据"><a href="#3-9-使用this-setState修改state上的数据" class="headerlink" title="3.9.使用this.setState修改state上的数据"></a>3.9.使用this.setState修改state上的数据</h2><h3 id="3-9-1-实现点击按钮，操作state中的数据"><a href="#3-9-1-实现点击按钮，操作state中的数据" class="headerlink" title="3.9.1 实现点击按钮，操作state中的数据"></a>3.9.1 实现点击按钮，操作state中的数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'触发点击事件--'</span>+ arg1+ arg2 )</span><br><span class="line">  <span class="comment">// React中，使用setState()方法改变state中的数据状态值，并自动进行页面重新渲染，而直接 this.state.msg 形式修改数据后不会重新渲染；</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    msg: <span class="string">'12345'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-this-setState的两个注意点"><a href="#3-10-this-setState的两个注意点" class="headerlink" title="3.10.this.setState的两个注意点"></a>3.10.this.setState的两个注意点</h2><ul>
<li>在 <code>this.setState({})</code>中，只会把对应的数据状态更新，而不会覆盖其他的数据状态；</li>
<li><code>this.setState({})</code>中的代码时异步执行的，若在<code>this.setState({})</code>执行完毕后，又想立即拿到最新值，不能使用<code>this.state.msg</code>直接去取，而是使用<code>this.setState({},callback)</code>，用回调函数来获取最新的状态值；</li>
</ul>
<h2 id="3-11-React中绑定文本框与State中的值"><a href="#3-11-React中绑定文本框与State中的值" class="headerlink" title="3.11.React中绑定文本框与State中的值"></a>3.11.React中绑定文本框与State中的值</h2><p>默认情况下，在React中，如果页面的表单元素绑定了 <code>state</code> 上的数据的状态值，那么每当 <code>state</code> 上的状态值变换，必然会自动把最新的状态值同步到页面上：</p>
<blockquote>
<p>单项数据绑定：状态值变化-&gt;自动更新页面数据；</p>
</blockquote>
<p>若是UI页面的文本框内容变化时，需要将变化同步到 <code>state</code> 中去，此时React中没有这种自动同步机制，需要程序员手动监听文本框内容的变化 <code>onChange</code> 事件，在 <code>onChange</code> 事件中拿到最新的文本框的值(方案1：使用<code>e</code>事件进行获取；方案2：使用<code>ref</code>属性获取元素 )，再通过手动调用 <code>this.setState({})</code>手动把值同步到 <code>state</code> 中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.show('参数1', '参数2') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 若直接把文本框的 value 属性，绑定到了state 的数据状态值，而不提供 onChange 处理函数，</span></span><br><span class="line"><span class="xml">    得到的文本框是一个只读的文本框；当文本框绑定 value 值后，要么提供一个 readyOnly ，要么提供</span></span><br><span class="line"><span class="xml">    一个 onChange 处理函数 */&#125;</span></span><br><span class="line">    &#123;/* &lt;input type= "text" style= &#123; &#123;width: '100%'&#125; &#125; value= &#123;this.state.msg&#125; readOnly /&gt; */&#125;</span><br><span class="line"></span><br><span class="line">    &lt;input type= "text" style= &#123; &#123;width: '100%'&#125; &#125; value= &#123;this.state.msg&#125; onChange= &#123; (e) =&gt; this.changeEvent(e) &#125; ref= "txt" /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">// 每当文本框内容变换时，必将会调用这个函数</span><br><span class="line">changeEvent= (e) =&gt; &#123;</span><br><span class="line">  console.log('文本框内容变换时触发')</span><br><span class="line">  // 方案1：使用`e`事件进行获取</span><br><span class="line">  // console.log(e.target.value)</span><br><span class="line">  // 方案2：使用`ref`属性获取元素</span><br><span class="line">  console.log(this.refs.txt.value)</span><br><span class="line">  // 调用 this.setState(&#123; &#125;) 改变 state 中的数据的状态值</span><br><span class="line">  const newVal= e.target.value;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    msg: newVal,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-拓展-Vue中实例的生命周期"><a href="#3-12-拓展-Vue中实例的生命周期" class="headerlink" title="3.12.拓展-Vue中实例的生命周期"></a>3.12.拓展-Vue中实例的生命周期</h2><p>每个组件的实例，从 <code>创建-&gt;运行-&gt;销毁</code> 这个过程中，这些事件就叫做组件的生命周期函数；分析对比 <code>Vue</code>和 <code>React</code> 的生命周期函数；</p>
<h3 id="3-12-2-Vue-组件的生命周期函数"><a href="#3-12-2-Vue-组件的生命周期函数" class="headerlink" title="3.12.2 Vue 组件的生命周期函数"></a>3.12.2 Vue 组件的生命周期函数</h3><blockquote>
<p>参考Vue官方文档中的Vue声明周期函数的图示进行分析：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">Vue生命周期图示</a></p>
</blockquote>
<h4 id="3-12-2-1-Vue-组件的创建阶段"><a href="#3-12-2-1-Vue-组件的创建阶段" class="headerlink" title="3.12.2.1 Vue 组件的创建阶段"></a>3.12.2.1 Vue 组件的创建阶段</h4><ol>
<li>Init Event &amp; LifeCycle：初始化<code>Vue事件</code>和<code>Vue的声明周期函数</code>；</li>
<li><code>beforeCreate</code>：这是组件创建阶段的第一个声明周期函数，此时组件的<code>data</code>和<code>methods</code>以及页面的DOM结构都还没有初始化，因而什么都做不了；</li>
<li>Init injection &amp; reactivity：初始化<code>data</code>和<code>methods</code>中的数据和方法；</li>
<li><code>created</code>：这个是组件创建阶段的第二个生命周期函数，此时组件的<code>data</code>和<code>methods</code>已经可用了，但是页面还没有渲染出效果来，因而在这个生命周期中常常会发起 <code>Ajax</code> 请求；</li>
<li>Has ‘el’ option?：判断传入的Vue对象是否有<code>el</code>，有的话就进行编译控制区域的代码；没有的话就等待，直到<code>vm.$mounted(el)</code>手动渲染，也进行编译控制区域的代码 (把 data 上的数据拿到，并解析执行模板结构中的指令，当所有的指令解析完毕，那么模板页面就渲染到<code>内存</code>中了，此时模板页面还没有挂载到页面上，仅仅存放在内存中，因而用户还看不到效果)；</li>
<li><code>beforMount</code>：这是组件创建阶段的第三个声明周期函数，此时模板结构在内存中已经编译完成，还没有真正渲染到页面中，此时看到的只是模板页面，没有进行数据的渲染；</li>
<li>Create vm.$el and replace ‘el’ with it：这一步正在把内存中渲染好的模板结构替换到页面上；</li>
<li><code>mounted</code>：这个是组件创建阶段的第四个生命周期函数，此时页面已经真正的渲染好了，用户已经可以看到真实的页面数据；当这个生命周期函数执行完，组件的<code>创建阶段</code>就完成了，进入到了组件的<code>运行阶段</code>；若大家用到了一些第三方的UI插件，而且这些插件需要被初始化，那么必须在<code>mounted</code>中进行初始化插件；</li>
</ol>
<h4 id="3-12-2-2-Vue-组件的运行阶段"><a href="#3-12-2-2-Vue-组件的运行阶段" class="headerlink" title="3.12.2.2 Vue 组件的运行阶段"></a>3.12.2.2 Vue 组件的运行阶段</h4><p>按需根据 <code>data</code> 数据的变化，有选择性的执行 0 到 N 次；</p>
<ol>
<li><code>beforUpdate</code>：在这个生命周期函数中，数据是最新的数据，而在页面中呈现出的数据还是旧数据；</li>
<li>Virtual DOM re-render and patch：这个阶段是根据最新的 <code>data</code> 数据，重新渲染模板结构到内存中，并把渲染好的模板结构替换到页面上；</li>
<li><code>updated</code>：在这个生命周期函数中，页面已经完成了更新，<code>data</code>数据是最新的，页面中呈现的数据也是最新的；</li>
</ol>
<h4 id="3-12-2-3-Vue-组件的销毁阶段"><a href="#3-12-2-3-Vue-组件的销毁阶段" class="headerlink" title="3.12.2.3 Vue 组件的销毁阶段"></a>3.12.2.3 Vue 组件的销毁阶段</h4><ol>
<li><code>beforeDestroy</code>：这个生命周期函数会在 <code>vm.$destroy()</code>被调用时触发，只是表示改组件即将被销毁；此时组件还是可用的，比如其中的<code>data</code>和<code>methods</code>等数据方法，可正常访问；</li>
<li>Teardown watchers ,child components and event listeners：执行销毁处理操作，清理 <code>检测器 子组件 事件监听器</code>；</li>
<li><code>destroyed</code>：在这个生命周期函数中，组件已经完成销毁，其中的<code>data</code>和<code>methods</code>等数据方法都不可访问使用；</li>
</ol>
<h2 id="3-13-拓展-Vue中实例的生命周期2（见上方）"><a href="#3-13-拓展-Vue中实例的生命周期2（见上方）" class="headerlink" title="3.13.拓展-Vue中实例的生命周期2（见上方）"></a>3.13.拓展-Vue中实例的生命周期2（见上方）</h2><h2 id="3-14-快速梳理React的组件生命周期函数图"><a href="#3-14-快速梳理React的组件生命周期函数图" class="headerlink" title="3.14.快速梳理React的组件生命周期函数图"></a>3.14.快速梳理React的组件生命周期函数图</h2><blockquote>
<p>参考React官方文档中的React生命周期函数的图示进行分析：<a href="https://react.docschina.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">React生命周期图示</a></p>
</blockquote>
<h3 id="3-14-1-React-组件的创建阶段"><a href="#3-14-1-React-组件的创建阶段" class="headerlink" title="3.14.1 React 组件的创建阶段"></a>3.14.1 React 组件的创建阶段</h3><p>永远只执行一次；</p>
<ol>
<li><code>componentWillMount</code>：</li>
<li><code>render</code>：</li>
<li><code>componentDidMount</code>：</li>
</ol>
<h3 id="3-14-2-React-组件的运行阶段"><a href="#3-14-2-React-组件的运行阶段" class="headerlink" title="3.14.2 React 组件的运行阶段"></a>3.14.2 React 组件的运行阶段</h3><p>按需根据 <code>props</code> 属性或 <code>state</code> 状态的改变，有选择性的执行 0 到多次；</p>
<ol>
<li><code>componentWillReceiveProps</code>：</li>
<li><code>shouldcomponentUpdate</code>：</li>
<li><code>componentWillUpdate</code>：</li>
<li><code>render</code>：</li>
<li><code>componentDidUpdate</code>：</li>
</ol>
<h3 id="3-14-3-React-组件的销毁阶段"><a href="#3-14-3-React-组件的销毁阶段" class="headerlink" title="3.14.3 React 组件的销毁阶段"></a>3.14.3 React 组件的销毁阶段</h3><p>永远只执行一次；</p>
<ol>
<li><code>componentWillUnmount</code>：</li>
</ol>

    </div>

    
    
    

    
    <div>
      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　本文结束　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div>
    
</div>

      
    </div>
      

        <div class="reward-container">
  <div><p style="font-size:14px; color:#34495e; margin:0 0 5px 0;">赞赏一下吧～ 还可以关注公众号订阅最新内容</p></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="GeekLeng WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="GeekLeng Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a>
              <a href="/tags/Webpack/" rel="tag"><i class="fa fa-tag"></i> Webpack</a>
              <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/" rel="tag"><i class="fa fa-tag"></i> 前端框架知识</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/23/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="VuxUI组件库学习笔记">
      <i class="fa fa-chevron-left"></i> VuxUI组件库学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/29/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8axios%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/" rel="next" title="Vue项目中使用axios进行跨域请求">
      Vue项目中使用axios进行跨域请求 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React基础学习笔记"><span class="nav-text">React基础学习笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-React-基础"><span class="nav-text">1. React 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-介绍react"><span class="nav-text">1.1 介绍react</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-三大框架的现状"><span class="nav-text">1.2.三大框架的现状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-从组件化方面对比React和Vue"><span class="nav-text">1.3.从组件化方面对比React和Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-组件化方面"><span class="nav-text">1.3.1 组件化方面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-从其它角度对比React和Vue"><span class="nav-text">1.4.从其它角度对比React和Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-开发团队方面"><span class="nav-text">1.4.1 开发团队方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-社区方面"><span class="nav-text">1.4.2 社区方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-移动App体验方面"><span class="nav-text">1.4.3 移动App体验方面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-为什么要学习React"><span class="nav-text">1.5.为什么要学习React</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-介绍DOM和虚拟DOM的概念"><span class="nav-text">1.6.介绍DOM和虚拟DOM的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-虚拟DOM"><span class="nav-text">1.6.1 虚拟DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-diff-算法（下方）"><span class="nav-text">1.6.2 diff 算法（下方）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-虚拟DOM的本质和目的"><span class="nav-text">1.7.虚拟DOM的本质和目的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-实际的列表排序案例进行分析"><span class="nav-text">1.7.1 实际的列表排序案例进行分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-虚拟DOM概念总结"><span class="nav-text">1.7.2 虚拟DOM概念总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-介绍Diff算法的概念"><span class="nav-text">1.8.介绍Diff算法的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-1-tree-diff"><span class="nav-text">1.8.1 tree diff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-2-component-diff"><span class="nav-text">1.8.2 component diff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-3-element-diff"><span class="nav-text">1.8.3 element diff</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-webpack-4-x-最基本的使用步骤"><span class="nav-text">1.9.webpack 4.x 最基本的使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-1-使用webpack创建React的项目的步骤"><span class="nav-text">1.9.1 使用webpack创建React的项目的步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-关于Node和Chrome之间的关系"><span class="nav-text">1.10.关于Node和Chrome之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-1-module-export-和-export-default-的区别"><span class="nav-text">1.10.1 module.export&#x3D; {}和 export default {}的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-2-哪些是Node支持的特性？"><span class="nav-text">1.10.2 哪些是Node支持的特性？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-webpack-dev-server的基本使用"><span class="nav-text">1.11.webpack-dev-server的基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-1-安装使用webpack-dev-server进行自动编译打包"><span class="nav-text">1.11.1 安装使用webpack-dev-server进行自动编译打包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-配置-html-webpack-plugin-插件"><span class="nav-text">1.12.配置 html-webpack-plugin 插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-1-html-webpack-plugin-插件作用"><span class="nav-text">1.12.1 html-webpack-plugin 插件作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-使用React渲染最基本的虚拟DOM到页面上"><span class="nav-text">1.13.使用React渲染最基本的虚拟DOM到页面上</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-1-React-的安装和使用"><span class="nav-text">1.13.1 React 的安装和使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-使用React-createElement实现虚拟DOM嵌套"><span class="nav-text">1.14.使用React.createElement实现虚拟DOM嵌套</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-1-测试使用React-createElement建立虚拟DOM代码"><span class="nav-text">1.14.1 测试使用React.createElement建立虚拟DOM代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-2-使用babel插件，直接写HTML代码"><span class="nav-text">1.14.2 使用babel插件，直接写HTML代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-在React项目中启用JSX语法"><span class="nav-text">1.15.在React项目中启用JSX语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-1-最基础的JSX语法代码"><span class="nav-text">1.15.1 最基础的JSX语法代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-2-使用babel插件，直接写HTML代码"><span class="nav-text">1.15.2 使用babel插件，直接写HTML代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-3-babel-插件的安装使用"><span class="nav-text">1.15.3 babel 插件的安装使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-16-在JSX中书写JS代码"><span class="nav-text">1.16.在JSX中书写JS代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-1-在JSX中混合写入js表达式"><span class="nav-text">1.16.1 在JSX中混合写入js表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-17-将普通字符串数组，转为jsx数组并渲染到页面上"><span class="nav-text">1.17.将普通字符串数组，转为jsx数组并渲染到页面上</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-1-方法一：手动在外部进行for循环"><span class="nav-text">1.17.1 方法一：手动在外部进行for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-2-方法二：直接在内部进行for循环，使用map函数"><span class="nav-text">1.17.2 方法二：直接在内部进行for循环，使用map函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-React-组件"><span class="nav-text">2. React 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-演示Vue和React中key的作用"><span class="nav-text">2.1.演示Vue和React中key的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-编程中对于JavaScript语句后面是否加分号的问题"><span class="nav-text">2.1.1 编程中对于JavaScript语句后面是否加分号的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-测试数组中key的作用"><span class="nav-text">2.1.2 测试数组中key的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-关于jsx语法的注意事项"><span class="nav-text">2.2.关于jsx语法的注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-创建组件的第一种方式并为组件传递props数据"><span class="nav-text">2.3.创建组件的第一种方式并为组件传递props数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-使用构造函数来创建组件，并为组件传递数据"><span class="nav-text">2.3.1 使用构造函数来创建组件，并为组件传递数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-使用ES6的展开运算符简化传递props数据的过程"><span class="nav-text">2.4.使用ES6的展开运算符简化传递props数据的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-使用ES6的展开运算符（-）传递对象、数组数据"><span class="nav-text">2.4.1 使用ES6的展开运算符（...）传递对象、数组数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-将组件抽离为单独的-jsx文件"><span class="nav-text">2.5.将组件抽离为单独的.jsx文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-配置webpack从而在导入组件的时候，省略-jsx后缀名"><span class="nav-text">2.6.配置webpack从而在导入组件的时候，省略.jsx后缀名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-配置webpack设置根目录"><span class="nav-text">2.7.配置webpack设置根目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-设置src代码目录为"><span class="nav-text">2.7.1 设置src代码目录为@</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-class-创建类并通过constructor挂载实例属性"><span class="nav-text">2.8.class-创建类并通过constructor挂载实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-ES6-中class的使用"><span class="nav-text">2.8.1 ES6 中class的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-class-使用static创建静态属性"><span class="nav-text">2.9.class-使用static创建静态属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-1-静态属性定义"><span class="nav-text">2.9.1 静态属性定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-2-静态属性使用"><span class="nav-text">2.9.2 静态属性使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-class-实例方法和静态方法（见上方）"><span class="nav-text">2.10.class-实例方法和静态方法（见上方）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-class-总结class的基本用法和两个注意点"><span class="nav-text">2.11.class-总结class的基本用法和两个注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-13-class-使用extends实现子类继承父类"><span class="nav-text">2.13.class-使用extends实现子类继承父类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-1-代码案例"><span class="nav-text">2.13.1 代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-14-class-子类访问父类上的实例方法"><span class="nav-text">2.14.class-子类访问父类上的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-1-代码案例"><span class="nav-text">2.14.1 代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-15-class-constructor构造器中super函数的使用说明"><span class="nav-text">2.15.class-constructor构造器中super函数的使用说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-1-问题讨论及代码案例"><span class="nav-text">2.15.1 问题讨论及代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-16-class-为子类挂载独有的实例属性和实例方法"><span class="nav-text">2.16.class-为子类挂载独有的实例属性和实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-1-代码案例"><span class="nav-text">2.16.1 代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-17-使用class关键字创建组件"><span class="nav-text">2.17.使用class关键字创建组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-17-1-基本的class创建组件的语法"><span class="nav-text">2.17.1 基本的class创建组件的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-17-2-两种创建类的方法的对比"><span class="nav-text">2.17.2 两种创建类的方法的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-18-为class创建的组件传递props参数并直接使用this-props来访问"><span class="nav-text">2.18.为class创建的组件传递props参数并直接使用this.props来访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-18-1-代码案例"><span class="nav-text">2.18.1 代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-19-介绍class创建的组件中this-state"><span class="nav-text">2.19.介绍class创建的组件中this.state</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-19-1-两种创建类的方法的对比"><span class="nav-text">2.19.1 两种创建类的方法的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-19-2-代码案例"><span class="nav-text">2.19.2  代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-20-介绍有状态组件和无状态组件的区别"><span class="nav-text">2.20.介绍有状态组件和无状态组件的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-21-评论列表案例-创建CmtList组件并渲染基本页面结构"><span class="nav-text">2.21.评论列表案例-创建CmtList组件并渲染基本页面结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-22-评论列表案例-将评论Item项抽离为单独的CmtItem组件"><span class="nav-text">2.22.评论列表案例-将评论Item项抽离为单独的CmtItem组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-23-评论列表案例-将评论列表组件和评论项组件抽离为单独的组件"><span class="nav-text">2.23.评论列表案例-将评论列表组件和评论项组件抽离为单独的组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-24-评论列表案例-演示-符号替代相对路径的好处"><span class="nav-text">2.24.评论列表案例-演示@符号替代相对路径的好处</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-React-样式"><span class="nav-text">3. React 样式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-在组件中使用style行内样式并封装样式对象"><span class="nav-text">3.1.在组件中使用style行内样式并封装样式对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-代码案例（上一天的评论组件案例代码）"><span class="nav-text">3.1.1 代码案例（上一天的评论组件案例代码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-对样式代码进行封装抽离"><span class="nav-text">3.1.2 对样式代码进行封装抽离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-使用css样式表美化组件"><span class="nav-text">3.2.使用css样式表美化组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-使用-className-进行样式的添加"><span class="nav-text">3.2.1 使用 className 进行样式的添加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-演示React中使用普通-css-样式表的作用域冲突问题"><span class="nav-text">3.3.演示React中使用普通 css 样式表的作用域冲突问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-思考问题"><span class="nav-text">3.3.1 思考问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-为普通样式表通过-modules-参数启用模块化"><span class="nav-text">3.4.为普通样式表通过 modules 参数启用模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-启用Css样式表的模块化功能"><span class="nav-text">3.4.1 启用Css样式表的模块化功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-使用localIdentName来自定义模块化的类名"><span class="nav-text">3.5.使用localIdentName来自定义模块化的类名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-自定义模块化样式表的名字，可选的参数有："><span class="nav-text">3.5.1 自定义模块化样式表的名字，可选的参数有：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-代码案例"><span class="nav-text">3.5.2 代码案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-通过local和global设置类名是否被模块化"><span class="nav-text">3.6.通过local和global设置类名是否被模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-global-设置全局的class类"><span class="nav-text">3.6.1 global 设置全局的class类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-local-设置局部的class类"><span class="nav-text">3.6.2 local 设置局部的class类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-在项目中为scss或less文件启用模块化"><span class="nav-text">3.7.在项目中为scss或less文件启用模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-导入第三方样式，如-Bootstrap"><span class="nav-text">3.7.1 导入第三方样式，如 Bootstrap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-在React中为按钮绑定点击事件"><span class="nav-text">3.8.在React中为按钮绑定点击事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-React-的事件绑定机制"><span class="nav-text">3.8.1 React 的事件绑定机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-使用this-setState修改state上的数据"><span class="nav-text">3.9.使用this.setState修改state上的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1-实现点击按钮，操作state中的数据"><span class="nav-text">3.9.1 实现点击按钮，操作state中的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-this-setState的两个注意点"><span class="nav-text">3.10.this.setState的两个注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-React中绑定文本框与State中的值"><span class="nav-text">3.11.React中绑定文本框与State中的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-拓展-Vue中实例的生命周期"><span class="nav-text">3.12.拓展-Vue中实例的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-2-Vue-组件的生命周期函数"><span class="nav-text">3.12.2 Vue 组件的生命周期函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-2-1-Vue-组件的创建阶段"><span class="nav-text">3.12.2.1 Vue 组件的创建阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-2-2-Vue-组件的运行阶段"><span class="nav-text">3.12.2.2 Vue 组件的运行阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-2-3-Vue-组件的销毁阶段"><span class="nav-text">3.12.2.3 Vue 组件的销毁阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-13-拓展-Vue中实例的生命周期2（见上方）"><span class="nav-text">3.13.拓展-Vue中实例的生命周期2（见上方）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-14-快速梳理React的组件生命周期函数图"><span class="nav-text">3.14.快速梳理React的组件生命周期函数图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-14-1-React-组件的创建阶段"><span class="nav-text">3.14.1 React 组件的创建阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-14-2-React-组件的运行阶段"><span class="nav-text">3.14.2 React 组件的运行阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-14-3-React-组件的销毁阶段"><span class="nav-text">3.14.3 React 组件的销毁阶段</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GeekLeng"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">GeekLeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Geek-LHJ" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Geek-LHJ" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15501899678@163.com" title="E-Mail → mailto:15501899678@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/" title="https:&#x2F;&#x2F;github.com&#x2F;" rel="noopener" target="_blank">Github</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com&#x2F;" rel="noopener" target="_blank">Baidu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://developer.mozilla.org/zh-CN/" title="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">MDN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GeekLeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">311k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">4:43</span>
</div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=tmEFfL5pPK0vBvRMnX3hgVXb-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'tmEFfL5pPK0vBvRMnX3hgVXb-gzGzoHsz',
            'X-LC-Key': 'VnP4D53JVOGpUDoNiPvJ0BNc',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 21179,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>












  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: true,
      appId: 'tmEFfL5pPK0vBvRMnX3hgVXb-gzGzoHsz',
      appKey: 'VnP4D53JVOGpUDoNiPvJ0BNc',
      placeholder: "留下邮箱，有回复时你将收到提醒。",
      avatar: 'wavatar',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":140,"height":180},"mobile":{"show":false}});</script></body>
</html>
