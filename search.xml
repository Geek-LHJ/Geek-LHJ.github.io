<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript设计模式设计原则</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>JavaScript设计模式设计的三大设计原则：单一职责原则(SRP)、最少知识原则(LKP)、开放封闭原则(OCP)；</p>
<a id="more"></a>

<h2 id="三-设计原则"><a href="#三-设计原则" class="headerlink" title="三. 设计原则"></a>三. 设计原则</h2><h3 id="3-1-单一职责原则-SRP"><a href="#3-1-单一职责原则-SRP" class="headerlink" title="3.1 单一职责原则(SRP)"></a>3.1 单一职责原则(SRP)</h3><blockquote>
<p>SRP 原则体现为：一个对象（方法）只做一件事情；</p>
</blockquote>
<p>单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏；</p>
<h4 id="3-1-1-设计模式中的-SRP-原则"><a href="#3-1-1-设计模式中的-SRP-原则" class="headerlink" title="3.1.1 设计模式中的 SRP 原则"></a>3.1.1 设计模式中的 SRP 原则</h4><p>SRP 原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。</p>
<blockquote>
<ol>
<li>代理模式：图片预加载示例，增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅负责往页面中添加 img 标签，这也是它最原始的职责；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myImage 负责往页面中添加 img 标签：</span></span><br><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( imgNode );</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// proxyImage 负责预加载图片，并在预加载完成之后把请求交给本体 myImage：</span></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    myImage.setSrc( <span class="keyword">this</span>.src );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">      myImage.setSrc( <span class="string">'file:// /C:/Users/svenzeng/Desktop/loading.gif'</span> );</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc( <span class="string">'http:// imgcache.qq.com/music/photo/000GGDys0yA0Nk.jpg'</span> );</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>迭代器模式，实例：先遍历一个集合，然后往页面中添加一些 div，这些 div 的 innerHTML 分别对应集合里的元素；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a. 基本实现</span></span><br><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = data.length; i &lt; l; i++ )&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">    div.innerHTML = data[ i ];</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] );</span><br><span class="line"><span class="comment">// b. SRP 原则实现</span></span><br><span class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> obj, callback </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value, i = <span class="number">0</span>, length = obj.length, isArray = isArraylike( obj ); <span class="comment">// isArraylike 函数未实现，可以翻阅 jQuery 源代码</span></span><br><span class="line">  <span class="keyword">if</span> ( isArray ) &#123; <span class="comment">// 迭代类数组</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line">      callback.call( obj[ i ], i, obj[ i ] );</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123; <span class="comment">// 迭代 object 对象</span></span><br><span class="line">      value = callback.call( obj[ i ], i, obj[ i ] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</span><br><span class="line">  each( data, <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">    div.innerHTML = n;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] );</span><br><span class="line">appendDiv(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">4</span>&#125; );</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>单例模式：惰性单例创建唯一一个登录窗 div 的示例；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a. 基本实现</span></span><br><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !div )&#123;</span><br><span class="line">      div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">      div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">      div.style.display = <span class="string">'none'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// b. SRP 原则实现</span></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123; <span class="comment">// 获取单例</span></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || ( result = fn .apply(<span class="keyword">this</span>, <span class="built_in">arguments</span> ) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 创建登录浮窗</span></span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">  <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle( createLoginLayer );</span><br><span class="line"><span class="keyword">var</span> loginLayer1 = createSingleLoginLayer();</span><br><span class="line"><span class="keyword">var</span> loginLayer2 = createSingleLoginLayer();</span><br><span class="line">alert ( loginLayer1 === loginLayer2 ); <span class="comment">// 输出： true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li>装饰者模式：装饰函数实现；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-何时应该分离职责"><a href="#3-1-2-何时应该分离职责" class="headerlink" title="3.1.2 何时应该分离职责"></a>3.1.2 何时应该分离职责</h4><p>要明确的是，并不是所有的职责都应该一一分离。一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们；另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</p>
<h4 id="3-1-3-违反-SRP-原则"><a href="#3-1-3-违反-SRP-原则" class="headerlink" title="3.1.3 违反 SRP 原则"></a>3.1.3 违反 SRP 原则</h4><p>在常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。一方面，我们受设计原则的指导， 另一方面， 我们未必要在任何时候都一成不变地遵守原则；在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。</p>
<h4 id="3-1-4-SRP-原则的优缺点"><a href="#3-1-4-SRP-原则的优缺点" class="headerlink" title="3.1.4 SRP 原则的优缺点"></a>3.1.4 SRP 原则的优缺点</h4><p>SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。但 SRP 原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。</p>
<h3 id="3-2-最少知识原则-LKP"><a href="#3-2-最少知识原则-LKP" class="headerlink" title="3.2 最少知识原则(LKP)"></a>3.2 最少知识原则(LKP)</h3><blockquote>
<p>最少知识原则（ LKP）：一个软件实体应当尽可能少地与其他实体发生相互作用；</p>
</blockquote>
<h4 id="3-2-1-减少对象之间的联系"><a href="#3-2-1-减少对象之间的联系" class="headerlink" title="3.2.1 减少对象之间的联系"></a>3.2.1 减少对象之间的联系</h4><p>最少知识原则要求在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。</p>
<h4 id="3-2-2-设计模式中的最少知识原则"><a href="#3-2-2-设计模式中的最少知识原则" class="headerlink" title="3.2.2 设计模式中的最少知识原则"></a>3.2.2 设计模式中的最少知识原则</h4><p>最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式，如下所示：</p>
<blockquote>
<ol>
<li>中介者模式：</li>
</ol>
</blockquote>
<p>如博彩公司示例，博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。中介者模式很好地体现了最少知识原则，通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。</p>
<blockquote>
<ol start="2">
<li>外观模式：主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使子系统更加容易使用；</li>
</ol>
</blockquote>
<p><img src="/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png" alt="外观模式"></p>
<p>外观模式的作用是对客户屏蔽一组子系统的复杂性，外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过请求外观接口来达到访问子系统的目的，如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统；</p>
<h4 id="3-2-3-封装在最少知识原则中的体现"><a href="#3-2-3-封装在最少知识原则中的体现" class="headerlink" title="3.2.3 封装在最少知识原则中的体现"></a>3.2.3 封装在最少知识原则中的体现</h4><p>封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原的一种体现。</p>
<blockquote>
<p>实例：具有缓存效果的计算乘积的函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">    <span class="keyword">if</span> ( cache[ args ] )&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">      a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">mult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ); <span class="comment">// 输出： 6</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-开放封闭原则-OCP"><a href="#3-3-开放封闭原则-OCP" class="headerlink" title="3.3 开放封闭原则(OCP)"></a>3.3 开放封闭原则(OCP)</h3><blockquote>
<p>开放封闭原则（ OCP）：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改；</p>
</blockquote>
<p>开放封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</p>
<h4 id="3-3-1-扩展-window-onload-函数"><a href="#3-3-1-扩展-window-onload-函数" class="headerlink" title="3.3.1 扩展 window.onload 函数"></a>3.3.1 扩展 window.onload 函数</h4><p>通过增加代码，而不是修改原代码的方式，来给 <code>window.onload</code> 函数添加新的功能，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用装饰函数实现函数功能扩展</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.onload = ( <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; ).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">document</span>.getElementsByTagName( <span class="string">'*'</span> ).length );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h4 id="3-3-2-用对象的多态性消除条件分支"><a href="#3-3-2-用对象的多态性消除条件分支" class="headerlink" title="3.3.2 用对象的多态性消除条件分支"></a>3.3.2 用对象的多态性消除条件分支</h4><p>过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因，每当需要增加一个新的 if 语句时，都要被迫改动原函数。因此当一大片的 <code>if-else</code> 或者 <code>swtich-case</code> 语句时，第一时间考虑能否利用对象的多态性来重构代码，例如让动物发出叫声的例子，每增加一种动物，就需要改动 <code>makeSound</code> 函数的内部实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a. 使用 if-else 基本实现</span></span><br><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Duck )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Chicken )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 输出：嘎嘎嘎</span></span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 输出：咯咯咯</span></span><br><span class="line"><span class="comment">// b. 利用对象的多态性重构代码</span></span><br><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 嘎嘎嘎</span></span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 咯咯咯</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-找出变化的地方"><a href="#3-3-3-找出变化的地方" class="headerlink" title="3.3.3 找出变化的地方"></a>3.3.3 找出变化的地方</h4><p>开放封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导怎样地实现它；但开发中能找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，只需要替换那些容易变化的部分，而稳定的部分是不需要改变的；</p>
<h4 id="3-3-4-设计模式中的开放封闭原则"><a href="#3-3-4-设计模式中的开放封闭原则" class="headerlink" title="3.3.4 设计模式中的开放封闭原则"></a>3.3.4 设计模式中的开放封闭原则</h4><p>开放封闭原则在设计模式中应用很广泛，如之前的装饰者模式示例，还有发布订阅模式、模板方法模式、策略模式、代理模式、职责链模式，如下所示：</p>
<blockquote>
<ol>
<li>发布订阅模式</li>
</ol>
</blockquote>
<p>发布订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。</p>
<blockquote>
<ol start="2">
<li>模板方法模式</li>
</ol>
</blockquote>
<p>模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式，在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放封闭原则的。</p>
<blockquote>
<ol start="3">
<li>策略模式</li>
</ol>
</blockquote>
<p>策略模式和模板方法模式在大多数情况下可以相互替换使用，其中模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。</p>
<blockquote>
<ol start="4">
<li>代理模式</li>
</ol>
</blockquote>
<p>代理模式的图片预加载示例中，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的 <code>myImage</code> 函数， <code>myImage</code> 在这个过程中不需要任何改动，预加载图片的功能和给图片设置 src 的功能被隔离在两个函数里，它们可以单独改变而互不影响。 <code>myImage</code> 不知晓代理的存在，它可以继续专注于自己的职责——给图片设置 <code>src</code> 属性；</p>
<blockquote>
<ol start="5">
<li>职责链模式</li>
</ol>
</blockquote>
<p>职责链模式的订单示例中，当增加一个新类型的订单函数时，不需要改动原有的订单函数代码，只需要在链条中增加一个新的节点。</p>
<h4 id="3-3-5-开放封闭原则的相对性"><a href="#3-3-5-开放封闭原则的相对性" class="headerlink" title="3.3.5 开放封闭原则的相对性"></a>3.3.5 开放封闭原则的相对性</h4><p>实际开发中，让程序保持完全封闭是不容易做到，并且有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。因此我们可以做到的有下面两点：</p>
<ul>
<li>挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。</li>
<li>在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。如一个开源库，修改它提供的配置文件，总比修改它的源代码来得简单。</li>
</ul>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(十四)适配器模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题；</p>
<a id="more"></a>

<h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14 适配器模式"></a>14 适配器模式</h3><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题；</p>
<h4 id="14-1-适配器模式实例"><a href="#14-1-适配器模式实例" class="headerlink" title="14.1 适配器模式实例"></a>14.1 适配器模式实例</h4><p>在之前的地图的例子中，使用多态的思想，实现同一个操作在不同的对象产生不同的结果，如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123; map.show(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br><span class="line">renderMap( baiduMap ); <span class="comment">// 输出：开始渲染百度地图</span></span><br></pre></td></tr></table></figure>

<p>上面代码运行的关键在于 googleMap 和 baiduMap 提供了一致的 <code>show</code> 方法，若第三方接口方法不在约定中（如不是 <code>show</code> 方法），那么需要增加一个适配函数来解决问题，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">  display: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMapAdapter = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> baiduMap.display();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br><span class="line">renderMap( baiduMapAdapter ); <span class="comment">// 输出：开始渲染百度地图</span></span><br></pre></td></tr></table></figure>

<h4 id="14-2-适配器模式小结"><a href="#14-2-适配器模式小结" class="headerlink" title="14.2 适配器模式小结"></a>14.2 适配器模式小结</h4><p>适配器模式是一对相对简单的模式，在提到的设计模式中，有一些模式跟适配器模式的结构非常相似，比如装饰者模式、代理模式和外观模式。这几种模式都属于“<code>包装模式</code>”，都是由一个对象来包装另一个对象，它们的关键区别是模式的意图；</p>
<p>下面对这几种 <code>包装模式</code> 进行介绍：</p>
<ul>
<li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li>
<li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</li>
<li>外观模式的作用和适配器比较相似，可以把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</li>
</ul>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(十三)状态模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变；</p>
<a id="more"></a>

<h3 id="13-状态模式"><a href="#13-状态模式" class="headerlink" title="13 状态模式"></a>13 状态模式</h3><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变；</p>
<h4 id="13-1-初识状态模式-电灯程序"><a href="#13-1-初识状态模式-电灯程序" class="headerlink" title="13.1 初识状态模式-电灯程序"></a>13.1 初识状态模式-电灯程序</h4><blockquote>
<ol>
<li>开关控制电灯的打开关闭状态；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'off'</span>; <span class="comment">// 给电灯设置初始状态 off</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>; <span class="comment">// 电灯开关按钮</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义 Light.prototype.init 方法</span></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement( <span class="string">'button'</span> ), self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'开关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild( button );</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; self.buttonWasPressed(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 开关按下操作</span></span><br><span class="line">Light.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">this</span>.state === <span class="string">'off'</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'开灯'</span> );</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'on'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">this</span>.state === <span class="string">'on'</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'关灯'</span> );</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'off'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>

<p>上面的例子使用一个变量 <code>state</code> 来记录按钮的当前状态，在事件发生时，再根据这个状态来决定下一步的行为；不过当电灯的状态增加时（如强光，弱光状态等），需要手动修改 <code>buttonWasPressed</code> 函数，这样就是违反程序的<code>开放-封闭原则</code>，状态之间的切换关系是在 <code>buttonWasPressed</code> 函数增加 <code>if-else</code> 判断，当状态很多时， <code>buttonWasPressed</code> 函数会更加难以阅读和维护；</p>
<blockquote>
<ol start="2">
<li>状态模式改进电灯程序：</li>
</ol>
</blockquote>
<p>状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以 <code>button</code> 被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为；</p>
<p><img src="/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%94%B5%E7%81%AF.png" alt="状态模式电灯"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先将定义 3 个状态类，分别是 offLightState(关灯状态)、WeakLightState(弱光状态)、 strongLightState(强光状态) ,每个类都有一个原型方法 buttonWasPressed，代表在各自状态下点击按钮发送的行为；</span></span><br><span class="line"><span class="keyword">var</span> OffLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;;</span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'弱光'</span> ); <span class="comment">// offLightState 对应的行为</span></span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.weakLightState ); <span class="comment">// 切换状态到 weakLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> WeakLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;;</span><br><span class="line">WeakLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'强光'</span> ); <span class="comment">// weakLightState 对应的行为</span></span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.strongLightState ); <span class="comment">// 切换状态到 strongLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> StrongLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;;</span><br><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'关灯'</span> ); <span class="comment">// strongLightState 对应的行为</span></span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.offLightState ); <span class="comment">// 切换状态到 offLightState</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Light 类：在构造函数里为每个状态类都创建一个状态对象</span></span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Light 初始化方法</span></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement( <span class="string">'button'</span> ), self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild( button );</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'开关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offLightState; <span class="comment">// 设置当前电灯状态为关灯</span></span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed(); <span class="comment">// 按钮被按下的事件请求委托给当前持有的状态对象去执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现 Light.prototype.setState 方法：状态对象可以通过这个方法来切换 light 对象的状态，状态的切换规律事先被完好定义在各个状态类中；</span></span><br><span class="line">Light.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params"> newState </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.currState = newState;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试效果</span></span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>

<p>状态模式可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码；状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的 <code>if-else</code> 条件分支语言来控制状态之间的转换；</p>
<p>上面例子中若需要为 <code>light</code> 对象增加一种新的状态时，只需要增加一个新的状态类，再稍稍改变一些现有的代码即可；若现在 light 对象多了一种超强光的状态，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先增加 SuperStrongLightState 类；</span></span><br><span class="line"><span class="keyword">var</span> SuperStrongLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;;</span><br><span class="line">SuperStrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'关灯'</span> );</span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.offLightState );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 再在 Light 构造函数里新增一个 superStrongLightState 对象：</span></span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.superStrongLightState = <span class="keyword">new</span> SuperStrongLightState( <span class="keyword">this</span> ); <span class="comment">// 新增 superStrongLightState 对象</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 最后改变状态类之间的切换规则，从 StrongLightState----&gt;OffLightState 变为 StrongLightState----&gt;SuperStrongLightState ----&gt;OffLightState：</span></span><br><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'超强光'</span> ); <span class="comment">// strongLightState 对应的行为</span></span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.superStrongLightState ); <span class="comment">// 切换状态到 offLightState</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="13-2-状态模式的通用结构"><a href="#13-2-状态模式的通用结构" class="headerlink" title="13.2 状态模式的通用结构"></a>13.2 状态模式的通用结构</h4><p>在电灯的例子中，首先定义了 <code>Light</code> 类， Light类在这里也被称为上下文（ <code>Context</code> ）；随后在 <code>Light</code> 的构造函数中创建每一个状态类的实例对象， <code>Context</code> 将持有这些状态对象的引用，以便把请求委托给状态对象；用户的请求，即点击 <code>button</code> 的动作也是实现在 <code>Context</code> 中的，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState( <span class="keyword">this</span> ); <span class="comment">// 持有状态对象的引用</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement( <span class="string">'button'</span> ), self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild( button );</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'开关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offLightState; <span class="comment">// 设置默认初始状态</span></span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 定义用户的请求动作  </span></span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来要编写各种状态类， <code>light</code> 对象被传入状态类的构造函数，状态对象也需要持有 <code>light</code> 对象的引用，以便调用 <code>light</code> 中的方法或者直接操作 <code>light</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OffLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;;</span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'弱光'</span> );</span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.weakLightState );</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="13-3-状态模式示例——文件上传"><a href="#13-3-状态模式示例——文件上传" class="headerlink" title="13.3 状态模式示例——文件上传"></a>13.3 状态模式示例——文件上传</h4><p>文件上传中，包括有扫描、正在上传、暂停、上传成功、上传失败这几种状态，点击同一个按钮，在上传中和<br>暂停状态下的行为表现是不一样的，如上传中，点击按钮暂停，暂停中，点击按钮继续播放；</p>
<p>文件上传中，设置 暂停/继续 和 删除两个按钮，点击这两个按钮的发生行为如下：</p>
<ul>
<li>文件在扫描状态中，是不能进行任何操作的，既不能暂停也不能删除文件，只能等待扫描完成。扫描完成之后，根据文件的 md5 值判断，若确认该文件已经存在于服务器，则直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况下才进入上传中状态；</li>
<li>上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传；</li>
<li>扫描和上传过程中，点击删除按钮无效，只有在暂停、上传完成、上传失败之后，才能删除文件；</li>
</ul>
<blockquote>
<ol>
<li>文件上传基本实现：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上传是一个异步的过程，定义全局函数 window.external.upload 来通知上传进度，把当前的文件状态作为参数state 传入函数中</span></span><br><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params"> state </span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( state ); <span class="comment">// 可能为 sign、 uploading、 done、 error</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上传的插件对象</span></span><br><span class="line"><span class="keyword">var</span> plugin = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> plugin = <span class="built_in">document</span>.createElement( <span class="string">'embed'</span> );</span><br><span class="line">  plugin.style.display = <span class="string">'none'</span>;</span><br><span class="line">  plugin.type = <span class="string">'application/txftn-webkit'</span>;</span><br><span class="line">  plugin.sign = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始文件扫描'</span> ); &#125;</span><br><span class="line">  plugin.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'暂停文件上传'</span> ); &#125;;</span><br><span class="line">  plugin.uploading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始文件上传'</span> ); &#125;;</span><br><span class="line">  plugin.del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删除文件上传'</span> ); &#125;</span><br><span class="line">  plugin.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件上传完成'</span> ); &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( plugin );</span><br><span class="line">  <span class="keyword">return</span> plugin;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 定义控制上传过程的对象 Upload 类</span></span><br><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"> fileName </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin = plugin;</span><br><span class="line">  <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'sign'</span>; <span class="comment">// 设置初始状态为 waiting</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化 Upload 类函数</span></span><br><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML =</span><br><span class="line">    <span class="string">'&lt;span&gt;文件名称:'</span>+ <span class="keyword">this</span>.fileName +<span class="string">'&lt;/span&gt;\</span></span><br><span class="line"><span class="string">    &lt;button data-action="button1"&gt;扫描中&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;button data-action="button2"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( <span class="keyword">this</span>.dom );</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="keyword">this</span>.dom.querySelector( <span class="string">'[data-action="button1"]'</span> ); <span class="comment">// 第一个按钮</span></span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="keyword">this</span>.dom.querySelector( <span class="string">'[data-action="button2"]'</span> ); <span class="comment">// 第二个按钮</span></span><br><span class="line">  <span class="keyword">this</span>.bindEvent();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个按钮分别绑定点击事件</span></span><br><span class="line">Upload.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( self.state === <span class="string">'sign'</span> )&#123; <span class="comment">// 扫描状态下，任何操作无效</span></span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'扫描中，点击无效...'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'uploading'</span> )&#123; <span class="comment">// 上传中，点击切换到暂停</span></span><br><span class="line">      self.changeState( <span class="string">'pause'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'pause'</span> )&#123; <span class="comment">// 暂停中，点击切换到上传中</span></span><br><span class="line">      self.changeState( <span class="string">'uploading'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'done'</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'文件已完成上传, 点击无效'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'error'</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'文件上传失败, 点击无效'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.button2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( self.state === <span class="string">'done'</span> || self.state === <span class="string">'error'</span> || self.state === <span class="string">'pause'</span> )&#123;</span><br><span class="line">      <span class="comment">// 上传完成、上传失败和暂停状态下可以删除</span></span><br><span class="line">      self.changeState( <span class="string">'del'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'sign'</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'文件正在扫描中，不能删除'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( self.state === <span class="string">'uploading'</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'文件正在上传中，不能删除'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Upload.prototype.changeState 方法，负责切换状态之后的具体行为：</span></span><br><span class="line">Upload.prototype.changeState = <span class="function"><span class="keyword">function</span>(<span class="params"> state </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>( state )&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sign'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.sign();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'扫描中，任何操作无效'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'uploading'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.uploading();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'正在上传，点击暂停'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.pause();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'已暂停，点击继续上传'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'done'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.done();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上传完成'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'error'</span>:</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上传失败'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'del'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.del();</span><br><span class="line">    <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'删除完成'</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试上传文件</span></span><br><span class="line"><span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload( <span class="string">'JavaScript 设计模式与开发实践'</span> );</span><br><span class="line">uploadObj.init();</span><br><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params"> state </span>)</span>&#123; <span class="comment">// 插件调用 JavaScript 的方法</span></span><br><span class="line">  uploadObj.changeState( state );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.external.upload( <span class="string">'sign'</span> ); <span class="comment">// 文件开始扫描</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload( <span class="string">'uploading'</span> ); <span class="comment">// 1 秒后开始上传</span></span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload( <span class="string">'done'</span> ); <span class="comment">// 5 秒后上传完成</span></span><br><span class="line">&#125;, <span class="number">5000</span> );</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>状态模式重构文件上传程序：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：提供 window.external.upload 函数</span></span><br><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params"> state </span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( state ); <span class="comment">// 可能为 sign、 uploading、 done、 error</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> plugin = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> plugin = <span class="built_in">document</span>.createElement( <span class="string">'embed'</span> );</span><br><span class="line">  plugin.style.display = <span class="string">'none'</span>;</span><br><span class="line">  plugin.type = <span class="string">'application/txftn-webkit'</span>;</span><br><span class="line">  plugin.sign = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始文件扫描'</span> ); &#125;</span><br><span class="line">  plugin.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'暂停文件上传'</span> ); &#125;;</span><br><span class="line">  plugin.uploading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始文件上传'</span> ); &#125;;</span><br><span class="line">  plugin.del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删除文件上传'</span> ); &#125;</span><br><span class="line">  plugin.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件上传完成'</span> ); &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( plugin );</span><br><span class="line">  <span class="keyword">return</span> plugin;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 第二步：改造 Upload 构造函数，在构造函数中为每种状态子类都创建一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"> fileName </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin = plugin;</span><br><span class="line">  <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.signState = <span class="keyword">new</span> SignState( <span class="keyword">this</span> ); <span class="comment">// 设置初始状态为 waiting</span></span><br><span class="line">  <span class="keyword">this</span>.uploadingState = <span class="keyword">new</span> UploadingState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.pauseState = <span class="keyword">new</span> PauseState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.doneState = <span class="keyword">new</span> DoneState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.errorState = <span class="keyword">new</span> ErrorState( <span class="keyword">this</span> );</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.signState; <span class="comment">// 设置当前状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第三步：实现 Upload.prototype.init 方法</span></span><br><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML =</span><br><span class="line">    <span class="string">'&lt;span&gt;文件名称:'</span>+ <span class="keyword">this</span>.fileName +<span class="string">'&lt;/span&gt;\</span></span><br><span class="line"><span class="string">    &lt;button data-action="button1"&gt;扫描中&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;button data-action="button2"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( <span class="keyword">this</span>.dom );</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="keyword">this</span>.dom.querySelector( <span class="string">'[data-action="button1"]'</span> );</span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="keyword">this</span>.dom.querySelector( <span class="string">'[data-action="button2"]'</span> );</span><br><span class="line">  <span class="keyword">this</span>.bindEvent();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第四步：负责具体的按钮事件实现</span></span><br><span class="line">Upload.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.currState.clickHandler1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.button2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.currState.clickHandler2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.sign = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin.sign();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.signState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.uploading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'正在上传，点击暂停'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.uploading();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.uploadingState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'已暂停，点击继续上传'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.pause();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.pauseState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上传完成'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.done();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.doneState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.error = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上传失败'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.errorState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin.del();</span><br><span class="line">  <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第五步：编写各个状态类的实现</span></span><br><span class="line"><span class="keyword">var</span> StateFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> State = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  State.prototype.clickHandler1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子类必须重写父类的 clickHandler1 方法'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  State.prototype.clickHandler2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子类必须重写父类的 clickHandler2 方法'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> param </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadObj </span>)</span>&#123; <span class="keyword">this</span>.uploadObj = uploadObj; &#125;;</span><br><span class="line">    F.prototype = <span class="keyword">new</span> State();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> param )&#123;</span><br><span class="line">      F.prototype[ i ] = param[ i ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> SignState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'扫描中，点击无效...'</span> ); &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件正在上传中，不能删除'</span> ); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> UploadingState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.uploadObj.pause(); &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件正在上传中，不能删除'</span> ); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> PauseState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.uploadObj.uploading(); &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.uploadObj.del(); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> DoneState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件已完成上传, 点击无效'</span> ); &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.uploadObj.del(); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> ErrorState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'文件上传失败, 点击无效'</span> ); &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.uploadObj.del(); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 最后测试</span></span><br><span class="line"><span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload( <span class="string">'JavaScript 设计模式与开发实践'</span> );</span><br><span class="line">uploadObj.init();</span><br><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params"> state </span>)</span>&#123; uploadObj[ state ](); &#125;;</span><br><span class="line"><span class="built_in">window</span>.external.upload( <span class="string">'sign'</span> );</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload( <span class="string">'uploading'</span> ); <span class="comment">// 1 秒后开始上传</span></span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload( <span class="string">'done'</span> ); <span class="comment">// 5 秒后上传完成</span></span><br><span class="line">&#125;, <span class="number">5000</span> );</span><br></pre></td></tr></table></figure>

<h4 id="13-4-状态模式的优缺点及性能优化点"><a href="#13-4-状态模式的优缺点及性能优化点" class="headerlink" title="13.4 状态模式的优缺点及性能优化点"></a>13.4 状态模式的优缺点及性能优化点</h4><blockquote>
<ol>
<li>状态模式的优点：</li>
</ol>
</blockquote>
<ul>
<li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里，通过增加新的状态类，很容易增加新的状态和转换；</li>
<li>避免 <code>Context</code> 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 <code>Context</code> 中原本过多的条件分支；</li>
<li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然；</li>
<li><code>Context</code> 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响；</li>
</ul>
<blockquote>
<ol start="2">
<li>状态模式的缺点：</li>
</ol>
</blockquote>
<p>状态模式会在系统中定义许多状态类，并且生成许多对象；同时由于逻辑分散在状态类中，虽然减少了 <code>if-else</code>分支语句，但也造成了逻辑分散的问题；</p>
<blockquote>
<ol start="3">
<li>状态模式性能优化点：</li>
</ol>
</blockquote>
<ul>
<li>有两种选择来管理 <code>state</code> 对象的创建和销毁，第一种是仅当 <code>state</code> 对象被需要时才创建并随后销毁，能有效的节省内存；另一种是一开始就创建好所有的状态对象，并且始终不销毁它们，适用于状态的改变很频繁的场景中；</li>
<li>本章的例子中，为每个 <code>Context</code> 对象都创建了一组 <code>state</code> 对象，实际上这些 <code>state</code> 对象之间是可以共享的，各 <code>Context</code> 对象可以共享一个 <code>state</code> 对象，这也是享元模式的应用场景之一；</li>
</ul>
<h4 id="13-5-状态模式和策略模式的关系"><a href="#13-5-状态模式和策略模式的关系" class="headerlink" title="13.5 状态模式和策略模式的关系"></a>13.5 状态模式和策略模式的关系</h4><p>状态模式和策略模式都封装了一系列的算法或者行为，它们的类图看起来来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的模式；策略模式和状态模式的相同点是都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行；区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以必须熟知这些策略类的作用，以便可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部，因此我们不需要了解这些细节；</p>
<h4 id="13-6-JavaScript-版本的状态机"><a href="#13-6-JavaScript-版本的状态机" class="headerlink" title="13.6 JavaScript 版本的状态机"></a>13.6 JavaScript 版本的状态机</h4><p>前面示例都是模拟传统面向对象语言的状态模式实现，为每种状态都定义一个状态子类，然后在 <code>Context</code> 中持有这些状态对象的引用，以便把 <code>currState</code> 设置为当前的状态对象；在 JavaScript 这种“无类”语言中，没有规定让状态对象一定要从类中创建而来。另外， JavaScript 可以非常方便地使用委托技术，并不需要事先让一个对象持有另一个对象。</p>
<p>下面的状态机选择了通过 <code>Function.prototype.call</code> 方法直接把请求委托给某个字面量对象来执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.currState = FSM.off; <span class="comment">// 设置当前状态</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement( <span class="string">'button'</span> ), self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'已关灯'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild( button );</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed.call( self ); <span class="comment">// 把请求委托给 FSM 状态机</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> FSM = &#123;</span><br><span class="line">  off: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'关灯'</span> );</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是开灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = FSM.on;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  on: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'开灯'</span> );</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是关灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = FSM.off;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br><span class="line"><span class="comment">// 方式2：利用下面的 delegate 函数来完成这个状态机编写。这是面向对象设计和闭包互换的一个例子，前者把变量保存为对象的属性，而后者把变量封闭在闭包形成的环境</span></span><br><span class="line"><span class="keyword">var</span> delegate = <span class="function"><span class="keyword">function</span>(<span class="params"> client, delegation </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 将客户的操作委托给 delegation 对象</span></span><br><span class="line">      <span class="keyword">return</span> delegation.buttonWasPressed.apply( client, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> FSM = &#123;</span><br><span class="line">  off: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'关灯'</span> );</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是开灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = <span class="keyword">this</span>.onState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  on: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'开灯'</span> );</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是关灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.offState = delegate( <span class="keyword">this</span>, FSM.off );</span><br><span class="line">  <span class="keyword">this</span>.onState = delegate( <span class="keyword">this</span>, FSM.on );</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offState; <span class="comment">// 设置初始状态为关闭状态</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement( <span class="string">'button'</span> ), self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'已关灯'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild( button );</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; self.currState.buttonWasPressed(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>

<h4 id="13-7-状态模式小结"><a href="#13-7-状态模式小结" class="headerlink" title="13.7 状态模式小结"></a>13.7 状态模式小结</h4><p>状态模式是非常有效的模式之一，通过状态模式重构代码之后，会让代码会变得清晰。虽然状态模式一开始并不是非常容易理解，但有必须去好好掌握这种设计模式。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(十二)装饰者模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>装饰者模式定义为给对象动态地增加职责的方式；装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责；</p>
<a id="more"></a>

<h3 id="12-装饰者模式"><a href="#12-装饰者模式" class="headerlink" title="12 装饰者模式"></a>12 装饰者模式</h3><p>装饰者模式定义为给对象动态地增加职责的方式；装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责；</p>
<h4 id="12-1-装饰函数"><a href="#12-1-装饰函数" class="headerlink" title="12.1 装饰函数"></a>12.1 装饰函数</h4><p>在 JavaScript 中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能通过保存原引用的方式就可以改写某个函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert (<span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">var</span> _onload = <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  _onload();</span><br><span class="line">  alert (<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码符合<strong>开放-封闭</strong>原则的，在增加新功能的时候，确实没有修改原来的 <code>window.onload</code> 代码，但是这种方式存在以下两个问题：</p>
<ul>
<li>必须维护 <code>_onload</code> 这个中间变量，如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多；</li>
<li>其实还遇到了 <code>this</code> 被劫持的问题，遇到该问题时需要 用<code>Function.prototype.apply()</code> 手动设置 <code>this</code> 指向，如下<code>document.getElementById</code> 方法；<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _getElementById = <span class="built_in">document</span>.getElementById;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">      alert (1);</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> _getElementById.apply( <span class="built_in">document</span>, <span class="built_in">arguments</span> );</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="12-2-用-AOP-面向切面编程-装饰函数"><a href="#12-2-用-AOP-面向切面编程-装饰函数" class="headerlink" title="12.2 用 AOP (面向切面编程)装饰函数"></a>12.2 用 AOP (面向切面编程)装饰函数</h4><blockquote>
<ol>
<li><code>Function.prototype.before</code> 方法和<code>Function.prototype.after</code> 方法实现：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"> beforefn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 返回包含了原函数和新函数的"代理"函数</span></span><br><span class="line">    beforefn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// 执行新函数，且保证 this 不被劫持，新函数接受的参数</span></span><br><span class="line">    <span class="comment">// 也会被原封不动地传入原函数，新函数在原函数之前执行</span></span><br><span class="line">    <span class="keyword">return</span> __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// 执行原函数并返回原函数的执行结果，</span></span><br><span class="line">    <span class="comment">// 并且保证 this 不被劫持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.用 AOP 装饰函数修改上面例子：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"> beforefn </span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      beforefn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert (<span class="number">1</span>); &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( button );</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="12-3-AOP-的应用实例"><a href="#12-3-AOP-的应用实例" class="headerlink" title="12.3 AOP 的应用实例"></a>12.3 AOP 的应用实例</h4><h4 id="12-4-装饰者模式和代理模式"><a href="#12-4-装饰者模式和代理模式" class="headerlink" title="12.4 装饰者模式和代理模式"></a>12.4 装饰者模式和代理模式</h4><p>代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。</p>
<ul>
<li>代理模式：当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者，本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情；代理模式强调一种关系（ Proxy 与它的实体之间的关系），这种关系可以静态的表达，在一开始就可以被确定；</li>
<li>装饰者模式：为对象动态加入行为；装饰者模式用于一开始不能确定对象的全部功能时；代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链；</li>
</ul>
<h4 id="12-5-装饰者模式小结"><a href="#12-5-装饰者模式小结" class="headerlink" title="12.5 装饰者模式小结"></a>12.5 装饰者模式小结</h4><p>装饰函数是 JavaScript 中独特的装饰者模式，这种模式在实际开发中非常有用；同时在框架开发中也十分有用，通过装饰者模式为框架里的函数提供的一些稳定而方便移植的功能，这些个性化的功能可以在框架之外动态装饰上去，这样能避免为了让框架拥有更多的功能，而去使用一些 if、 else 语句预测用户的实际需要；</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(十一)中介者模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>待上传</p>
<a id="more"></a>

<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(十)职责链模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>职责链模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止；</p>
<a id="more"></a>

<h3 id="10-职责链模式"><a href="#10-职责链模式" class="headerlink" title="10 职责链模式"></a>10 职责链模式</h3><blockquote>
<p>职责链模式的定义：</p>
</blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止；</p>
<blockquote>
<p>职责链模式最大优点：</p>
</blockquote>
<p>请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系；</p>
<h4 id="10-1-职责链模式实例"><a href="#10-1-职责链模式实例" class="headerlink" title="10.1 职责链模式实例"></a>10.1 职责链模式实例</h4><p>假设一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段。公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用<br>户会收到 100 元的商城优惠券， 200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到；</p>
<p>相关字段定义：</p>
<ul>
<li><code>orderType</code> 表示订单类型，code 的值为 1 的时候是 500 元定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户；</li>
<li><code>pay</code>：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式；</li>
<li><code>stock</code> ：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用户不受此限制；</li>
</ul>
<p>这个流程代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( orderType === <span class="number">1</span> )&#123; <span class="comment">// 500 元定金购买模式</span></span><br><span class="line">    <span class="keyword">if</span> ( pay === <span class="literal">true</span> )&#123; <span class="comment">// 已支付定金</span></span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'500 元定金预购, 得到 100 优惠券'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 未支付定金，降级到普通购买模式</span></span><br><span class="line">      <span class="keyword">if</span> ( stock &gt; <span class="number">0</span> )&#123; <span class="comment">// 用于普通购买的手机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'普通购买, 无优惠券'</span> );</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'手机库存不足'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( orderType === <span class="number">2</span> )&#123; <span class="comment">// 200 元定金购买模式</span></span><br><span class="line">    <span class="keyword">if</span> ( pay === <span class="literal">true</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'200 元定金预购, 得到 50 优惠券'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( stock &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'普通购买, 无优惠券'</span> );</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'手机库存不足'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( orderType === <span class="number">3</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( stock &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'普通购买, 无优惠券'</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'手机库存不足'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order( <span class="number">1</span> , <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输出： 500 元定金预购, 得到 100 优惠券</span></span><br></pre></td></tr></table></figure>
<p>此代码阅读起来很难，当项目运行后，若增加其他优惠政策，修改起来也很困难；</p>
<h4 id="10-2-用职责链模式重构代码"><a href="#10-2-用职责链模式重构代码" class="headerlink" title="10.2 用职责链模式重构代码"></a>10.2 用职责链模式重构代码</h4><p>先把 500 元订单、 200 元订单以及普通购买分成 3个函数；接下来把 <code>orderType、 pay、 stock</code> 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 500 元订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'500 元定金预购, 得到 100 优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    order200( orderType, pay, stock ); <span class="comment">// 将请求传递给 200 元订单</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 200 元订单</span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'200 元定金预购, 得到 50 优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    orderNormal( orderType, pay, stock ); <span class="comment">// 将请求传递给普通订单</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 普通购买订单</span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( stock &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'普通购买, 无优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'手机库存不足'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line">order500( <span class="number">1</span> , <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输出： 500 元定金预购, 得到 100 优惠券</span></span><br><span class="line">order500( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span> ); <span class="comment">// 输出：普通购买, 无优惠券</span></span><br><span class="line">order500( <span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输出： 200 元定金预购, 得到 500 优惠券</span></span><br><span class="line">order500( <span class="number">3</span>, <span class="literal">false</span>, <span class="number">500</span> ); <span class="comment">// 输出：普通购买, 无优惠券</span></span><br><span class="line">order500( <span class="number">3</span>, <span class="literal">false</span>, <span class="number">0</span> ); <span class="comment">// 输出：手机库存不足</span></span><br></pre></td></tr></table></figure>
<p>此代码相对于上一个实现逻辑更加清晰，不过请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函<br>数之中（如其中的 order200 和 order500 耦合在一起），当增加其他优惠时，必须修改整条链，这违反了<strong>开放-封闭原则</strong>；</p>
<h4 id="2-10-3-灵活可拆分的职责链节点"><a href="#2-10-3-灵活可拆分的职责链节点" class="headerlink" title="2.10.3 灵活可拆分的职责链节点"></a>2.10.3 灵活可拆分的职责链节点</h4><blockquote>
<ol>
<li>改写一下 3 种购买模式的节点函数，约定若某个节点不能处理请求，则返回一个特定的字符串 <code>nextSuccessor</code>来表示该请求需要继续往后面传递，代码如下：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'500 元定金预购，得到 100 优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>; <span class="comment">// 不用知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'200 元定金预购，得到 50 优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>; <span class="comment">// 不用知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( stock &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'普通购买，无优惠券'</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'手机库存不足'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>再定义一个构造函数 Chain ，在 <code>new Chain</code> 的时候传递的参数即为需要被包装的函数， 同时还拥有一个实例属性 <code>this.successor</code> ，表示在链中的下一个节点：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  <span class="keyword">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params"> successor </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">this</span>.fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">  <span class="keyword">if</span> ( ret === <span class="string">'nextSuccessor'</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply( <span class="keyword">this</span>.successor, <span class="built_in">arguments</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>测试结果</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 3 个订单函数分别包装成职责链的节点：</span></span><br><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> Chain( order500 );</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> Chain( order200 );</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> Chain( orderNormal );</span><br><span class="line"><span class="comment">// 指定节点在职责链中的顺序：</span></span><br><span class="line">chainOrder500.setNextSuccessor( chainOrder200 );</span><br><span class="line">chainOrder200.setNextSuccessor( chainOrderNormal );</span><br><span class="line"><span class="comment">// 最后把请求传递给第一个节点：</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输出： 500 元定金预购，得到 100 优惠券</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输出： 200 元定金预购，得到 50 优惠券</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">3</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输出：普通购买，无优惠券</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span> ); <span class="comment">// 输出：手机库存不足</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="4">
<li>自由灵活地增加、移除和修改链中的节点顺序，若新增 300 元的优惠政策，修改如下：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order300 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 具体实现略 &#125;;</span></span><br><span class="line">chainOrder300= <span class="keyword">new</span> Chain( order300 );</span><br><span class="line">chainOrder500.setNextSuccessor( chainOrder300);</span><br><span class="line">chainOrder300.setNextSuccessor( chainOrder200);</span><br></pre></td></tr></table></figure>

<h4 id="10-4-异步的职责链"><a href="#10-4-异步的职责链" class="headerlink" title="10.4 异步的职责链"></a>10.4 异步的职责链</h4><p>实际开发中经常会遇到一些异步的问题，比如在节点函数中发起一个 ajax 异步请求，异步请求返回的结果才能决定是否继续在职责链中 <code>passRequest</code> ，因而 Chain 新增原型方法 <code>Chain.prototype.next</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Chain.prototype.next= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply( <span class="keyword">this</span>.successor, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="10-5-职责链模式的优缺点"><a href="#10-5-职责链模式的优缺点" class="headerlink" title="10.5 职责链模式的优缺点"></a>10.5 职责链模式的优缺点</h4><blockquote>
<p>职责链模式的优点：</p>
</blockquote>
<ul>
<li>使用了职责链模式之后，链中的节点对象可以灵活地拆分重组，如增加和删除节点；</li>
<li>职责链模式还可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递；</li>
</ul>
<blockquote>
<p>职责链模式的缺点：</p>
</blockquote>
<p>职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗；</p>
<h4 id="10-6-用-AOP-面向切面编程-实现职责链"><a href="#10-6-用-AOP-面向切面编程-实现职责链" class="headerlink" title="10.6 用 AOP (面向切面编程)实现职责链"></a>10.6 用 AOP (面向切面编程)实现职责链</h4><p>利用 JavaScript 的函数式特性，有一种更加方便的方法来创建职责链；下面改写之前高阶函数中的<code>Function.prototype.after</code> 函数，使得第一个函数返回 <code>nextSuccessor</code> 时，将请求继续传递给下一个函数，其中约定返回字符串 <code>nextSuccessor</code> 或者 <code>false</code> 中的一个；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ret === <span class="string">'nextSuccessor'</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> order = order500yuan.after( order200yuan ).after( orderNormal );</span><br><span class="line">order( <span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输出： 500 元定金预购，得到 100 优惠券</span></span><br><span class="line">order( <span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">//  输出： 200 元定金预购，得到 50 优惠券</span></span><br><span class="line">order( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span> ); <span class="comment">// 输出：普通购买，无优惠券</span></span><br></pre></td></tr></table></figure>

<h4 id="10-7-职责链模式小结"><a href="#10-7-职责链模式小结" class="headerlink" title="10.7 职责链模式小结"></a>10.7 职责链模式小结</h4><p>职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点；职责链模式的应用有很多，如作用域链、原型链、 DOM 节点的事件冒泡等，职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>职责链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(九)享元模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>享元（ flyweight）模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象；</p>
<a id="more"></a>

<h3 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9 享元模式"></a>9 享元模式</h3><p>享元（ flyweight）模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象；</p>
<h4 id="9-1-享元模式简单示例"><a href="#9-1-享元模式简单示例" class="headerlink" title="9.1 享元模式简单示例"></a>9.1 享元模式简单示例</h4><p>假设目前加工好了50件男士外套和50件女士外套，需要使用塑料模特拍照，正常情况下需要 50 个男模特和 50 个女模特，然后让他们每人分别穿上一件外套来拍照。不使用享元模式的情况下，在程序里也许会这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Model = <span class="function"><span class="keyword">function</span>(<span class="params"> sex, underwear</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  <span class="keyword">this</span>.underwear= underwear;</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.takePhoto = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'sex= '</span> + <span class="keyword">this</span>.sex + <span class="string">' underwear='</span> + <span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ )&#123;</span><br><span class="line">  <span class="keyword">var</span> maleModel = <span class="keyword">new</span> Model( <span class="string">'male'</span>, <span class="string">'underwear'</span> + i );</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++ )&#123;</span><br><span class="line">  <span class="keyword">var</span> femaleModel= <span class="keyword">new</span> Model( <span class="string">'female'</span>, <span class="string">'underwear'</span> + j );</span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑一下如何优化这个场景，其实男模特和女模特各自有一个就足够，代码调整如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Model = <span class="function"><span class="keyword">function</span>(<span class="params"> sex </span>)</span>&#123; <span class="keyword">this</span>.sex = sex; &#125;;</span><br><span class="line">Model.prototype.takePhoto = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'sex= '</span> + <span class="keyword">this</span>.sex + <span class="string">' underwear='</span> + <span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> maleModel = <span class="keyword">new</span> Model( <span class="string">'male'</span> ), femaleModel = <span class="keyword">new</span> Model( <span class="string">'female'</span> );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ )&#123;</span><br><span class="line">  maleModel.underwear = <span class="string">'underwear'</span> + i;</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++ )&#123;</span><br><span class="line">  femaleModel.underwear = <span class="string">'underwear'</span> + j;</span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-内部状态与外部状态"><a href="#9-2-内部状态与外部状态" class="headerlink" title="9.2 内部状态与外部状态"></a>9.2 内部状态与外部状态</h4><p>享元模式要求将对象的属性划分为<strong>内部状态与外部状态</strong>（状态在这里通常指属性），享元模式的目标是尽量减少共享对象的数量；</p>
<blockquote>
<p>1.如何划分内部状态和外部状态：</p>
</blockquote>
<ul>
<li>内部状态存储于对象内部；</li>
<li>内部状态可以被一些对象共享；</li>
<li>内部状态独立于具体的场景，通常不会改变；</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享；</li>
</ul>
<p>这样便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象；组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，因此享元模式是一种用时间换空间的优化模式；</p>
<blockquote>
<ol start="2">
<li>分析上面的例子：</li>
</ol>
</blockquote>
<p>在上面的例子中，性别是内部状态，外套是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以最多只需要 2 个对象；</p>
<p>在上面的例子中，存在的一些问题以及解决方法：</p>
<ul>
<li>通过构造函数显式 <code>new</code> 出了男女两个 <code>model</code> 对象，在其他系统中，并不是一开始就需要所有的共享对象；因此通过一个对象工厂来解决，只有当某种共享对象被真正需要时，它才从工厂中被创建出来；</li>
<li>给 <code>model</code> 对象手动设置了 <code>underwear</code> 外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难；因此用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来；</li>
</ul>
<h4 id="9-3-文件上传的例子"><a href="#9-3-文件上传的例子" class="headerlink" title="9.3 文件上传的例子"></a>9.3 文件上传的例子</h4><p>实现多个文件的上传，上传成功文件后展示文件的信息，并支持删除文件的功能；</p>
<blockquote>
<ol>
<li>文件上传基本实现代码：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  定义 Upload 构造函数，它接受 3 个参数，分别是插件类型、文件名和文件大小</span></span><br><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType, fileName, fileSize </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.uploadType = uploadType;</span><br><span class="line">  <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">  <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">  <span class="keyword">this</span>.dom= <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  upload 对象init函数</span></span><br><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML =</span><br><span class="line">    <span class="string">'&lt;span&gt;文件名称:'</span>+ <span class="keyword">this</span>.fileName +<span class="string">', 文件大小: '</span>+ <span class="keyword">this</span>.fileSize +<span class="string">'&lt;/span&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;button class="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom.querySelector( <span class="string">'.delFile'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; that.delFile(); &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( <span class="keyword">this</span>.dom );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// upload 对象删除文件的功能</span></span><br><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">window</span>.confirm( <span class="string">'确定要删除该文件吗? '</span> + <span class="keyword">this</span>.fileName ) )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当选择了文件并确认上传后，调用 Window 下的一个全局函数 startUpload，用户选择的文件列表被组合成一个数组 files 塞进该函数的参数列表里，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType, files </span>)</span>&#123; <span class="comment">// uploadType 区分是控件还是 flash</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[ i++ ]; )&#123;</span><br><span class="line">  <span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload( uploadType, file.fileName, file.fileSize );</span><br><span class="line">    uploadObj.init( id++ ); <span class="comment">// 给 upload 对象设置一个唯一的 id</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件类型上传文件</span></span><br><span class="line">startUpload( <span class="string">'plugin'</span>, [</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'1.txt'</span>, <span class="attr">fileSize</span>: <span class="number">1000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'2.html'</span>, <span class="attr">fileSize</span>: <span class="number">3000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'3.txt'</span>, <span class="attr">fileSize</span>: <span class="number">5000</span> &#125;</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Flash类型上传文件</span></span><br><span class="line">startUpload( <span class="string">'flash'</span>, [</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'4.txt'</span>, <span class="attr">fileSize</span>: <span class="number">1000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'5.html'</span>, <span class="attr">fileSize</span>: <span class="number">3000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'6.txt'</span>, <span class="attr">fileSize</span>: <span class="number">5000</span> &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>该方式的文件上传中，若一次性上传很多个文件时，每一个文件对应一个上传对象，这种对象爆炸的问题会使得浏览器崩溃；</p>
<blockquote>
<ol start="2">
<li>享元模式重构文件上传：</li>
</ol>
</blockquote>
<p>在文件上传的例子里， upload 对象必须依赖 <code>uploadType</code> 属性才能工作，这是因为插件上传、Flash 上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是完全不一样的，因此 <code>uploadType</code> 作为内部状态，把其他的外部状态从构造函数中抽离出来，Upload 构造函数中只保留 <code>uploadType</code> 参数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.uploadType = uploadType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时 <code>Upload.prototype.init</code> 函数也不再需要，因为 upload 对象初始化的工作被放在了 <code>uploadManager.add</code> 函数里面，接下来只需要定义 <code>Upload.prototype.del</code> 函数即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">  uploadManager.setExternalState( id, <span class="keyword">this</span> ); <span class="comment">// 表示把当前 id 对应的对象的外部状态都组装到共享对象中</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">window</span>.confirm( <span class="string">'确定要删除该文件吗? '</span> + <span class="keyword">this</span>.fileName ) )&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild( <span class="keyword">this</span>.dom );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工厂进行对象实例化</strong>：定义一个工厂来创建 upload 对象，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象，否则创建一个新的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> UploadFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> createdFlyWeightObjs = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( createdFlyWeightObjs [ uploadType] )&#123;</span><br><span class="line">      <span class="keyword">return</span> createdFlyWeightObjs [ uploadType];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> createdFlyWeightObjs [ uploadType] = <span class="keyword">new</span> Upload( uploadType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>管理器封装外部状态</strong>： <code>uploadManager</code> 对象负责向 <code>UploadFactory</code> 提交创建对象的请求，并用一个 <code>uploadDatabase</code> 对象保存所有 <code>upload</code> 对象的外部状态，以便在程序运行过程中给 <code>upload</code> 共享对象设置外部状态，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadManager = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uploadDatabase = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 创建上传文件函数</span></span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> id, uploadType, fileName, fileSize </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> flyWeightObj = UploadFactory.create( uploadType );</span><br><span class="line">      <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">      dom.innerHTML =</span><br><span class="line">      <span class="string">'&lt;span&gt;文件名称:'</span>+ fileName +<span class="string">', 文件大小: '</span>+ fileSize +<span class="string">'&lt;/span&gt;'</span> +</span><br><span class="line">      <span class="string">'&lt;button class="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">      dom.querySelector( <span class="string">'.delFile'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; flyWeightObj.delFile( id ); &#125;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild( dom );</span><br><span class="line">      uploadDatabase[ id ] = &#123; <span class="attr">fileName</span>: fileName, <span class="attr">fileSize</span>: fileSize, <span class="attr">dom</span>: dom &#125;;</span><br><span class="line">      <span class="keyword">return</span> flyWeightObj ;</span><br><span class="line">    &#125;,</span><br><span class="line">    setExternalState: <span class="function"><span class="keyword">function</span>(<span class="params"> id, flyWeightObj </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> uploadData = uploadDatabase[ id ];</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> uploadData )&#123; flyWeightObj[ i ] = uploadData[ i ]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>接着是触发上传动作的 <code>startUpload</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType, files </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[ i++ ]; )&#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后测试，运行下面的代码后，可以发现运行结果跟用享元模式重构之前一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件类型上传文件</span></span><br><span class="line">startUpload( <span class="string">'plugin'</span>, [</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'1.txt'</span>, <span class="attr">fileSize</span>: <span class="number">1000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'2.html'</span>, <span class="attr">fileSize</span>: <span class="number">3000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'3.txt'</span>, <span class="attr">fileSize</span>: <span class="number">5000</span> &#125;</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Flash类型上传文件</span></span><br><span class="line">startUpload( <span class="string">'flash'</span>, [</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'4.txt'</span>, <span class="attr">fileSize</span>: <span class="number">1000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'5.html'</span>, <span class="attr">fileSize</span>: <span class="number">3000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">fileName</span>: <span class="string">'6.txt'</span>, <span class="attr">fileSize</span>: <span class="number">5000</span> &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h4 id="9-4-享元模式的适用性"><a href="#9-4-享元模式的适用性" class="headerlink" title="9.4 享元模式的适用性"></a>9.4 享元模式的适用性</h4><p>享元模式的适用场景：</p>
<ul>
<li>一个程序中使用了大量的相似对象；</li>
<li>由于使用了大量对象，造成很大的内存开销；</li>
<li>对象的大多数状态都可以变为外部状态；</li>
<li>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象；</li>
</ul>
<h4 id="9-5-再谈内部状态和外部状态"><a href="#9-5-再谈内部状态和外部状态" class="headerlink" title="9.5  再谈内部状态和外部状态"></a>9.5  再谈内部状态和外部状态</h4><p>实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象；现在来考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候；</p>
<p><strong>没有内部状态的享元：</strong></p>
<p><strong>没有外部状态的享元：</strong></p>
<h4 id="2-9-6-对象池"><a href="#2-9-6-对象池" class="headerlink" title="2.9.6 对象池"></a>2.9.6 对象池</h4><p>对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 <code>new</code> ，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。</p>
<p><strong>对象池实现：</strong></p>
<p>假设在一个地图应用中， 地图上经常会出现一些标志地名的小气泡，当搜索附近地图的时候，页面里出现了 2 个小气泡。当我再搜索附近的其他地点时，页面中出现了 6 个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2 个小气泡删除掉，而是把它们放进对象池；这样在第二次的搜索结果页面里，只需要再创建 4 个小气泡而不是 6 个；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包,该工厂的 create 方法表示获取一个 div 节点， recover 方法表示回收一个 div 节点：var toolTipFactory = (function()&#123;</span></span><br><span class="line"><span class="keyword">var</span> toolTipFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> toolTipPool = []; <span class="comment">// toolTip 对象池</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( toolTipPool.length === <span class="number">0</span> )&#123; <span class="comment">// 如果对象池为空</span></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> ); <span class="comment">// 创建一个 dom</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">        <span class="keyword">return</span> div;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果对象池里不为空</span></span><br><span class="line">        <span class="keyword">return</span> toolTipPool.shift(); <span class="comment">// 则从对象池中取出一个 dom</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    recover: <span class="function"><span class="keyword">function</span>(<span class="params"> tooltipDom </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> toolTipPool.push( tooltipDom ); <span class="comment">// 对象池回收 dom</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 2. 创建 2 个小气泡节点，并用一个数组 ary 来记录它们</span></span><br><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, str; str = [ <span class="string">'A'</span>, <span class="string">'B'</span> ][ i++ ]; )&#123;</span><br><span class="line">  <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">  toolTip.innerHTML = str;</span><br><span class="line">  ary.push( toolTip );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 假设地图需要开始重新绘制，在此之前要把这两个节点回收进对象池：</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, toolTip; toolTip = ary[ i++ ]; )&#123;</span><br><span class="line">  toolTipFactory.recover( toolTip );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 4. 再创建 6 个小气泡：</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, str; str = [ <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span> ][ i++ ]; )&#123;</span><br><span class="line">  <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">  toolTip.innerHTML = str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-享元模式小结"><a href="#9-6-享元模式小结" class="headerlink" title="9.6  享元模式小结"></a>9.6  享元模式小结</h4><p>享元模式是为解决性能问题而生的模式，在一个存在大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题；</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(八)模板方法模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>待发布</p>
<a id="more"></a>

<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(七)组合模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的；</p>
<a id="more"></a>

<h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7 组合模式"></a>7 组合模式</h3><p>组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的；</p>
<h4 id="7-1-组合模式的用途"><a href="#7-1-组合模式的用途" class="headerlink" title="7.1 组合模式的用途"></a>7.1 组合模式的用途</h4><p>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构，如宏命令的例子，通过遍历该树形结构，调用组合对象的 execute 方法，程序会递归调用组合对象下面的叶对象的 execute 方法；组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，只要约定对象上拥有可执行的 execute 方法即可；</p>
<h4 id="7-2-请求在树中传递的过程"><a href="#7-2-请求在树中传递的过程" class="headerlink" title="7.2 请求在树中传递的过程"></a>7.2 请求在树中传递的过程</h4><p>以宏命令为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通子命令），叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。总之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会有子节点；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14756387-8be455a4b15a1a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_宏命令例子_1576393930_5178.png"></p>
<h4 id="7-3-透明性带来的安全问题"><a href="#7-3-透明性带来的安全问题" class="headerlink" title="7.3 透明性带来的安全问题"></a>7.3 透明性带来的安全问题</h4><p>组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的，组合对象可以拥有子节点，叶对象下面就没有子节点，解决方案通常是给叶对象也增加 add 方法，并且在调用这个方法时，抛出一个异常来及时提醒客户：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合对象</span></span><br><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123; <span class="keyword">this</span>.commandsList.push( command ); &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 叶对象</span></span><br><span class="line"><span class="keyword">var</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'打开电视'</span> ); &#125;,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'叶对象不能添加子节点'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add( openTvCommand );</span><br><span class="line">openTvCommand.add( macroCommand ) <span class="comment">// Uncaught Error: 叶对象不能添加子节点</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-组合模式的例子——扫描文件夹"><a href="#7-4-组合模式的例子——扫描文件夹" class="headerlink" title="7.4 组合模式的例子——扫描文件夹"></a>7.4 组合模式的例子——扫描文件夹</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************* Folder ******************************/</span></span><br><span class="line"><span class="keyword">var</span> Folder = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.files = [];</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> file </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.files.push( file );</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'开始扫描文件夹: '</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file, files = <span class="keyword">this</span>.files; file = files[ i++ ]; )&#123;</span><br><span class="line">    file.scan();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******************************* File ******************************/</span></span><br><span class="line"><span class="keyword">var</span> File = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'文件下面不能再添加文件'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'开始扫描文件: '</span> + <span class="keyword">this</span>.name );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一些文件夹和文件对象， 并且让它们组合成一棵树</span></span><br><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> Folder( <span class="string">'测试文件夹'</span> );</span><br><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> File( <span class="string">'JavaScript 设计模式与开发实践'</span> );</span><br><span class="line">folder.add( file );</span><br><span class="line"><span class="comment">// 操作树的最顶端对象，进行扫描整个文件夹的操作</span></span><br><span class="line">folder.scan();</span><br></pre></td></tr></table></figure>

<h4 id="7-5-组合模式的注意点"><a href="#7-5-组合模式的注意点" class="headerlink" title="7.5 组合模式的注意点"></a>7.5 组合模式的注意点</h4><ol>
<li>组合模式不是父子关系：组合模式是一种 HAS-A（聚合）的关系，而不是 IS-A。组合对象包含一组叶对象，但 Leaf 并不是 Composite 的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口；</li>
<li>对叶对象操作的一致性：组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性；</li>
<li>双向映射关系：假如存在叶对象处在多个组合对象的情况，那么在调用的时候，该叶对象的命令会执行多次，这种复合情况下必须给父节点和子节点建立双向映射关系，一个简单的方法是给组合对象和叶对象都增加集合来保存对方的引用。但这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时可以引入中介者模式来管理这些对象；</li>
<li>用职责链模式提高组合模式性能：在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想，在实际操作中避免遍历整棵树，借助职责链模式进行解决，职责链模式一般需要手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。</li>
</ol>
<h4 id="7-6-引用父对象"><a href="#7-6-引用父对象" class="headerlink" title="7.6 引用父对象"></a>7.6 引用父对象</h4><p>之前示例中组合模式的树结构是从上至下的，但有时候需要在子节点上保持对父节点的引用，比如在组合模式中<br>使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。</p>
<blockquote>
<p>实例：改写扫描文件夹的代码，增加删除功能</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改写 Folder 类和 File 类，在这两个类的构造函数中增加 this.parent 属性，并且在调用 add 方法的时候，正确设置文件或者文件夹的父节点：</span></span><br><span class="line"><span class="keyword">var</span> Folder = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.parent = <span class="literal">null</span>; <span class="comment">// 增加 this.parent 属性</span></span><br><span class="line">  <span class="keyword">this</span>.files = [];</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> file </span>)</span>&#123;</span><br><span class="line">  file.parent = <span class="keyword">this</span>; <span class="comment">//设置父对象</span></span><br><span class="line">  <span class="keyword">this</span>.files.push( file );</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'开始扫描文件夹: '</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file, files = <span class="keyword">this</span>.files; file = files[ i++ ]; )&#123;</span><br><span class="line">    file.scan();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 增加移除文件夹方法 Folder.prototype.remove</span></span><br><span class="line">Folder.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.parent )&#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> files = <span class="keyword">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123;</span><br><span class="line">    <span class="keyword">var</span> file = files[ l ];</span><br><span class="line">    <span class="keyword">if</span> ( file === <span class="keyword">this</span> )&#123; files.splice( l, <span class="number">1</span> ); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File 类的实现基本一致：</span></span><br><span class="line"><span class="keyword">var</span> File = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'不能添加在文件下面'</span> ); &#125;;</span><br><span class="line">File.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始扫描文件: '</span> + <span class="keyword">this</span>.name ); &#125;;</span><br><span class="line">File.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.parent )&#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> files = <span class="keyword">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123;</span><br><span class="line">    <span class="keyword">var</span> file = files[ l ];</span><br><span class="line">    <span class="keyword">if</span> ( file === <span class="keyword">this</span> )&#123; files.splice( l, <span class="number">1</span> ); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试一下移除文件功能：</span></span><br><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> Folder( <span class="string">'学习资料'</span> );</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> Folder( <span class="string">'JavaScript'</span> );</span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> Folder ( <span class="string">'深入浅出 Node.js'</span> );</span><br><span class="line">folder1.add( <span class="keyword">new</span> File( <span class="string">'JavaScript 设计模式与开发实践'</span> ) );</span><br><span class="line">folder.add( folder1 );</span><br><span class="line">folder.add( file1 );</span><br><span class="line">folder1.remove(); <span class="comment">//移除文件夹</span></span><br><span class="line">folder.scan();</span><br></pre></td></tr></table></figure>

<h4 id="7-7-使用组合模式场景"><a href="#7-7-使用组合模式场景" class="headerlink" title="7.7 使用组合模式场景"></a>7.7 使用组合模式场景</h4><ul>
<li>表示对象的<strong>部分-整体层次结构</strong>。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且<strong>符合开放-封闭原则</strong>。</li>
<li>客户希望<strong>统一对待</strong>树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、 else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</li>
</ul>
<h4 id="7-8-组合模式小结"><a href="#7-8-组合模式小结" class="headerlink" title="7.8 组合模式小结"></a>7.8 组合模式小结</h4><p>组合模式可以让我们使用树形方式创建对象的结构。我们可以把相同的操作应用在组合对象和单个对象上。在大多数情况下都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们；但在使用了组合模式的系统中，每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解，并且组合模式会创建了太多的对象；</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(六)命令模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式的命令指的是一个执行某些特定事情的指令；</p>
<a id="more"></a>

<h3 id="6-命令模式"><a href="#6-命令模式" class="headerlink" title="6 命令模式"></a>6 命令模式</h3><h4 id="6-1-命令模式的用途"><a href="#6-1-命令模式的用途" class="headerlink" title="6.1 命令模式的用途"></a>6.1 命令模式的用途</h4><p>命令模式的命令指的是一个执行某些特定事情的指令；</p>
<p><strong>命令模式的应用场景</strong>：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发图送者和请求接收者能够消除彼此之间的耦合关系；</p>
<h4 id="6-2-命令模式的例子——菜单程序"><a href="#6-2-命令模式的例子——菜单程序" class="headerlink" title="6.2 命令模式的例子——菜单程序"></a>6.2 命令模式的例子——菜单程序</h4><p>实现一个点击不同按钮调用不同方法的功能 (模拟传统面向对象语言的命令模式实现)：</p>
<ol>
<li><p>按钮绘制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button1"</span>&gt;</span>点击按钮 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button2"</span>&gt;</span>点击按钮 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button3"</span>&gt;</span>点击按钮 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> button1 = <span class="built_in">document</span>.getElementById( <span class="string">'button1'</span> ),</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> button2 = <span class="built_in">document</span>.getElementById( <span class="string">'button2'</span> ),</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> button3 = <span class="built_in">document</span>.getElementById( <span class="string">'button3'</span> );</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 <code>setCommand</code> 函数， <code>setCommand</code> 函数负责往按钮上面安装命令。约定点击按钮会执行某个 <code>command</code> 命令，执行命令的动作被约定为调用 <code>command</code> 对象的 <code>execute()</code> 方法；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> button, command </span>)</span>&#123;</span><br><span class="line">  button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; command.execute(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写点击按钮之后的具体行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MenuBar = &#123;</span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷新菜单目录'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> SubMenu = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'增加子菜单'</span> ); &#125;,</span><br><span class="line">  del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删除子菜单'</span> ); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装行为在命令类中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line">RefreshMenuBarCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver.refresh();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> AddSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line">AddSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver.add();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DelSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">this</span>.receiver = receiver; &#125;;</span><br><span class="line">DelSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删除子菜单'</span> ); &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把命令接收者传入到 <code>command</code> 对象中，并且把 <code>command</code> 对象安装到 <code>button</code> 上面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> RefreshMenuBarCommand( MenuBar );</span><br><span class="line"><span class="keyword">var</span> addSubMenuCommand = <span class="keyword">new</span> AddSubMenuCommand( SubMenu );</span><br><span class="line"><span class="keyword">var</span> delSubMenuCommand = <span class="keyword">new</span> DelSubMenuCommand( SubMenu );</span><br><span class="line"></span><br><span class="line">setCommand( button1, refreshMenuBarCommand );</span><br><span class="line">setCommand( button2, addSubMenuCommand );</span><br><span class="line">setCommand( button3, delSubMenuCommand );</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-3-JavaScript-中的命令模式"><a href="#6-3-JavaScript-中的命令模式" class="headerlink" title="6.3 JavaScript 中的命令模式"></a>6.3 JavaScript 中的命令模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindClick = <span class="function"><span class="keyword">function</span>(<span class="params"> button, func </span>)</span>&#123; button.onclick = func; &#125;;</span><br><span class="line"><span class="keyword">var</span> MenuBar = &#123;</span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷新菜单界面'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> SubMenu = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'增加子菜单'</span> ); &#125;,</span><br><span class="line">  del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删除子菜单'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bindClick( button1, MenuBar.refresh );</span><br><span class="line">bindClick( button2, SubMenu.add );</span><br><span class="line">bindClick( button3, SubMenu.del );</span><br></pre></td></tr></table></figure>

<p>JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了 JavaScript 语言之中；运算块不一定要封装在 <code>command.execute</code> 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。</p>
<h4 id="6-4-撤消命令"><a href="#6-4-撤消命令" class="headerlink" title="6.4 撤消命令"></a>6.4 撤消命令</h4><p>撤销操作的实现一般是给命令对象增加一个名为 unexecude 或者 undo 的方法，在该方法里执行 execute 的反向操作。在 command.execute 方法让小球开始真正运动之前，我们需要先记录小球的当前位置，在 unexecude 或者 undo 操作中，再让小球回到刚刚记录下的位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ball = <span class="built_in">document</span>.getElementById( <span class="string">'ball'</span> );</span><br><span class="line"><span class="keyword">var</span> pos = <span class="built_in">document</span>.getElementById( <span class="string">'pos'</span> );</span><br><span class="line"><span class="keyword">var</span> moveBtn = <span class="built_in">document</span>.getElementById( <span class="string">'moveBtn'</span> );</span><br><span class="line"><span class="keyword">var</span> cancelBtn = <span class="built_in">document</span>.getElementById( <span class="string">'cancelBtn'</span> );</span><br><span class="line"><span class="keyword">var</span> MoveCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver, pos </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">  <span class="keyword">this</span>.pos = pos;</span><br><span class="line">  <span class="keyword">this</span>.oldPos = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">MoveCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver.start( <span class="string">'left'</span>, <span class="keyword">this</span>.pos, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span> );</span><br><span class="line">  <span class="keyword">this</span>.oldPos = <span class="keyword">this</span>.receiver.dom.getBoundingClientRect()[ <span class="keyword">this</span>.receiver.propertyName ];</span><br><span class="line">  <span class="comment">// 记录小球开始移动前的位置</span></span><br><span class="line">&#125;;</span><br><span class="line">MoveCommand.prototype.undo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver.start( <span class="string">'left'</span>, <span class="keyword">this</span>.oldPos, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span> );</span><br><span class="line">  <span class="comment">// 回到小球移动前记录的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> moveCommand;</span><br><span class="line">moveBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animate = <span class="keyword">new</span> Animate( ball );</span><br><span class="line">  moveCommand = <span class="keyword">new</span> MoveCommand( animate, pos.value );</span><br><span class="line">  moveCommand.execute();</span><br><span class="line">&#125;;</span><br><span class="line">cancelBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  moveCommand.undo(); <span class="comment">// 撤销命令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-宏命令"><a href="#5-宏命令" class="headerlink" title="5 宏命令"></a>5 宏命令</h4><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个 execute 方法负责执行命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'关门'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开电脑'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'登录 QQ'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123; <span class="keyword">this</span>.commandsList.push( command ); &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add( closeDoorCommand );</span><br><span class="line">macroCommand.add( openPcCommand );</span><br><span class="line">macroCommand.add( openQQCommand );</span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure>

<h4 id="6-命令模式小结"><a href="#6-命令模式小结" class="headerlink" title="6 命令模式小结"></a>6 命令模式小结</h4><p> JavaScript 可以用高阶函数非常方便地实现命令模式，命令模式在 JavaScript 语言中是一种隐形的模式。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(五)发布订阅模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>发布订阅模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知；</p>
<a id="more"></a>

<h3 id="5-发布订阅模式-观察者模式"><a href="#5-发布订阅模式-观察者模式" class="headerlink" title="5 发布订阅模式(观察者模式)"></a>5 发布订阅模式(观察者模式)</h3><p>发布订阅模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知；</p>
<h4 id="5-1-发布－-订阅模式的作用"><a href="#5-1-发布－-订阅模式的作用" class="headerlink" title="5.1 发布－ 订阅模式的作用"></a>5.1 发布－ 订阅模式的作用</h4><p>发布—订阅模式的应用都非常之广泛，首先看一个现实中的例子，小明最近在看房子，到了某个售楼处之后才被告知，该楼盘的房子早已售罄，小明离开之前，把电话号码留在了售楼处。售楼处答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们；</p>
<p>在这个例子中使用发布—订阅模式有着显而易见的优点：</p>
<ol>
<li>购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。这点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案；</li>
<li>购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，同时售楼处的任何变动也不会影响购买者，只要售楼处记得发短信这件事情。这点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</li>
</ol>
<h4 id="5-2-发布订阅模式的实现"><a href="#5-2-发布订阅模式的实现" class="headerlink" title="5.2 发布订阅模式的实现"></a>5.2 发布订阅模式的实现</h4><blockquote>
<ol>
<li>实现上述发布订阅模式实例步骤：</li>
</ol>
</blockquote>
<ul>
<li>首先要指定好谁充当发布者（比如售楼处）；</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）；</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;; <span class="comment">// 定义售楼处</span></span><br><span class="line">salesOffices.clientList = []; <span class="comment">// 缓存列表，存放订阅者的回调函数</span></span><br><span class="line">salesOffices.listen = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123; <span class="comment">// 增加订阅者</span></span><br><span class="line">  <span class="keyword">this</span>.clientList.push( fn ); <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line">salesOffices.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 发布消息</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[ i++ ]; )&#123;</span><br><span class="line">  f  n.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// (2) // arguments 是发布消息时带上的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试数据</span></span><br><span class="line">salesOffices.listen( <span class="function"><span class="keyword">function</span>(<span class="params"> price, squareMeter </span>)</span>&#123; <span class="comment">// 小明订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'squareMeter= '</span> + squareMeter );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen( <span class="function"><span class="keyword">function</span>(<span class="params"> price, squareMeter </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'squareMeter= '</span> + squareMeter );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.trigger( <span class="number">2000000</span>, <span class="number">88</span> ); <span class="comment">// 输出： 200 万， 88 平方米</span></span><br><span class="line">salesOffices.trigger( <span class="number">3000000</span>, <span class="number">110</span> ); <span class="comment">// 输出： 300 万， 110 平方米</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>发布订阅模式的通用实现</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：把发布订阅的功能提取出来，放在一个单独的对象内</span></span><br><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">  clientList: [],</span><br><span class="line">  listen: <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.clientList[ key ] )&#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[ key ] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[ key ].push( fn ); <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> ), <span class="comment">// (1);</span></span><br><span class="line">    fns = <span class="keyword">this</span>.clientList[ key ];</span><br><span class="line">    <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="comment">// 如果没有绑定对应的消息</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123;</span><br><span class="line">    fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// (2) // arguments 是 trigger 时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二步：定义 installEvent 函数给所有的对象都动态安装发布—订阅功能</span></span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> event )&#123;</span><br><span class="line">    obj[ i ] = event[ i ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试：给售楼处对象 salesOffices 动态增加发布—订阅功能</span></span><br><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小明订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter100'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输出： 2000000</span></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter100'</span>, <span class="number">3000000</span> ); <span class="comment">// 输出： 3000000</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-取消订阅的事件"><a href="#5-3-取消订阅的事件" class="headerlink" title="5.3 取消订阅的事件"></a>5.3 取消订阅的事件</h4><p>有时也许需要取消订阅事件的功能，因此给 <code>event</code> 对象增加 <code>remove</code> 方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.remove = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[ key ];</span><br><span class="line">  <span class="keyword">if</span> ( !fns )&#123; <span class="comment">// 如果 key 对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !fn )&#123; <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></span><br><span class="line">    fns &amp;&amp; ( fns.length = <span class="number">0</span> );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123; <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">      <span class="keyword">var</span> _fn = fns[ l ];</span><br><span class="line">      <span class="keyword">if</span> ( _fn === fn )&#123;</span><br><span class="line">        fns.splice( l, <span class="number">1</span> ); <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> event )&#123;</span><br><span class="line">    obj[ i ] = event[ i ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小明订阅消息</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.remove( <span class="string">'squareMeter88'</span>, fn1 ); <span class="comment">// 删除小明的订阅</span></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输出： 2000000</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-网站登录实例-P116"><a href="#5-4-网站登录实例-P116" class="headerlink" title="5.4 网站登录实例(P116)"></a>5.4 网站登录实例(P116)</h4><h4 id="5-5-全局的发布订阅对象"><a href="#5-5-全局的发布订阅对象" class="headerlink" title="5.5 全局的发布订阅对象"></a>5.5 全局的发布订阅对象</h4><p>刚刚实现的发布订阅模式，给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题：</p>
<ol>
<li>给每个发布者对象都添加了 <code>listen</code> 和 <code>trigger</code> 方法，以及一个缓存列表 <code>clientList</code> ，这其实是一种资源浪费；</li>
<li>订阅者跟售楼处对象还是存在一定的耦合性，订阅者至少要知道售楼处对象的名字是 <code>salesOffices</code> ，才能顺利的订阅到事件；</li>
</ol>
<p>实际上，订阅者没必要亲自去售楼处，只需要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。因此，发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者， Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clientList = &#123;&#125;, listen, trigger, remove;</span><br><span class="line">  listen = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !clientList[ key ] )&#123;</span><br><span class="line">      clientList[ key ] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    clientList[ key ].push( fn );</span><br><span class="line">  &#125;;</span><br><span class="line">  trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> ),</span><br><span class="line">    fns = clientList[ key ];</span><br><span class="line">    <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123;</span><br><span class="line">      fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  remove = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = clientList[ key ];</span><br><span class="line">    <span class="keyword">if</span> ( !fns )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !fn )&#123;</span><br><span class="line">      fns &amp;&amp; ( fns.length = <span class="number">0</span> );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123;</span><br><span class="line">        <span class="keyword">var</span> _fn = fns[ l ];</span><br><span class="line">        <span class="keyword">if</span> ( _fn === fn )&#123;</span><br><span class="line">          fns.splice( l, <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    listen: listen,</span><br><span class="line">    trigger: trigger,</span><br><span class="line">    remove: remove</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">Event.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price ); <span class="comment">// 输出： '价格=2000000'</span></span><br><span class="line">&#125;);</span><br><span class="line">Event.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 售楼处发布消息</span></span><br></pre></td></tr></table></figure>

<h4 id="5-6-模块间通信"><a href="#5-6-模块间通信" class="headerlink" title="5.6 模块间通信"></a>5.6 模块间通信</h4><p>我们利用上一节中实现的发布订阅模式的全局 <code>Event</code> 对象可以在两个封装良好的模块中进行通信，而这两个模块可以完全不知道对方的存在。比如现在有两个模块， a 模块里面有一个按钮，每次点击按钮之后， b 模块里的 div 中会显示按钮的总点击次数，我们用全局发布—订阅模式完成下面的代码，使得 a 模块和 b 模块可以在保持封装性的前提下进行通信。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"count"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'count'</span> );</span></span><br><span class="line"><span class="actionscript">      button.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        Event.trigger( <span class="string">'add'</span>, count++ );</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById( <span class="string">'show'</span> );</span></span><br><span class="line"><span class="actionscript">      Event.listen( <span class="string">'add'</span>, <span class="function"><span class="keyword">function</span><span class="params">( count )</span></span>&#123;</span></span><br><span class="line">        div.innerHTML = count;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)();</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-7-JavaScript-实现发布订阅模式的便利性"><a href="#5-7-JavaScript-实现发布订阅模式的便利性" class="headerlink" title="5.7 JavaScript 实现发布订阅模式的便利性"></a>5.7 JavaScript 实现发布订阅模式的便利性</h4><p>在 JavaScript 中，无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时增加了代码量和复杂度。刚好在 <code>JavaScript</code> 中， <code>arguments</code> 可以很方便地表示参数列表，所以我们一般都会选择推模型，使用 <code>Function.prototype.apply</code> 方法把所有参数都推送给订阅者。</p>
<h4 id="5-8-发布订阅模式小结"><a href="#5-8-发布订阅模式小结" class="headerlink" title="5.8 发布订阅模式小结"></a>5.8 发布订阅模式小结</h4><p>发布订阅模式是一种非常重要的模式，在实际开发中非常有用。既可以用在异步编程中，也可以帮助完成更松耦合的代码编写。发布订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。 从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript 本身也是一门基于事件驱动的语言。</p>
<p>发布订阅模式的优点一为时间上的解耦，二为对象之间的解耦。发布订阅模式缺点就是创建订阅者本身要消耗一定的时间和内存，若订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中；若过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>发布订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(四)迭代器模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<a id="more"></a>

<h3 id="4-迭代器模式"><a href="#4-迭代器模式" class="headerlink" title="4 迭代器模式"></a>4 迭代器模式</h3><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<h4 id="4-1-each-函数"><a href="#4-1-each-函数" class="headerlink" title="4.1 each 函数"></a>4.1 each 函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, callback </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = ary.length; i &lt; l; i++ )&#123;</span><br><span class="line">    callback.call( ary[i], i, ary[ i ] ); <span class="comment">// 把下标和元素当作参数传给 callback 函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">each( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123;</span><br><span class="line">  alert ( [ i, n ] );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-2-内部迭代器和外部迭代器"><a href="#4-2-内部迭代器和外部迭代器" class="headerlink" title="4.2 内部迭代器和外部迭代器"></a>4.2 内部迭代器和外部迭代器</h4><ul>
<li>内部迭代器：外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，如 each 函数；</li>
<li>外部迭代器：必须显式地请求迭代下一个元素；增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，可以手工控制迭代的过程或者顺序；</li>
</ul>
<blockquote>
<p>实现判断 2 个数组里元素的值是否完全相等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 内部迭代器实现</span></span><br><span class="line"><span class="keyword">var</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params"> ary1, ary2 </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ary1.length !== ary2.length )&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> ( <span class="string">'ary1 和 ary2 不相等'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  each( ary1, <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n !== ary2[ i ] )&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> ( <span class="string">'ary1 和 ary2 不相等'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  alert ( <span class="string">'ary1 和 ary2 相等'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">compare( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ], [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span> ] ); <span class="comment">// throw new Error ( 'ary1 和 ary2 不相等' );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.外部迭代器实现</span></span><br><span class="line"><span class="keyword">var</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; current += <span class="number">1</span>; &#125;;</span><br><span class="line">  <span class="keyword">var</span> isDone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> current &gt;= obj.length; &#125;;</span><br><span class="line">  <span class="keyword">var</span> getCurrItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> obj[ current ]; &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: next,</span><br><span class="line">    isDone: isDone,</span><br><span class="line">    getCurrItem: getCurrItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params"> iterator1, iterator2 </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>( !iterator1.isDone() &amp;&amp; !iterator2.isDone() )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> ( <span class="string">'iterator1 和 iterator2 不相等'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    iterator1.next();</span><br><span class="line">    iterator2.next();</span><br><span class="line">  &#125;</span><br><span class="line">  alert ( <span class="string">'iterator1 和 iterator2 相等'</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator1 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br><span class="line"><span class="keyword">var</span> iterator2 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br><span class="line">compare( iterator1, iterator2 ); <span class="comment">// 输出： iterator1 和 iterator2 相等</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-迭代器模式的应用举例"><a href="#4-3-迭代器模式的应用举例" class="headerlink" title="4.3 迭代器模式的应用举例"></a>4.3 迭代器模式的应用举例</h4><p>文件上传模块中，根据不同的浏览器获取相应的上传组件对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 最初代码，使用 if-else 一个个进行判断</span></span><br><span class="line"><span class="keyword">var</span> getUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"TXFTNActiveX.FTNUpload"</span>); <span class="comment">// IE 上传控件</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( supportFlash() )&#123; <span class="comment">// supportFlash 函数未提供</span></span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'</span>;</span><br><span class="line">      <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'&lt;input name="file" type="file"/&gt;'</span>; <span class="comment">// 表单上传</span></span><br><span class="line">      <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2. 迭代器：每种获取 upload 对象的方法都封装在各自的函数，使用一个迭代器，迭代获取这些 upload 对象，直到获取到一个可用的为止；每种 upload 对象约定若该函数里面的 upload 对象是可用的，则让函数返回该对象，反之返回 false，提示迭代器继续往后面进行迭代；</span></span><br><span class="line"><span class="keyword">var</span> getActiveUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject( <span class="string">"TXFTNActiveX.FTNUpload"</span> ); <span class="comment">// IE 上传控件</span></span><br><span class="line">   &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getFlashUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( supportFlash() )&#123; <span class="comment">// supportFlash 函数未提供</span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'</span>;</span><br><span class="line">    <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getFormUpladObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">'&lt;input name="file" type="file" class="ui-file"/&gt;'</span>; <span class="comment">// 表单上传</span></span><br><span class="line">  <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 迭代器代码</span></span><br><span class="line"><span class="keyword">var</span> iteratorUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="built_in">arguments</span>[ i++ ]; )&#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj = fn();</span><br><span class="line">    <span class="keyword">if</span> ( uploadObj !== <span class="literal">false</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> uploadObj;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj );</span><br></pre></td></tr></table></figure>

<h4 id="4-4-迭代器模式小结"><a href="#4-4-迭代器模式小结" class="headerlink" title="4.4 迭代器模式小结"></a>4.4 迭代器模式小结</h4><p>迭代器模式是一种相对简单的模式，目前的绝大部分语言都内置了迭代器。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(三)代理模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式分为保护代理和虚拟代理，保护代理用于控制不同权限的对象对目标对象的访问，虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建；</p>
<a id="more"></a>

<h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3 代理模式"></a>3 代理模式</h3><p>代理模式：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式分为保护代理和虚拟代理，保护代理用于控制不同权限的对象对目标对象的访问，虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建；</p>
<h4 id="3-1-虚拟代理实现图片预加载"><a href="#3-1-虚拟代理实现图片预加载" class="headerlink" title="3.1 虚拟代理实现图片预加载"></a>3.1 虚拟代理实现图片预加载</h4><blockquote>
<ol>
<li>虚拟代理实现图片预加载<br>图片预加载中先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种场景就很适合使用虚拟代理；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( imgNode );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 代理对象,在图片被真正加载好之前，页面中将出现一张占位的图 loading.gif, 来提示图片正在加载</span></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    myImage.setSrc( <span class="keyword">this</span>.src );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">      myImage.setSrc( <span class="string">'file:///C:/Users/admin/Desktop/loading.gif'</span> );</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.setSrc( <span class="string">'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg'</span> );</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>不用代理的预加载图片函数实现：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( imgNode );</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    imgNode.src = img.src;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">      imgNode.src = <span class="string">'file:// /C:/Users/svenzeng/Desktop/loading.gif'</span>;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">MyImage.setSrc( <span class="string">'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg'</span> );</span><br></pre></td></tr></table></figure>

<p>上段代码中的 MyImage 对象除了负责给 img 节点设置 src 外，还要负责预加载图片。在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现；在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放—封闭原则；假如之后只是从网络上获取一些体积很小的图片，或者根本不再需要预加载，我们希望把预加载图片的这段代码从 MyImage 对象里删掉，这时候就不得不改动 MyImage 对象了。而实际上需要的只是给 img 节点设置 src，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法；于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体 MyImage ；</p>
<p><strong>单一职责原则</strong>：就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏；</p>
<h4 id="3-2-虚拟代理合并-HTTP-请求"><a href="#3-2-虚拟代理合并-HTTP-请求" class="headerlink" title="3.2 虚拟代理合并 HTTP 请求"></a>3.2 虚拟代理合并 HTTP 请求</h4><p>使用代理函数合并 HTTP 请求实现：使用代理函数收集一段时间之内的请求，最后一次性发送给服务器；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span>1</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span>2</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span>3</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> synchronousFile = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开始同步文件， id 为: '</span> + id ); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxySynchronousFile = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = [], <span class="comment">// 保存一段时间内需要同步的 ID</span></span><br><span class="line">  timer; <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">    cache.push( id );</span><br><span class="line">    <span class="keyword">if</span> ( timer )&#123; <span class="comment">// 保证不会覆盖已经启动的定时器</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      synchronousFile( cache.join( <span class="string">','</span> ) ); <span class="comment">// 2 秒后发送需要同步的 ID 集合</span></span><br><span class="line">      clearTimeout( timer ); <span class="comment">// 清空定时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      cache.length = <span class="number">0</span>; <span class="comment">// 清空 ID 集合</span></span><br><span class="line">    &#125;, <span class="number">2000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkbox = <span class="built_in">document</span>.getElementsByTagName( <span class="string">'input'</span> );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, c; c = checkbox[ i++ ]; )&#123;</span><br><span class="line">  c.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.checked === <span class="literal">true</span> )&#123;</span><br><span class="line">      proxySynchronousFile( <span class="keyword">this</span>.id );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-缓存代理"><a href="#3-3-缓存代理" class="headerlink" title="3.3 缓存代理"></a>3.3 缓存代理</h4><blockquote>
<p>缓存代理实例：计算乘积；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乘积函数</span></span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">    a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 缓存代理函数</span></span><br><span class="line"><span class="keyword">var</span> proxyMult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">    <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = mult.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyMult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// 输出： 24</span></span><br><span class="line">proxyMult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// 输出： 24</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>缓存代理用于ajax异步请求数据</p>
</blockquote>
<p>在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。</p>
<h4 id="3-4-高阶函数动态创建代理"><a href="#3-4-高阶函数动态创建代理" class="headerlink" title="3.4 高阶函数动态创建代理"></a>3.4 高阶函数动态创建代理</h4><p>实例：为乘法、加法、减法等创建缓存代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************** 计算乘积 *****************/</span></span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123; a = a * <span class="built_in">arguments</span>[i]; &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**************** 计算加和 *****************/</span></span><br><span class="line"><span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123; a = a + <span class="built_in">arguments</span>[i]; &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**************** 创建缓存代理的工厂 *****************/</span></span><br><span class="line"><span class="keyword">var</span> createProxyFactory = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">    <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyMult = createProxyFactory( mult ), proxyPlus = createProxyFactory( plus );</span><br><span class="line">alert ( proxyMult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ) ); <span class="comment">// 输出： 24</span></span><br><span class="line">alert ( proxyPlus( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ) ); <span class="comment">// 输出： 10</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-其他代理模式的应用"><a href="#3-5-其他代理模式的应用" class="headerlink" title="3.5 其他代理模式的应用"></a>3.5 其他代理模式的应用</h4><ul>
<li>防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。</li>
<li>远程代理：为一个对象在不同的地址空间提供局部代表，在 Java 中，远程代理可以是另一个虚拟机中的对象。</li>
<li>保护代理：用于对象应该有不同访问权限的情况。</li>
<li>智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</li>
<li>写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体， DLL（操作系统中的动态链接库）是其典型运用场景。</li>
</ul>
<h4 id="3-6-代理模式小结"><a href="#3-6-代理模式小结" class="headerlink" title="3.6 代理模式小结"></a>3.6 代理模式小结</h4><p>代理模式在 JavaScript 开发中最常用的是虚拟代理和缓存代理。一般在编写代码的时候不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理模式代码。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(二)策略模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>策略模式定义： 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换；</p>
<a id="more"></a>

<h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2 策略模式"></a>2 策略模式</h3><p>策略模式定义： 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换；</p>
<h4 id="2-1-策略模式"><a href="#2-1-策略模式" class="headerlink" title="2.1 策略模式"></a>2.1 策略模式</h4><p>策略模式的目的就是将算法的使用与算法的实现分离开来，将不变的部分和变化的部分隔开是每个设计模式的主题；</p>
<p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。 第二个部分是环境类 Context， Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用；</p>
<blockquote>
<p>实例：积分模式（基础分乘上对于的等级倍数）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 最简单代码实现</span></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> level, base </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( level === <span class="string">'S'</span> )&#123; <span class="keyword">return</span> base * <span class="number">4</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> ( level === <span class="string">'A'</span> )&#123; <span class="keyword">return</span> base * <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus( <span class="string">'B'</span>, <span class="number">10</span> ); <span class="comment">// 输出： 40</span></span><br><span class="line">calculateBonus( <span class="string">'S'</span>, <span class="number">5</span> ); <span class="comment">// 输出： 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 模仿传统面向对象语言中的策略模式实现</span></span><br><span class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> base </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  performanceA.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> base </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> base * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义总分类 Bonus：</span></span><br><span class="line"><span class="keyword">var</span> Bonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = <span class="literal">null</span>; <span class="comment">// 原始值</span></span><br><span class="line">  <span class="keyword">this</span>.strategy = <span class="literal">null</span>; <span class="comment">// 等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = <span class="function"><span class="keyword">function</span>(<span class="params"> base </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = base; <span class="comment">// 设置基础值</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setStrategy = <span class="function"><span class="keyword">function</span>(<span class="params"> strategy </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.strategy = strategy; <span class="comment">// 设置等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.getBonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取得总分数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate( <span class="keyword">this</span>.base ); <span class="comment">// 把计算分数的操作委托给对应的策略对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-JavaScript-版本的策略模式"><a href="#2-2-JavaScript-版本的策略模式" class="headerlink" title="2.2 JavaScript 版本的策略模式"></a>2.2 JavaScript 版本的策略模式</h4><p>在 JavaScript 语言中，函数也是对象，所以更简单和直接的做法是把 <code>strategy</code> 直接定义为函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">  <span class="string">"S"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> base </span>)</span>&#123; <span class="keyword">return</span> base * <span class="number">4</span>; &#125;,</span><br><span class="line">  <span class="string">"A"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> base </span>)</span>&#123; <span class="keyword">return</span> base * <span class="number">3</span>; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> level, base </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[ level ]( base );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'S'</span>, <span class="number">10</span> ) ); <span class="comment">// 输出： 40</span></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'A'</span>, <span class="number">5</span> ) ); <span class="comment">// 输出： 15</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-策略模式实现表单校验"><a href="#2-3-策略模式实现表单校验" class="headerlink" title="2.3 策略模式实现表单校验"></a>2.3 策略模式实现表单校验</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1. 封装策略对象</span></span><br><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">  isNonEmpty: <span class="function"><span class="keyword">function</span>(<span class="params"> value, errorMsg </span>)</span>&#123; <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> ( value === <span class="string">''</span> )&#123; <span class="keyword">return</span> errorMsg ; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minLength: <span class="function"><span class="keyword">function</span>(<span class="params"> value, length, errorMsg </span>)</span>&#123; <span class="comment">// 限制最小长度</span></span><br><span class="line">    <span class="keyword">if</span> ( value.length &lt; length )&#123; <span class="keyword">return</span> errorMsg; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isMobile: <span class="function"><span class="keyword">function</span>(<span class="params"> value, errorMsg </span>)</span>&#123; <span class="comment">// 手机号码格式</span></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test( value ) )&#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 步骤2. 实现 Validator 类(作为 Context，负责接收用户的请求并委托给 strategy 对象)</span></span><br><span class="line"><span class="keyword">var</span> Validator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = []; <span class="comment">// 保存校验规则</span></span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> dom, rule, errorMsg </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ary = rule.split( <span class="string">':'</span> ); <span class="comment">// 把 strategy 和参数分开</span></span><br><span class="line">  <span class="keyword">this</span>.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 把校验的步骤用空函数包装起来，并且放入 cache</span></span><br><span class="line">    <span class="keyword">var</span> strategy = ary.shift(); <span class="comment">// 用户挑选的 strategy</span></span><br><span class="line">    ary.unshift( dom.value ); <span class="comment">// 把 input 的 value 添加进参数列表</span></span><br><span class="line">    ary.push( errorMsg ); <span class="comment">// 把 errorMsg 添加进参数列表</span></span><br><span class="line">    <span class="keyword">return</span> strategies[ strategy ].apply( dom, ary );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, validatorFunc; validatorFunc = <span class="keyword">this</span>.cache[ i++ ]; )&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = validatorFunc(); <span class="comment">// 开始校验，并取得校验后的返回信息</span></span><br><span class="line">    <span class="keyword">if</span> ( msg )&#123; <span class="comment">// 如果有确切的返回值，说明校验没有通过</span></span><br><span class="line">      <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 步骤3. 向 Validator 类发送校验的请求</span></span><br><span class="line"><span class="keyword">var</span> validataFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator(); <span class="comment">// 创建一个 validator 对象</span></span><br><span class="line">  <span class="comment">/***************添加一些校验规则****************/</span></span><br><span class="line">  validator.add( registerForm.userName, <span class="string">'isNonEmpty'</span>, <span class="string">'用户名不能为空'</span> );</span><br><span class="line">  validator.add( registerForm.password, <span class="string">'minLength:6'</span>, <span class="string">'密码长度不能少于 6 位'</span> );</span><br><span class="line">  validator.add( registerForm.phoneNumber, <span class="string">'isMobile'</span>, <span class="string">'手机号码格式不正确'</span> );</span><br><span class="line">  <span class="keyword">var</span> errorMsg = validator.start(); <span class="comment">// 获得校验结果</span></span><br><span class="line">  <span class="keyword">return</span> errorMsg; <span class="comment">// 返回校验结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> registerForm = <span class="built_in">document</span>.getElementById( <span class="string">'registerForm'</span> );</span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> errorMsg = validataFunc(); <span class="comment">// 如果 errorMsg 有确切的返回值，说明未通过校验</span></span><br><span class="line">  <span class="keyword">if</span> ( errorMsg )&#123;</span><br><span class="line">    alert ( errorMsg );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 阻止表单提交</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-策略模式的优缺点"><a href="#2-4-策略模式的优缺点" class="headerlink" title="2.4 策略模式的优缺点"></a>2.4 策略模式的优缺点</h4><blockquote>
<p>策略模式的优点：</p>
</blockquote>
<ul>
<li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句；</li>
<li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展；</li>
<li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作；</li>
<li>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案；</li>
</ul>
<blockquote>
<p>策略模式的缺点：</p>
</blockquote>
<ul>
<li>使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在 Context 中要好；</li>
<li>使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy ；由于 strategy 要向客户暴露它的所有实现，这是违反最少知识原则；</li>
</ul>
<h4 id="2-5-一等函数对象与策略模式"><a href="#2-5-一等函数对象与策略模式" class="headerlink" title="2.5 一等函数对象与策略模式"></a>2.5 一等函数对象与策略模式</h4><p>之前的策略模式示例中，既有模拟传统面向对象语言的版本，也有针对 <code>JavaScript</code> 语言的特有实现。在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中， <code>Context</code> 将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样便能表现出对象的多态性；</p>
<p>在 JavaScript 中，除了使用类来封装算法和行为之外，直接使用函数也是一种选择。这些“算法”可以被封装到函数中并且四处传递，也就是常说的“高阶函数”。实际上在 <code>JavaScript</code> 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> S = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">4</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">3</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> func, salary </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func( salary );</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus( S, <span class="number">10</span> ); <span class="comment">// 输出： 40</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-策略模式小结"><a href="#2-6-策略模式小结" class="headerlink" title="2.6 策略模式小结"></a>2.6 策略模式小结</h4><p>本小节既有接近传统面向对象语言的策略模式实现，也有更适合 JavaScript 语言的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式(一)单例模式</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的定义是： 保证一个类仅有一个实例，并提供一个访问它的全局访问点；</p>
<a id="more"></a>

<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1 单例模式"></a>1 单例模式</h3><p>单例模式的定义是： 保证一个类仅有一个实例，并提供一个访问它的全局访问点；</p>
<h4 id="1-1-实现单例模式"><a href="#1-1-实现单例模式" class="headerlink" title="1.1 实现单例模式"></a>1.1 实现单例模式</h4><p>用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert ( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.instance )&#123;</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton( name );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = Singleton.getInstance( <span class="string">'sven1'</span> );</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance( <span class="string">'sven2'</span> );</span><br><span class="line">alert ( a === b ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-透明的单例模式"><a href="#1-2-透明的单例模式" class="headerlink" title="1.2 透明的单例模式"></a>1.2 透明的单例模式</h4><p>实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> html </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( instance )&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv( <span class="string">'sven1'</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv( <span class="string">'sven2'</span> );</span><br><span class="line">alert ( a === b ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中， CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。虽然目前还没有接触过“单一职责原则”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。</p>
<h4 id="1-3-用代理实现单例模式（也是缓存代理的应用）"><a href="#1-3-用代理实现单例模式（也是缓存代理的应用）" class="headerlink" title="1.3 用代理实现单例模式（也是缓存代理的应用）"></a>1.3 用代理实现单例模式（也是缓存代理的应用）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> html </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.html = html;</span><br><span class="line">  <span class="keyword">this</span>.init();</span><br><span class="line">&#125;;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  div.innerHTML = <span class="keyword">this</span>.html;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 引入代理类 proxySingletonCreateDiv：</span></span><br><span class="line"><span class="keyword">var</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> html </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !instance )&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> CreateDiv( html );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv( <span class="string">'sven1'</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv( <span class="string">'sven2'</span> );</span><br><span class="line">alert ( a === b );</span><br></pre></td></tr></table></figure>

<h4 id="1-4-JavaScript-中的单例模式"><a href="#1-4-JavaScript-中的单例模式" class="headerlink" title="1.4 JavaScript 中的单例模式"></a>1.4 JavaScript 中的单例模式</h4><p>前几种单例模式的实现是接近传统面向对象语言中的实现，单例对象是从“类”中创建而来。如在 Java 中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来的；而JavaScript 其实是一门无类（ class-free）语言，因此，生搬单例模式的概念并无意义，JavaScript中只需要创建一个<code>唯一</code>的对象即可；</p>
<p>JavaScript 开发中经常会把全局变量当成单例来使用， 但全局变量存在很多问题，很容易造成命名空间污染，因而需要尽量减少全局变量使用：</p>
<ol>
<li>适当使用命名空间，以对象字面量的方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert (<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用闭包封装私有变量：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'sven'</span>, age = <span class="number">29</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name + <span class="string">'-'</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-5-惰性单例"><a href="#1-5-惰性单例" class="headerlink" title="1.5 惰性单例"></a>1.5 惰性单例</h4><p>惰性单例指的是在需要的时候才创建对象实例；</p>
<blockquote>
<p>实例：创建登录浮窗，实现单例模式，并且在点击的时候才创建</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !div )&#123;</span><br><span class="line">      div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">      div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">      div.style.display = <span class="string">'none'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'loginBtn'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loginLayer = createLoginLayer();</span><br><span class="line">  loginLayer.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-通用的惰性单例"><a href="#1-6-通用的惰性单例" class="headerlink" title="1.6 通用的惰性单例"></a>1.6 通用的惰性单例</h4><p>上部分代码违反单一职责原则的，创建对象和管理单例的逻辑都放在 <code>createLoginLayer</code> 对象内部，下次需要创建页面中唯一的 <code>iframe</code> ，或者 <code>script</code> 标签，就得把 <code>createLoginLayer</code> 函数几乎照抄一遍；因而考虑把不变的部分隔离出，即为管理单例的逻辑，用一个变量来标志是否创建过对象，若是则在下次直接返回这个已经创建好的对象，再把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 <code>getSingle</code> 函数内部，创建对象的方法 <code>fn</code> 被当成参数动态传入 <code>getSingle</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || ( result = fn .apply(<span class="keyword">this</span>, <span class="built_in">arguments</span> ) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">  div.innerHTML = <span class="string">'登录浮窗'</span>;</span><br><span class="line">  div.style.display = <span class="string">'none'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">  <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle( createLoginLayer );</span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'loginBtn'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loginLayer = createSingleLoginLayer();</span><br><span class="line">  loginLayer.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-单例模式小结"><a href="#1-7-单例模式小结" class="headerlink" title="1.7 单例模式小结"></a>1.7 单例模式小结</h4><p>单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力；</p>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式基础知识</title>
    <url>/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/2020/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.png" alt="JavaScript设计模式与开发实践"></p>
<!-- 
设计模式是在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案，通俗说设计模式是在某种场合下对某个问题的一种解决方案。模式是一些经过了大量实际项目验证的优秀解决方案，熟悉这些模式的程序员会对某些模式的理解也许形成了条件反射，当合适的场景出现时，就可以很快地找到某种模式作为解决方案；所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”，一个程序的设计总是可以分为可变的部分和不变的部分，将可变的封装起来；模式应该用在正确的地方,只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道是否算正确应用； -->

<a id="more"></a>

<blockquote>
<p>本文主要参考了<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">《JavaScript设计模式和开发实践》</a>一书</p>
</blockquote>
<blockquote>
<p>系列链接</p>
</blockquote>
<ol>
<li><a href="/2020/10/10/JavaScript设计模式基础知识">JavaScript 设计模式基础知识</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-1-单例模式">JavaScript 设计模式(一)单例模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-2-策略模式">JavaScript 设计模式(二)策略模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-3-代理模式">JavaScript 设计模式(三)代理模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-4-迭代器模式">JavaScript 设计模式(四)迭代器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-5-发布订阅模式">JavaScript 设计模式(五)发布订阅模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-6-命令模式">JavaScript 设计模式(六)命令模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-7-组合模式">JavaScript 设计模式(七)组合模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-8-模板方法模式">JavaScript 设计模式(八)模板方法模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-9-享元模式">JavaScript 设计模式(九)享元模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-10-职责链模式">JavaScript 设计模式(十)职责链模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-11-中介者模式">JavaScript 设计模式(十一)中介者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-12-装饰者模式">JavaScript 设计模式(十二)装饰者模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-13-状态模式">JavaScript 设计模式(十三)状态模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式-14-适配器模式">JavaScript 设计模式(十四)适配器模式</a></li>
<li><a href="/2020/10/10/JavaScript设计模式设计原则">JavaScript 设计模式(下)设计原则</a></li>
<li><a href="https://github.com/Geek-LHJ/JavaScript-design-pattern" target="_blank" rel="noopener">JavaScript 设计模式练习代码</a></li>
</ol>
<blockquote>
<p>设计模式的一些知识：</p>
</blockquote>
<ul>
<li><strong>设计模式的定义</strong>：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案，通俗说设计模式是在某种场合下对某个问题的一种解决方案；</li>
<li><strong>学习模式的作用</strong>：模式是一些经过了大量实际项目验证的优秀解决方案，熟悉这些模式的程序员会对某些模式的理解也许形成了条件反射，当合适的场景出现时，就可以很快地找到某种模式作为解决方案；</li>
<li><strong>设计模式的适用性</strong>：所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”，一个程序的设计总是可以分为可变的部分和不变的部分，将可变的封装起来；模式应该用在正确的地方,只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道是否算正确应用；</li>
<li><strong>分辨模式的关键是意图而不是结构</strong>：有很多模式的类图和结构确实很相似，但这不太重要，辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题，例如区别代理模式和装饰者模式，策略模式和状态模式，策略模式和智能命令模式；</li>
</ul>
<h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h2><p>JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承;</p>
<h3 id="1-1-面向对象的JavaScript"><a href="#1-1-面向对象的JavaScript" class="headerlink" title="1.1 面向对象的JavaScript"></a>1.1 面向对象的JavaScript</h3><h4 id="1-1-1-动态类型语言和鸭子类型"><a href="#1-1-1-动态类型语言和鸭子类型" class="headerlink" title="1.1.1 动态类型语言和鸭子类型"></a>1.1.1 动态类型语言和鸭子类型</h4><blockquote>
<p>静态类型语言： 编译时便已确定变量的类型；</p>
</blockquote>
<p><strong>优点</strong>：编译时就能发现类型不匹配的错误，编辑器可以帮助提前避免程序在运行期间有可能发生的一些错误；</p>
<p><strong>缺点</strong>：依照强契约来编写程序，为每个变量规定数据类型，类型的声明也会增加更多的代码；</p>
<blockquote>
<p>动态类型语言：到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型；</p>
</blockquote>
<p><strong>优点</strong>：编写的代码数量更少，整体代码量越少，专注于逻辑表达；</p>
<p><strong>缺点</strong>：无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误；</p>
<blockquote>
<p>鸭子类型：只关注对象的行为，而不关注对象本身，也就是关注 <strong>HAS-A</strong>, 而不是 <strong>IS-A</strong>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> duck = &#123;</span><br><span class="line">  duckSinging: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> chicken = &#123;</span><br><span class="line">  duckSinging: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> choir = [];</span><br><span class="line"><span class="keyword">var</span> joinChoir = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( animal &amp;&amp; <span class="keyword">typeof</span> animal.duckSinging === <span class="string">'function'</span> )&#123;</span><br><span class="line">    choir.push( animal );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'恭喜加入, 已有成员数量:'</span> + choir.length );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">joinChoir( duck );</span><br><span class="line">joinChoir( chicken );</span><br></pre></td></tr></table></figure>

<p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“<strong>面向接口编程，而不是面向实现编程</strong>”；例如，一个对象若有 <strong>push</strong> 和 <strong>pop</strong> 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有 <strong>length</strong> 属性，也可以依照下标来存取属性（最好还要拥有 <strong>slice</strong> 和 <strong>splice</strong> 等方法），这个对象就可以被当作数组来使用；</p>
<h4 id="1-1-2-多态"><a href="#1-1-2-多态" class="headerlink" title="1.1.2 多态"></a>1.1.2 多态</h4><blockquote>
<p>含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。</p>
</blockquote>
<p>多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 嘎嘎嘎</span></span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 咯咯咯</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>多态最根本的作用</strong>就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"开始渲染谷歌地图"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"开始渲染百度地图"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123; map.show(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br><span class="line">renderMap( baiduMap ); <span class="comment">// 输出：开始渲染百度地图</span></span><br></pre></td></tr></table></figure>

<p>绝大部分设计模式的实现都离不开多态性的思想，例如：</p>
<ul>
<li><strong>命令模式</strong>：请求被封装在一些命令对象中，这使得命令的调用者和命令的接收者可以完全解耦开来，当调用命令的 <code>execute</code> 方法时，不同的命令会做不同的事情，从而会产生不同的执行结果。而做这些事情的过程是早已被封装在命令对象内部的，作为调用命令的客户，根本不必去关心命令执行的具体过程。</li>
<li><strong>组合模式</strong>：多态性使得客户可以完全忽略组合对象和叶节点对象之前的区别，这正是组合模式最大的作用所在。对组合对象和叶节点对象发出同一个消息的时候，它们会各自做自己应该做的事情，组合对象把消息继续转发给下面的叶节点对象，叶节点对象则会对这些消息作出真实的反馈。</li>
<li><strong>策略模式</strong>： <code>Context</code> 并没有执行算法的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算”的消息时，它们会返回各自不同的计算结果。</li>
</ul>
<p><code>JavaScript</code> 是将函数作为一等对象的语言，函数本身也是对象，函数用来封装行为并且能够被四处传递。当对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 <code>JavaScript</code> 中可以用高阶函数来代替实现的原因。</p>
<h4 id="1-1-3-封装"><a href="#1-1-3-封装" class="headerlink" title="1.1.3 封装"></a>1.1.3 封装</h4><p>封装的目的是将信息隐藏，封装包括封装数据、封装实现、封装类型和封装变化；</p>
<ol>
<li>封装数据：JavaScript 并没有提供对这些关键字的支持，只能依赖变量的作用域来实现封装特性；ECMAScript 6 中可以使用<code>let</code>和<code>Symbol</code>实现；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用函数来创建作用域</span></span><br><span class="line"><span class="keyword">var</span> myObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __name = <span class="string">'sven'</span>; <span class="comment">// 私有（ private）变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 公开（ public）方法</span></span><br><span class="line">      <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log( myObject.getName() ); <span class="comment">// 输出： sven</span></span><br><span class="line"><span class="built_in">console</span>.log( myObject.__name ) <span class="comment">// 输出： undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>封装实现细节：封装使得对象内部的变化对其他对象而言是透明的，不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能；</li>
</ol>
<blockquote>
<p>如迭代器，其作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。如编写了一个 <code>each</code> 函数，它的作用就是遍历一个聚合对象，使用这个 <code>each</code> 函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。即使 <code>each</code> 函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变；</p>
</blockquote>
<ol start="3">
<li>封装类型：是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等；</li>
</ol>
<blockquote>
<p>在 JavaScript 中，并没有对抽象类和接口的支持。 JavaScript 本身也是一门类型模糊的语言。在封装类型方面， JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。</p>
</blockquote>
<ol start="4">
<li>封装变化：封装变化是设计模式角度出发的更重要的层面体现；</li>
</ol>
<blockquote>
<p>《设计模式》一书中共归纳总结了 23种设计模式。从意图上区分， 这 23 种设计模式分别被划分为创建型模式、结构型模式和行为型模式。拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。</p>
</blockquote>
<blockquote>
<p>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。</p>
</blockquote>
<h4 id="1-1-4-原型模式和基于原型继承的JavaScript对象系统"><a href="#1-1-4-原型模式和基于原型继承的JavaScript对象系统" class="headerlink" title="1.1.4 原型模式和基于原型继承的JavaScript对象系统"></a>1.1.4 原型模式和基于原型继承的JavaScript对象系统</h4><p>JavaScript 也同样遵守这些原型编程的基本规则：</p>
<ul>
<li>所有的数据都是对象：<ul>
<li>JavaScript根对象是 <code>Object.prototype</code> 对象，可以利用 ECMAScript 5 提供的 <code>Object.getPrototypeOf</code> 来查看这两个对象的原型：<code>console.log( Object.getPrototypeOf( {} ) === Object.prototype ); // 输出： true</code></li>
</ul>
</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它：<ul>
<li>JavaScript中显式地调用 <code>var obj1 = new Object()</code>或者 <code>var obj2 = {}</code>，引擎内部会从<code>Object.prototype</code> 上面克隆一个对象出来</li>
</ul>
</li>
<li>对象会记住它的原型：<ul>
<li>JavaScript 的对象有一个名为<strong>proto</strong>的隐藏属性，该对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>{Constructor}.prototype</code>;</li>
</ul>
</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型;</li>
</ul>
<h3 id="1-2-this、-call-和-apply"><a href="#1-2-this、-call-和-apply" class="headerlink" title="1.2 this、 call 和 apply"></a>1.2 this、 call 和 apply</h3><h4 id="1-2-1-this-指向"><a href="#1-2-1-this-指向" class="headerlink" title="1.2.1 this 指向"></a>1.2.1 this 指向</h4><p>JavaScript 的 <code>this</code> 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境，即函数中的 <code>this</code> 基本都指向函数的调用者；</p>
<p>this 的指向大致可以分为以下 4 种：</p>
<ul>
<li>作为对象的方法调用：当函数作为对象的方法被调用时， this 指向该对象；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert ( <span class="keyword">this</span> === obj ); <span class="comment">// 输出： true</span></span><br><span class="line">    alert ( <span class="keyword">this</span>.a ); <span class="comment">// 输出: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure></li>
<li>作为普通函数调用：this 总是指向全局对象，在浏览器的 JavaScript 里，这个全局对象是 window 对象；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">'sven'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = myObject.getName;</span><br><span class="line"><span class="built_in">console</span>.log( getName() ); <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure></li>
<li>构造器调用：构造器里的 <code>this</code> 就指向返回的这个对象；当 <code>new</code> 调用构造器时，且构造器显式地返回了一个 <code>object</code> 类型的对象，那么最终会返回这个对象；</li>
<li><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code> 调用：动态地改变传入函数的 this；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'aaa'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'bbb'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: aaa</span></span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出： bbb</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>例子： 改写<code>document.getElementById</code>方法（注意其中的<code>this</code>指向<code>document</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span>(<span class="params"> func </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply( <span class="built_in">document</span>, <span class="built_in">arguments</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)( <span class="built_in">document</span>.getElementById );</span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="keyword">var</span> div = getId( <span class="string">'div1'</span> );</span><br><span class="line">alert (div.id); <span class="comment">// 输出： div1</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-call-和-apply"><a href="#1-2-2-call-和-apply" class="headerlink" title="1.2.2 call 和 apply"></a>1.2.2 call 和 apply</h4><blockquote>
<ol>
<li>call和apply的区别：传入参数形式的不同；</li>
</ol>
</blockquote>
<ul>
<li>apply： 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组， apply 方法把这个集合中的元素作为参数传递给被调用的函数；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</span><br><span class="line">  alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br></pre></td></tr></table></figure></li>
<li>call：call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，<br>从第二个参数开始往后，每个参数被依次传入函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</span><br><span class="line">  alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line">func.call( <span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<ol start="2">
<li>call和apply的用途：改变函数内部的 this 指向；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'aaa'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert ( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;;</span><br><span class="line">getName(); <span class="comment">// 输出: window</span></span><br><span class="line">getName.call( obj1 ); <span class="comment">// 输出: aaa</span></span><br><span class="line">getName.call( obj2 ); <span class="comment">// 输出: bbb</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li><code>Function.prototype.bind</code> 函数模拟实现如下：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"> context </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存原函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 返回一个新的函数</span></span><br><span class="line">    <span class="keyword">return</span> self.apply( context, <span class="built_in">arguments</span> ); <span class="comment">// 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert ( <span class="keyword">this</span>.name ); <span class="comment">// 输出： sven</span></span><br><span class="line">&#125;.bind( obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>通过 <code>Function.prototype.bind</code> 来“包装” func 函数，并且传入一个对象 <code>context</code> 当作参数，这个 <code>context</code> 对象就是我们想修正的 <code>this</code> 对象。在 <code>Function.prototype.bind</code> 的内部实现中，先把 <code>func</code> 函数的引用保存起来，然后返回一个新的函数。当在将来执行 <code>func</code> 函数时，实际上先执行的是这个刚刚返回的新函数。在新<br>函数内部， <code>self.apply( context, arguments )</code>这句代码才是执行原来的 <code>func</code> 函数，并且指定 context对象为 func 函数体内的 this；</p>
<p><strong><code>Function.prototype.bind</code> 函数升级版本</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></span><br><span class="line">  context = [].shift.call( <span class="built_in">arguments</span> ), <span class="comment">// 需要绑定的 this 上下文</span></span><br><span class="line">  args = [].slice.call( <span class="built_in">arguments</span> ); <span class="comment">// 剩余的参数转成数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 返回一个新的函数</span></span><br><span class="line">  <span class="keyword">return</span> self.apply( context, [].concat.call( args, [].slice.call( <span class="built_in">arguments</span> ) ) );</span><br><span class="line">  <span class="comment">// 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this</span></span><br><span class="line">  <span class="comment">// 并且组合两次分别传入的参数，作为新函数的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'aaa'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c, d </span>)</span>&#123;</span><br><span class="line">  alert ( <span class="keyword">this</span>.name ); <span class="comment">// 输出： aaa</span></span><br><span class="line">  alert ( [ a, b, c, d ] ) <span class="comment">// 输出： [ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;.bind( obj, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">func( <span class="number">3</span>, <span class="number">4</span> );</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li>借用其他对象的方法:</li>
</ol>
</blockquote>
<p>函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下常会借用 <code>Array.prototype</code> 对象上的方法。比如想往 <code>arguments</code> 中添加一个新的元素，通常会借用 <code>Array.prototype.push</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span> );</span><br><span class="line"><span class="built_in">console</span>.log ( <span class="built_in">arguments</span> ); <span class="comment">// 输出[1,2,3]</span></span><br><span class="line">&#125;)( <span class="number">1</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>在操作 arguments 的时候，我们经常非常频繁地找 <code>Array.prototype</code> 对象借用方法；</p>
<h3 id="1-3-闭包和高阶函数"><a href="#1-3-闭包和高阶函数" class="headerlink" title="1.3 闭包和高阶函数"></a>1.3 闭包和高阶函数</h3><h4 id="1-3-1-闭包的作用"><a href="#1-3-1-闭包的作用" class="headerlink" title="1.3.1 闭包的作用"></a>1.3.1 闭包的作用</h4><p>闭包的形成与变量的作用域以及变量的生存周期密切相关，因而需要了解<code>变量的作用域</code>和<code>变量的生存周期</code>；</p>
<blockquote>
<ol>
<li>封装变量：闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如：mult 函数接受 number 类型的参数，并返回这些参数的乘积，并对该函数加入缓存机制；</span></span><br><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">  <span class="keyword">if</span> ( cache[ args ] )&#123;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">    a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line">&#125;;</span><br><span class="line">alert ( mult( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ) ); <span class="comment">// 输出： 6</span></span><br><span class="line">alert ( mult( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ) ); <span class="comment">// 输出： 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用闭包避免 cache 变量和 mult 函数一起平行地暴露在全局作用域下</span></span><br><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">    <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">      a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提炼其中的乘积函数</span></span><br><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 封闭 calculate 函数</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">      a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line">    <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = calculate.apply( <span class="literal">null</span>, <span class="built_in">arguments</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>延续局部变量的寿命：避免局部变量在函数调用后销毁；</li>
</ol>
</blockquote>
<h4 id="1-3-2-高阶函数"><a href="#1-3-2-高阶函数" class="headerlink" title="1.3.2 高阶函数"></a>1.3.2 高阶函数</h4><p>满足可以作为参数被传递或可以作为返回值输出的函数称为高阶函数；</p>
<blockquote>
<ol>
<li>实例：判断数据的类型；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1. 基本实现</span></span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object String]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isArray = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object Number]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方式2：字符串作为参数，进行函数封装</span></span><br><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params"> type </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span>+ type +<span class="string">']'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isString = isType( <span class="string">'String'</span> );</span><br><span class="line"><span class="keyword">var</span> isArray = isType( <span class="string">'Array'</span> );</span><br><span class="line"><span class="keyword">var</span> isNumber = isType( <span class="string">'Number'</span> );</span><br><span class="line"><span class="built_in">console</span>.log( isArray( [ <span class="number">1</span>, <span class="number">2</span> ] ) ); <span class="comment">// 输出： true</span></span><br><span class="line"><span class="comment">// 方式3：用循环语句，来批量注册 isType 函数</span></span><br><span class="line"><span class="keyword">var</span> Type = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, type; type = [ <span class="string">'String'</span>, <span class="string">'Array'</span>, <span class="string">'Number'</span> ][ i++ ]; )&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"> type </span>)</span>&#123;</span><br><span class="line">    Type[ <span class="string">'is'</span> + type ] = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span>+ type +<span class="string">']'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)( type )</span><br><span class="line">&#125;;</span><br><span class="line">Type.isArray( [] ); <span class="comment">// 输出： true</span></span><br><span class="line">Type.isString( <span class="string">"str"</span> ); <span class="comment">// 输出： true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>实例：单例模式中既把函数当作参数传递，又让函数执行后返回了另外一个函数；</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params"> fn </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ret || ( ret = fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ) );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>高阶函数的其他应用：</li>
</ol>
</blockquote>
<ul>
<li>函数柯里化(function currying)：currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例：计算总数，只需要最后一次返回整个结果；</span></span><br><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length === <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply( <span class="keyword">this</span>, args );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      [].push.apply( args, <span class="built_in">arguments</span> );</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line">      money += <span class="built_in">arguments</span>[ i ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> cost = currying( cost ); <span class="comment">// 转化成 currying 函数</span></span><br><span class="line">cost( <span class="number">100</span> ); <span class="comment">// 未真正求值</span></span><br><span class="line">cost( <span class="number">200</span> ); <span class="comment">// 未真正求值</span></span><br><span class="line">alert ( cost() ); <span class="comment">// 求值并输出： 400</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程笔记</title>
    <url>/2019/03/10/Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，该文档是菜鸟教程上面关于Git教程方面的知识，包括了使用 Git 前的相关知识，在不同系统中安装配置 Git，Git的相关操作(基本操作、分支管理、操作远程库等知识)，具体查看文档；</p>
<a id="more"></a>

<h1 id="Git教程笔记1"><a href="#Git教程笔记1" class="headerlink" title="Git教程笔记1"></a>Git教程笔记1</h1><blockquote>
<p><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<p>文章目录：</p>
<ul>
<li><a href="#1-Git安装配置">1.Git安装配置</a></li>
<li><a href="#2-Git工作流程">2.Git工作流程</a></li>
<li><a href="#3-Git工作区、暂存区和版本库">3.Git工作区、暂存区和版本库</a></li>
<li><a href="#4-Git创建仓库">4.Git创建仓库</a></li>
<li><a href="#5-Git基本操作">5.Git基本操作</a></li>
<li><a href="#6-Git分支管理">6.Git分支管理</a></li>
<li><a href="#7-Git查看提交历史">7.Git查看提交历史</a></li>
<li><a href="#8-Git标签">8.Git标签</a></li>
<li><a href="#9-Git&Github">9.Git&amp;Github</a></li>
<li><a href="#10-GitCODING">10.GitCODING</a></li>
<li><a href="#11-Git服务器搭建(没有动手测试)">11.Git服务器搭建(没有动手测试)</a></li>
</ul>
<h2 id="1-Git安装配置"><a href="#1-Git安装配置" class="headerlink" title="1.Git安装配置"></a>1.Git安装配置</h2><h3 id="1-1-Linux-Windows-Mac-平台上安装-略"><a href="#1-1-Linux-Windows-Mac-平台上安装-略" class="headerlink" title="1.1 Linux  | Windows | Mac 平台上安装(略)"></a>1.1 Linux  | Windows | Mac 平台上安装(略)</h3><p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">http://git-scm.com/downloads</a></p>
<h3 id="1-2-Git-配置"><a href="#1-2-Git-配置" class="headerlink" title="1.2 Git 配置"></a>1.2 Git 配置</h3><p>Git 提供了一个叫做 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量，这些环境变量，决定了 Git 在各个环节的具体工作方式和行为；</p>
<p>这些环境变量存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置；若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件；</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户；若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件；</li>
<li>当前项目的 <code>Git</code> 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效；每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量；</li>
</ul>
<h4 id="1-2-1-用户信息"><a href="#1-2-1-用户信息" class="headerlink" title="1.2.1 用户信息"></a>1.2.1 用户信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置个人的用户名称和电子邮件地址</span></span><br><span class="line">$ git config --global user.name <span class="string">"runoob"</span></span><br><span class="line">$ git config --global user.email <span class="built_in">test</span>@runoob.com</span><br></pre></td></tr></table></figure>

<p>如果用了 <code>--global</code> 选项，那么更改的配置文件就是位于你<code>用户主目录</code>下的那个，以后你所有的项目都会默认使用这里配置的用户信息；<br>如果要在<code>某个特定的项目中</code>使用其他名字或者电邮，只要去掉 <code>--global</code> 选项重新配置即可，新的设定保存在当前项目的 <code>.git/config</code> 文件里；</p>
<p><strong>在项目中遇到了这样的问题，只要切换了不同项目（用户名称和电子邮件不同），就需要配置 SSH 秘钥才能成功上传代码，解决该问题方式就是对特定的项目中使用其他名字或者电邮，不加 –global 选项</strong></p>
<h4 id="1-2-2-文本编辑器"><a href="#1-2-2-文本编辑器" class="headerlink" title="1.2.2 文本编辑器"></a>1.2.2 文本编辑器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Git默认使用的文本编辑器是 `Vi` 或者 `Vim`，如配置 Emacs 文本编辑器</span></span><br><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-差异分析工具"><a href="#1-2-3-差异分析工具" class="headerlink" title="1.2.3 差异分析工具"></a>1.2.3 差异分析工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff</span></span><br><span class="line">$ git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure>
<p>Git 可以理解 <code>kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff</code> 等合并工具的输出信息；当然你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章；</p>
<h4 id="1-2-4-查看配置信息"><a href="#1-2-4-查看配置信息" class="headerlink" title="1.2.4 查看配置信息"></a>1.2.4 查看配置信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要检查已有的配置信息，使用 git config --list 命令；若看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig）</span></span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment"># 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可</span></span><br><span class="line">$ git config user.name</span><br></pre></td></tr></table></figure>

<h2 id="2-Git工作流程"><a href="#2-Git工作流程" class="headerlink" title="2.Git工作流程"></a>2.Git工作流程</h2><p> <code>Git</code> 的一般工作流程如下：</p>
<ol>
<li>克隆 <code>Git</code> 资源作为工作目录；</li>
<li>在克隆的资源上添加或修改文件；</li>
<li>如果其他人修改了，你可以更新资源；</li>
<li>在提交前查看修改；</li>
<li>提交修改；</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交；</li>
</ol>
<p><img src="/2019/03/10/Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/1.png" alt="Git工作流程图"></p>
<h2 id="3-Git工作区、暂存区和版本库"><a href="#3-Git工作区、暂存区和版本库" class="headerlink" title="3.Git工作区、暂存区和版本库"></a>3.Git工作区、暂存区和版本库</h2><h3 id="3-1-三者的基本概念"><a href="#3-1-三者的基本概念" class="headerlink" title="3.1 三者的基本概念"></a>3.1 三者的基本概念</h3><ul>
<li><strong>工作区</strong>：就是你在电脑里能看到的目录；</li>
<li><strong>暂存区</strong>：英文叫 <code>stage或index</code> ；一般存放在 “<code>.git目录下</code>“ 下的<code>index</code>文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）；</li>
<li><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code> ，这个不算工作区，而是Git的版本库；</li>
</ul>
<h3 id="3-2-三者之间的关系"><a href="#3-2-三者之间的关系" class="headerlink" title="3.2 三者之间的关系"></a>3.2 三者之间的关系</h3><p><img src="/2019/03/10/Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png" alt="工作区暂存区版本库的关系图"></p>
<p>图中左侧为<code>工作区</code>，右侧为<code>版本库</code>。在版本库中标记为 “<code>index</code>“ 的区域是<code>暂存区</code>（<code>stage, index</code>），标记为 “master” 的是 master 分支所代表的目录树；图中我们可以看出此时 “<code>HEAD</code>“ 实际是指向 <code>master</code> 分支的一个”游标”；所以图示的命令中出现 <code>HEAD</code> 的地方可以用 <code>master</code> 来替换；图中的 <code>objects</code> 标识的区域为 Git 的对象库，实际位于 “<code>.git/objects</code>“ 目录下，里面包含了创建的各种对象及内容。</p>
<h2 id="4-Git创建仓库"><a href="#4-Git创建仓库" class="headerlink" title="4.Git创建仓库"></a>4.Git创建仓库</h2><h3 id="4-1-git-init"><a href="#4-1-git-init" class="headerlink" title="4.1 git init"></a>4.1 git init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用当前目录作为Git仓库，我们只需使它初始化，命令执行完后会在当前目录生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 指定目录作为Git仓库</span></span><br><span class="line">git init newrepo</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下命令将目录下以 .c 结尾及 README 文件提交到仓库中</span></span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">'初始化项目版本'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-git-clone"><a href="#4-2-git-clone" class="headerlink" title="4.2 git clone"></a>4.2 git clone</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从现有 Git 仓库中拷贝项目，repo:Git 仓库；directory:本地目录。</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br><span class="line"><span class="comment"># 如果需要克隆到指定的目录，可以使用以下命令格式</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-Git基本操作"><a href="#5-Git基本操作" class="headerlink" title="5.Git基本操作"></a>5.Git基本操作</h2><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比；</p>
<h3 id="5-1-获取与创建项目命令"><a href="#5-1-获取与创建项目命令" class="headerlink" title="5.1 获取与创建项目命令"></a>5.1 获取与创建项目命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 git init 在目录中创建新的 Git 仓库</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment"># 用 git clone 拷贝一个 Git 仓库到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url] [dirName]</span><br></pre></td></tr></table></figure>

<h3 id="5-2-基本快照"><a href="#5-2-基本快照" class="headerlink" title="5.2 基本快照"></a>5.2 基本快照</h3><h4 id="5-1-1-git-add"><a href="#5-1-1-git-add" class="headerlink" title="5.1.1 git add"></a>5.1.1 git add</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git add 命令可将该文件添加到缓存, *或. 表示添加所有新增文件，也可以是具体的文件</span></span><br><span class="line">$ git add *</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-git-status"><a href="#5-1-2-git-status" class="headerlink" title="5.1.2 git status"></a>5.1.2 git status</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git status 命令用于查看项目的当前状态，查看在上次提交之后是否有修改，-s 表示以简短的结果输出</span></span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-git-diff"><a href="#5-1-3-git-diff" class="headerlink" title="5.1.3 git diff"></a>5.1.3 git diff</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看执行 git status 的结果的详细信息，显示已写入缓存与已修改但尚未写入缓存的改动的区别</span></span><br><span class="line">$ git diff <span class="comment"># 尚未缓存的改动</span></span><br><span class="line">$ git diff --cached <span class="comment"># 查看已缓存的改动</span></span><br><span class="line">$ git diff HEAD <span class="comment"># 查看已缓存的与未缓存的所有改动</span></span><br><span class="line">$ git diff --<span class="built_in">stat</span> <span class="comment"># 显示摘要而非整个 diff</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-git-commit"><a href="#5-1-4-git-commit" class="headerlink" title="5.1.4 git commit"></a>5.1.4 git commit</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址，注意 --global 参数的使用</span></span><br><span class="line">$ git config --global user.name <span class="string">'runoob'</span></span><br><span class="line">$ git config --global user.email <span class="built_in">test</span>@runoob.com</span><br><span class="line"><span class="comment"># 使用 git add 命令将想要快照的内容写入缓存区</span></span><br><span class="line">$ git add .</span><br><span class="line"><span class="comment"># 执行 git commit 将缓存区内容添加到仓库中，使用 -m 选项以在命令行中提供提交注释</span></span><br><span class="line">$ git commit -m <span class="string">'提交的注释信息'</span></span><br><span class="line"><span class="comment"># 若觉得 git add 提交缓存的流程繁琐，Git 也允许你用 -a 选项跳过这一步</span></span><br><span class="line">git commit -am <span class="string">'提交的注释信息（此前不需要 git add ）'</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-5-git-reset-HEAD"><a href="#5-1-5-git-reset-HEAD" class="headerlink" title="5.1.5 git reset HEAD"></a>5.1.5 git reset HEAD</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消已缓存的文件内容；执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</span></span><br><span class="line">$ git reset HEAD [fileName]</span><br></pre></td></tr></table></figure>

<h4 id="5-1-6-git-rm"><a href="#5-1-6-git-rm" class="headerlink" title="5.1.6 git rm"></a>5.1.6 git rm</h4><p>若只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 <code>Changes not staged for commit</code> 的提示；要从 <code>Git</code> 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除工作区目录文件，从已跟踪文件清单中移除</span></span><br><span class="line">$ git rm &lt;file&gt;</span><br><span class="line"><span class="comment"># 若删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line">$ git rm -f &lt;file&gt;</span><br><span class="line"><span class="comment"># 若把文件从暂存区域移除，但仍然希望保留在当前工作目录中；换句话说，仅是从跟踪清单中删除，使用 --cached 选项</span></span><br><span class="line">$ git rm --cached &lt;file&gt;</span><br><span class="line"><span class="comment"># 递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件</span></span><br><span class="line">$ git rm –r *</span><br></pre></td></tr></table></figure>

<h4 id="5-1-7-git-mv"><a href="#5-1-7-git-mv" class="headerlink" title="5.1.7 git mv"></a>5.1.7 git mv</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git mv 命令用于移动或重命名一个文件、目录、软连接</span></span><br><span class="line">$ git mv [filename1]  [filename2]</span><br></pre></td></tr></table></figure>

<h2 id="6-Git分支管理"><a href="#6-Git分支管理" class="headerlink" title="6.Git分支管理"></a>6.Git分支管理</h2><ul>
<li>创建分支命令：<code>git branch (branchname)</code>；</li>
<li>切换分支命令：<code>git checkout (branchname)</code>；</li>
<li>合并分支命令：<code>git merge</code>；</li>
</ul>
<h3 id="6-1-列出、新建、切换分支"><a href="#6-1-列出、新建、切换分支" class="headerlink" title="6.1 列出、新建、切换分支"></a>6.1 列出、新建、切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出分支基本命令,不要加参数</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 加上参数就是表示创建一个分支，分支名就是参数值</span></span><br><span class="line">$ git branch (branchname)</span><br><span class="line"><span class="comment"># 切换到某一分支下</span></span><br><span class="line">$ git checkout (branch)</span><br><span class="line"><span class="comment"># 创建新分支并立即切换到该分支下</span></span><br><span class="line">$ git checkout -b (branchname)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-删除分支"><a href="#6-2-删除分支" class="headerlink" title="6.2 删除分支"></a>6.2 删除分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除分支命令</span></span><br><span class="line">$ git branch -d (branchname)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-分支合并"><a href="#6-3-分支合并" class="headerlink" title="6.3 分支合并"></a>6.3 分支合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用以下命令将任何分支合并到当前分支中去</span></span><br><span class="line">$ git merge (branchname)</span><br></pre></td></tr></table></figure>

<h3 id="6-4-合并冲突"><a href="#6-4-合并冲突" class="headerlink" title="6.4 合并冲突"></a>6.4 合并冲突</h3><p>在 Git 中，若合并冲突出现了，我们需要手动去修改它，在修改完成后，我们可以用 <code>git add</code> 要告诉 <code>Git</code> 文件冲突已经解决，然后再使用 <code>git commit</code> 提交结果；</p>
<h2 id="7-Git查看提交历史"><a href="#7-Git查看提交历史" class="headerlink" title="7. Git查看提交历史"></a>7. Git查看提交历史</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 git log 命令列出历史提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 可以用 --oneline 选项来查看历史记录的简洁的版本</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line"><span class="comment"># 还可以用 --graph 选项，查看历史中什么时候出现了分支、合并，开启了拓扑图选项</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line"><span class="comment"># 也可以用 --reverse 参数来逆向显示所有日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --reverse --oneline</span><br><span class="line"><span class="comment"># 只想查找指定用户的提交日志可以使用命令：git log --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分</span></span><br><span class="line">$ git <span class="built_in">log</span> --author=Linus --oneline -5</span><br><span class="line"><span class="comment"># 如果要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after ; 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（还用了 --no-merges 选项以隐藏合并提交）</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br></pre></td></tr></table></figure>

<h2 id="8-Git标签"><a href="#8-Git标签" class="headerlink" title="8.Git标签"></a>8.Git标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果项目达到一个重要的阶段，并希望永远记住那个特别的提交快照，使用 `git tag` 给它打上标签; -a 选项意为"创建一个带注解的标签"; -m 选项为添加的标签注释内容</span></span><br><span class="line">$ git tag -a v1.0</span><br><span class="line"><span class="comment"># 查看项目中的标签</span></span><br><span class="line">$ git <span class="built_in">log</span> --decorate</span><br><span class="line"><span class="comment"># 若忘了给某个提交打标签，又将它发布了，我们可以给它追加标签, 85fc7e7 为那次修改发布的哈希值</span></span><br><span class="line">$ git tag -a v0.9 85fc7e7</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph</span><br><span class="line"><span class="comment"># 指定标签信息命令</span></span><br><span class="line">$ git tag -a &lt;tagname&gt; -m <span class="string">"标签注释内容"</span></span><br><span class="line"><span class="comment"># PGP签名标签命令：</span></span><br><span class="line">$ git tag -s &lt;tagname&gt; -m <span class="string">"标签注释内容"</span></span><br></pre></td></tr></table></figure>

<h2 id="9-Git-amp-Github"><a href="#9-Git-amp-Github" class="headerlink" title="9.Git&amp;Github"></a>9.Git&amp;Github</h2><h3 id="9-1-添加远程库"><a href="#9-1-添加远程库" class="headerlink" title="9.1 添加远程库"></a>9.1 添加远程库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>

<p>配置 <code>SSH</code> 秘钥连接 <code>GitHub</code> 远程库步骤：</p>
<ol>
<li>执行以下命令生成 <code>SSH Key</code>：<code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>；其中邮件名称是你在 <code>Github</code> 上注册的邮箱；</li>
<li>接着会要求确认路径和输入密码，这使用默认的一路回车就行，会在<code>~/</code> 目录下生成 <code>.ssh</code> 文件夹，如<code>C:\Users\&lt;username&gt;\.ssh</code>，进去打开 <code>id_rsa.pub</code>，复制里面的 <code>key</code> ；</li>
<li>回到 <code>github</code> 上，进入 <code>Account =&gt; Settings</code>（账户配置），新增 <code>SSH key</code>；</li>
<li>为了验证是否成功，输入以下命令：<code>$ ssh -T git@github.com</code>；</li>
</ol>
<h3 id="9-2-查看当前的远程库"><a href="#9-2-查看当前的远程库" class="headerlink" title="9.2 查看当前的远程库"></a>9.2 查看当前的远程库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要查看当前配置有哪些远程仓库，可以用命令</span></span><br><span class="line">$ git remote</span><br><span class="line"><span class="comment"># 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址</span></span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>

<h3 id="9-3-提取远程仓库"><a href="#9-3-提取远程仓库" class="headerlink" title="9.3 提取远程仓库"></a>9.3 提取远程仓库</h3><p>Git 有两个命令用来提取远程仓库的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 从远程仓库下载新分支与数据，该命令执行完后需要执行git merge 远程分支到你所在的分支</span></span><br><span class="line">$ git fetch</span><br><span class="line"><span class="comment"># 2. 从远端仓库提取数据并尝试合并到当前分支，该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支</span></span><br><span class="line">$ git merge</span><br></pre></td></tr></table></figure>

<p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <code>git fetch [alias]</code> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <code>git merge [alias]/[branch]</code> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支；</p>
<h4 id="9-3-1-推送到远程仓库"><a href="#9-3-1-推送到远程仓库" class="headerlink" title="9.3.1 推送到远程仓库"></a>9.3.1 推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送你的新分支与数据到某个远端仓库命令,该命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支</span></span><br><span class="line">$ git push [<span class="built_in">alias</span>] [branch]</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-删除远程仓库"><a href="#9-3-2-删除远程仓库" class="headerlink" title="9.3.2 删除远程仓库"></a>9.3.2 删除远程仓库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除远程仓库你可以使用命令：</span></span><br><span class="line">$ git remote rm [<span class="built_in">alias</span>]</span><br><span class="line"><span class="comment"># 例如：在原有的远程仓库上新增一个，然后再删除</span></span><br><span class="line"><span class="comment"># 1. 先查看当前配置有哪些远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 2. 添加仓库 origin2，再查看远程仓库</span></span><br><span class="line">$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 删除仓库 origin2，再查看远程仓库</span></span><br><span class="line">$ git remote rm origin2</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="10-GitCODING"><a href="#10-GitCODING" class="headerlink" title="10.GitCODING"></a>10.GitCODING</h2><p>由于 GitHub 的访问速度太慢，常还会出现丢包、失去连接等情况；因而使用国内服务器的托管平台 <code>CODING</code>；</p>
<p>将 <code>GitHub</code> 上的代码迁移到 <code>CODING</code> 的步骤：</p>
<ol>
<li>创建 CODING 项目；</li>
<li>将 GitHub 代码 Pull 到本地；</li>
<li>本地关联 CODING 仓库，Push 代码到 CODING；<ul>
<li>首先执行命令查看当前配置的远程仓库：<code>git remote -v</code>;</li>
<li>接下来执行以下命令，来关联 <code>CODING</code> 远程仓库，要先删除现有的仓库关联，在将仓库关联到 <code>CODING</code> 的地址，并且将代码 <code>Push</code> 到 <code>master</code> 分支：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br><span class="line">$ git remote add origin https://git.coding.net/xxx/xxx.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>

<p><code>CODING</code> 仓库的免密码 <code>Push/Pull</code>：配置<code>SSH Key</code>；</p>
<h2 id="11-Git服务器搭建-没有动手测试"><a href="#11-Git服务器搭建-没有动手测试" class="headerlink" title="11.Git服务器搭建(没有动手测试)"></a>11.Git服务器搭建(没有动手测试)</h2><p><code>Github</code> 公开的项目是免费的，但是如果你不想让其他人看到你的项目就需要收费，因而我们就需要自己搭建一台Git服务器作为私有仓库使用；接下来我们将以 <code>Centos</code> 为例搭建 <code>Git</code> 服务器：</p>
<h3 id="11-1-安装Git"><a href="#11-1-安装Git" class="headerlink" title="11.1 安装Git"></a>11.1 安装Git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br><span class="line"><span class="comment"># 接下来我们 创建一个git用户组和用户，用来运行git服务</span></span><br><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git</span><br></pre></td></tr></table></figure>

<h3 id="11-2-创建证书登录"><a href="#11-2-创建证书登录" class="headerlink" title="11.2 创建证书登录"></a>11.2 创建证书登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个，若没有就创建它；</span></span><br><span class="line">$ <span class="built_in">cd</span> /home/git/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ chmod 755 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br><span class="line">$ chmod 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="11-3-初始化Git仓库"><a href="#11-3-初始化Git仓库" class="headerlink" title="11.3 初始化Git仓库"></a>11.3 初始化Git仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令</span></span><br><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ mkdir gitrepo</span><br><span class="line">$ chown git:git gitrepo/</span><br><span class="line">$ <span class="built_in">cd</span> gitrepo</span><br><span class="line"></span><br><span class="line">$ git init --bare runoob.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/runoob.git/</span><br><span class="line"><span class="comment"># 以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git</span></span><br><span class="line">$ chown -R git:git runoob.git</span><br></pre></td></tr></table></figure>

<h3 id="11-4-克隆仓库"><a href="#11-4-克隆仓库" class="headerlink" title="11.4 克隆仓库"></a>11.4 克隆仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.45.4 为 Git 所在服务器 ip ，需要将其修改为你自己的 Git 服务 ip;</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@192.168.45.4:/home/gitrepo/runoob.git</span><br></pre></td></tr></table></figure>

<p>这样我们的 Git 服务器安装就完成；</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>官方文档</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git操作文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex官方文档学习笔记</title>
    <url>/2019/03/06/Vuex%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>在 Vue 的学习中，Vuex 是一个专为 Vue 开发的应用程序的状态管理模式，当我们构建一个中大型的单页面应用程序时，Vuex可以更好的帮助我们在组件外部统一管理状态，Vuex具体使用方法查看文档笔记；</p>
<a id="more"></a>

<h1 id="Vuex官方文档学习笔记"><a href="#Vuex官方文档学习笔记" class="headerlink" title="Vuex官方文档学习笔记"></a>Vuex官方文档学习笔记</h1><blockquote>
<p>学习链接：<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex官方文档</a></p>
</blockquote>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ol>
<li>在一个模块化的打包系统中，先下载 <code>vuex</code> 第三方模块，再显式地通过 <code>Vue.use()</code> 来安装 <code>Vuex</code> ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Vuex-是什么？"><a href="#1-1-Vuex-是什么？" class="headerlink" title="1.1 Vuex 是什么？"></a>1.1 Vuex 是什么？</h3><p><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的<strong>状态管理模式</strong>；状态管理模式介绍如下：</p>
<ol>
<li>状态自管理应用包含以下几个部分：<ul>
<li><code>state</code>：驱动应用的数据源；</li>
<li><code>view</code>：以声明方式将 <code>state</code> 映射到视图；</li>
<li><code>actions</code>：响应在 <code>view</code> 上的用户输入导致的状态变化；</li>
</ul>
</li>
<li><code>Vuex</code> 的基本思想是把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为；另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护；</li>
<li><code>Vuex</code> 是专门为 <code>Vue.js</code> 设计的状态管理库，以利用 <code>Vue.js</code> 的细粒度数据响应机制来进行高效的状态更新；</li>
</ol>
<p><img src="/2019/03/06/Vuex%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="图片"></p>
<h3 id="1-2-开始"><a href="#1-2-开始" class="headerlink" title="1.2 开始"></a>1.2 开始</h3><p>每一个 <code>Vuex</code> 应用的核心就是 <code>store</code> （仓库）,它包含着你的应用中大部分的状态  <code>state</code> ;</p>
<p>Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的；当 Vue 组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新；</li>
<li>不能直接改变 <code>store</code> 中的状态；改变 <code>store</code> 中的状态的唯一途径就是显式地 提交 (commit) <code>mutation</code> ，而非直接改变 <code>store.state.count</code>；这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用，代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 store，提供一个初始 state 对象和一些 mutation</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：</span></span><br><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. 核心概念</h2><h3 id="2-1-State"><a href="#2-1-State" class="headerlink" title="2.1 State"></a>2.1 State</h3><h4 id="2-1-1-单一状态树"><a href="#2-1-1-单一状态树" class="headerlink" title="2.1.1 单一状态树"></a>2.1.1 单一状态树</h4><p><code>Vuex</code> 使用<strong>单一状态树</strong>——用一个对象就包含了全部的应用层级状态；每个应用将仅仅包含一个 <code>store</code> 实例；单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<h4 id="2-1-2-在-Vue-组件中获得-Vuex-状态"><a href="#2-1-2-在-Vue-组件中获得-Vuex-状态" class="headerlink" title="2.1.2 在 Vue 组件中获得 Vuex 状态"></a>2.1.2 在 Vue 组件中获得 Vuex 状态</h4><p><code>Vuex</code> 的状态存储是响应式的，从 <code>store</code> 实例中读取状态最简单的方法就是在<strong>计算属性</strong>中返回某个状态，如代码中每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种模式导致组件依赖全局状态单例，解决办法如下</span></span><br></pre></td></tr></table></figure>

<p><code>Vuex</code> 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>），通过在根实例中注册 <code>store</code> 选项，该 <code>store</code> 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到，更新下 <code>Counter</code> 的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在根实例 app.vue 中进行注册 store选项；</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 子组件访 Counter 问该数据</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-mapState-辅助函数"><a href="#2-1-3-mapState-辅助函数" class="headerlink" title="2.1.3 mapState 辅助函数"></a>2.1.3 mapState 辅助函数</h4><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-对象展开运算符"><a href="#2-1-4-对象展开运算符" class="headerlink" title="2.1.4 对象展开运算符"></a>2.1.4 对象展开运算符</h4><p><code>mapState</code> 函数返回的是一个对象；我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-组件仍然保有局部状态"><a href="#2-1-5-组件仍然保有局部状态" class="headerlink" title="2.1.5 组件仍然保有局部状态"></a>2.1.5 组件仍然保有局部状态</h4><p>使用 <code>Vuex</code> 并不意味着你需要将所有的状态放入 <code>Vuex</code> ；如果有些状态严格属于单个组件，最好还是作为组件的局部状态；你应该根据你的应用开发需要进行权衡和确定。</p>
<h3 id="2-2-Getter"><a href="#2-2-Getter" class="headerlink" title="2.2 Getter"></a>2.2 Getter</h3><h4 id="2-2-1-从-store-中的-state-中派生出一些状态"><a href="#2-2-1-从-store-中的-state-中派生出一些状态" class="headerlink" title="2.2.1 从 store 中的 state 中派生出一些状态"></a>2.2.1 从 store 中的 state 中派生出一些状态</h4><p>例如：对列表进行数据过滤并计算个数，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤函数获取todo.done 为true的值</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Vuex</code> 允许我们在 <code>store</code> 中定义“<code>getter</code>”（可以认为是 <code>store</code> 的计算属性）；就像计算属性一样， <code>getter</code> 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算， <code>Getter</code> 接受 <code>state</code> 作为其第一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-通过属性访问"><a href="#2-2-2-通过属性访问" class="headerlink" title="2.2.2 通过属性访问"></a>2.2.2 通过属性访问</h4><p><code>Getter</code> 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 也可以接受其他 getter 作为第二个参数</span></span><br><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以很容易地在任何组件中使用它</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： <code>getter</code> 在通过属性访问时是作为 <code>Vue</code> 的响应式系统的一部分缓存其中的。</p>
<h4 id="2-2-3-通过方法访问"><a href="#2-2-3-通过方法访问" class="headerlink" title="2.2.3 通过方法访问"></a>2.2.3 通过方法访问</h4><p>还可以通过让 <code>getter</code> 返回一个函数，来实现给 <code>getter</code> 传参；在你对 <code>store</code> 里的数组进行查询时非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id: 2, text: '...', done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>注意： <code>getter</code> 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>
<h4 id="2-2-4-mapGetters-辅助函数"><a href="#2-2-4-mapGetters-辅助函数" class="headerlink" title="2.2.4 mapGetters 辅助函数"></a>2.2.4 mapGetters 辅助函数</h4><p><code>mapGetters</code> 辅助函数仅仅是将 <code>store</code> 中的 <code>getter</code> 映射到局部计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想将一个 <code>getter</code> 属性另取一个名字，要使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Mutation"><a href="#2-3-Mutation" class="headerlink" title="2.3 Mutation"></a>2.3 Mutation</h3><h4 id="2-3-1-修改-store-中的状态"><a href="#2-3-1-修改-store-中的状态" class="headerlink" title="2.3.1 修改 store 中的状态"></a>2.3.1 修改 store 中的状态</h4><p>更改 <code>Vuex</code> 的 <code>store</code> 中的状态的唯一方法是提交 <code>mutation</code> ；每个 <code>mutation</code> 都有一个字符串的 <code>事件类型 (type)</code> 和 一个 <code>回调函数 (handler)</code>；这个回调函数就是我们实际进行状态更改的地方，并且它会接受 <code>state</code> 作为第一个参数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要调用此 <code>mutation handler</code>，需要以相应的 <code>type</code> 调用 <code>store.commit</code> 方法：<br><code>store.commit(&#39;increment&#39;)</code></p>
<h4 id="2-3-2-提交载荷（Payload）——额外参数"><a href="#2-3-2-提交载荷（Payload）——额外参数" class="headerlink" title="2.3.2 提交载荷（Payload）——额外参数"></a>2.3.2 提交载荷（Payload）——额外参数</h4><p>可以向 <code>store.commit</code> 传入额外的参数，即 <code>mutation</code> 的 载荷（payload），例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>载荷还可以是一个对象，这样可以包含多个字段并且记录的 <code>mutation</code> 会更易读；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-对象风格的提交方式"><a href="#2-3-3-对象风格的提交方式" class="headerlink" title="2.3.3 对象风格的提交方式"></a>2.3.3 对象风格的提交方式</h4><p>提交 <code>mutation</code> 的另一种方式是直接使用包含 <code>type</code> 属性的对象，使用对象风格的提交方式，整个对象都作为载荷传给 <code>mutation</code> 函数，因此 <code>handler</code> 保持不变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义在store中的函数</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用mutation handler</span></span><br><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-Mutation-需遵守-Vue-的响应规则"><a href="#2-3-4-Mutation-需遵守-Vue-的响应规则" class="headerlink" title="2.3.4 Mutation 需遵守 Vue 的响应规则"></a>2.3.4 Mutation 需遵守 Vue 的响应规则</h4><ol>
<li>最好提前在你的 <code>store</code> 中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，你应该使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者 <code>以新对象替换老对象</code>；例如：<code>state.obj = { ...state.obj, newProp: 123 }</code></li>
</ol>
<h4 id="2-3-5-使用常量替代-Mutation-事件类型"><a href="#2-3-5-使用常量替代-Mutation-事件类型" class="headerlink" title="2.3.5 使用常量替代 Mutation 事件类型"></a>2.3.5 使用常量替代 Mutation 事件类型</h4><p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code> 实现中是很常见的模式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-Mutation-必须是同步函数-重要原则"><a href="#2-3-6-Mutation-必须是同步函数-重要原则" class="headerlink" title="2.3.6 Mutation 必须是同步函数(重要原则)"></a>2.3.6 Mutation 必须是同步函数(重要原则)</h4><p>参考下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-7-在组件中提交-Mutation"><a href="#2-3-7-在组件中提交-Mutation" class="headerlink" title="2.3.7 在组件中提交 Mutation"></a>2.3.7 在组件中提交 Mutation</h4><p>可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 <code>mutation</code> ，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code> ）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-8-Vuex-中-mutation-都是同步事务"><a href="#2-3-8-Vuex-中-mutation-都是同步事务" class="headerlink" title="2.3.8 Vuex 中 mutation 都是同步事务"></a>2.3.8 Vuex 中 <code>mutation</code> 都是同步事务</h4><p>在 <code>mutation</code> 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 <code>mutation</code> 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念，为了处理异步操作，来看一看 <code>Action</code>的功能；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="comment">// 任何由 "increment" 导致的状态变更都应该在此刻完成。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Action"><a href="#2-4-Action" class="headerlink" title="2.4 Action"></a>2.4 Action</h3><p><code>Action</code> 类似于 <code>mutation</code> ，不同在于：</p>
<ol>
<li>Action 提交的是 <code>mutation</code> ，而不是直接变更状态；</li>
<li>Action 可以包含任意异步操作；</li>
</ol>
<p><code>Action</code> 函数接受一个与 <code>store</code> 实例具有相同方法和属性的 <code>context</code> 对象；因此你可以调用 <code>context.commit</code>提交一个 <code>mutation</code> ，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>；</p>
<p>注册一个简单的 <code>action</code> 例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-分发-Action"><a href="#2-4-1-分发-Action" class="headerlink" title="2.4.1 分发 Action"></a>2.4.1 分发 Action</h4><p><code>Action</code> 通过 <code>store.dispatch</code> 方法触发:  <code>store.dispatch(&#39;increment&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Action 还可以在 action 内部执行异步操作（区别于mutation 必须同步执行）：</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actions 支持同样的载荷方式和对象方式进行分发：</span></span><br><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>购物车示例，涉及到<code>调用异步 API</code> 和<code>分发多重 mutation</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-在组件中分发-Action"><a href="#2-4-2-在组件中分发-Action" class="headerlink" title="2.4.2 在组件中分发 Action"></a>2.4.2 在组件中分发 Action</h4><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 <code>action</code> ，或者使用 <code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code> ）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-组合-Action"><a href="#2-4-3-组合-Action" class="headerlink" title="2.4.3 组合 Action"></a>2.4.3 组合 Action</h4><p><code>Action</code> 通常是异步的，那么如何知道 <code>action</code> 什么时候结束呢？首先要明白 <code>store.dispatch</code> 可以处理被触发的 <code>action</code> 的处理函数返回的 <code>Promise</code> ，并且 <code>store.dispatch</code> 仍旧返回 <code>Promise</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用，使用 promise 语法</span></span><br><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另外一个 action 中也可以如下：</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若利用 async / await，我们可以如下组合 action：</span></span><br><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 <code>action</code> 函数；在这种情况下，只有当所有触发函数完成后，返回的 <code>Promise</code> 才会执行；</p>
<h3 id="2-5-Module"><a href="#2-5-Module" class="headerlink" title="2.5 Module"></a>2.5 Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时， <code>store</code> 对象就有可能变得相当臃肿；为了解决以上问题， <code>Vuex</code> 允许我们将 <code>store</code> 分割成模块（ <code>module</code> ），每个模块拥有自己的 <code>state; mutation; action; getter; 嵌套子模块</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-模块的局部状态"><a href="#2-5-1-模块的局部状态" class="headerlink" title="2.5.1 模块的局部状态"></a>2.5.1 模块的局部状态</h4><p>对于模块内部的 <code>mutation</code> 和 <code>getter</code> ，接收的第一个参数是<strong>模块的局部状态对象</strong>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于模块内部的 <code>action</code> ，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于模块内部的 <code>getter</code> ，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-命名空间"><a href="#2-5-2-命名空间" class="headerlink" title="2.5.2 命名空间"></a>2.5.2 命名空间</h4><p>默认情况下，模块内部的 <code>action、mutation 和 getter</code> 是注册在全局命名空间的——这样使得多个模块能够对同一 <code>mutation</code> 或 <code>action</code> 作出响应；</p>
<p>若希望模块具有更高的封装度和复用性，可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块；当模块被注册后，它的所有 <code>getter; action; mutation</code> 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-模块动态注册"><a href="#2-5-3-模块动态注册" class="headerlink" title="2.5.3 模块动态注册"></a>2.5.3 模块动态注册</h4><p>使用 <code>store.registerModule</code> 方法注册模块，注册后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-模块重用"><a href="#2-5-4-模块重用" class="headerlink" title="2.5.4 模块重用"></a>2.5.4 模块重用</h4><p>有时需要创建一个模块的多个实例，如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 <code>store</code> 或模块间数据互相污染的问题；实际上这和 <code>Vue</code> 组件内的 <code>data</code> 是同样的问题：解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="comment">// 使用函数返回数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h2><p>规定了一些需要遵守的规则：</p>
<ol>
<li>应用层级的状态应该集中到单个 <code>store</code> 对象中；</li>
<li>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的；</li>
<li>异步逻辑都应该封装到 action 里面；</li>
</ol>
<p>下面是项目结构示例：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure>

<h2 id="4-未-插件"><a href="#4-未-插件" class="headerlink" title="4. (未)插件"></a>4. (未)插件</h2><h2 id="5-严格模式"><a href="#5-严格模式" class="headerlink" title="5. 严格模式"></a>5. 严格模式</h2><p>开启严格模式，仅需在创建 <code>store</code> 的时候传入 <code>strict: true</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  strict: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在严格模式下，无论何时发生了状态变更且不是由 <code>mutation</code> 函数引起的，将会抛出错误；这能保证所有的状态变更都能被调试工具跟踪到；</p>
<h3 id="5-1-开发环境与发布环境"><a href="#5-1-开发环境与发布环境" class="headerlink" title="5.1 开发环境与发布环境"></a>5.1 开发环境与发布环境</h3><p><strong>不要在发布环境下启用严格模式</strong> 严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失，处理如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  strict: process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-表单处理"><a href="#6-表单处理" class="headerlink" title="6. 表单处理"></a>6. 表单处理</h2><p>当在严格模式中使用 <code>Vuex</code> 时，在属于 <code>Vuex</code> 的 <code>state</code> 上使用 <code>v-model</code> 会比较棘手：<code>&lt;input v-model=&quot;obj.message&quot;&gt;</code>；用“Vuex 的思维”去解决这个问题的方法是：给 <code>&lt;input&gt;</code> 中绑定 <code>value</code> ，然后侦听 <code>input</code> 或者 <code>change</code> 事件，在事件回调中调用 <code>action</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    message: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是 mutation 函数：</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateMessage (state, message) &#123;</span><br><span class="line">    state.obj.message = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-双向绑定的计算属性"><a href="#6-1-双向绑定的计算属性" class="headerlink" title="6.1 双向绑定的计算属性"></a>6.1 双向绑定的计算属性</h3><p>使用带有 <code>setter</code> 的双向绑定计算属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-未-测试"><a href="#7-未-测试" class="headerlink" title="7. (未)测试"></a>7. (未)测试</h2><h2 id="8-未-热重载"><a href="#8-未-热重载" class="headerlink" title="8. (未)热重载"></a>8. (未)热重载</h2>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vuex</category>
        <category>官方文档</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
        <tag>状态管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouterAPI官方参考文档笔记</title>
    <url>/2019/03/05/VueRouterAPI%E5%AE%98%E6%96%B9%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>在 Vue 的学习中，VueRouter 是 Vue.js 官方的路由管理器，该文档是对 VueRouter 官方API文档的知识的学习笔记，包含 VueRouter 具体的API接口的使用方法，具体查看文档；</p>
<a id="more"></a>

<h1 id="VueRouterAPI官方参考文档笔记"><a href="#VueRouterAPI官方参考文档笔记" class="headerlink" title="VueRouterAPI官方参考文档笔记"></a>VueRouterAPI官方参考文档笔记</h1><p><a href="https://router.vuejs.org/zh/api/#router-link" target="_blank" rel="noopener">VueRouterAPI文档</a></p>
<h2 id="1-Router-基本API"><a href="#1-Router-基本API" class="headerlink" title="1. Router 基本API"></a>1. Router 基本API</h2><h3 id="1-1-lt-router-link-gt"><a href="#1-1-lt-router-link-gt" class="headerlink" title="1.1 &lt;router-link&gt;"></a>1.1 &lt;router-link&gt;</h3><p><code>&lt;router-link&gt;</code> 组件支持用户在具有路由功能的应用中 (点击) 导航；该组件 <code>to</code> 属性指定目标地址，默认渲染成带有正确链接的 <code>&lt;a&gt;</code> 标签，可以通过配置 <code>tag</code> 属性生成别的标签；当目标路由成功激活时，链接元素自动设置一个表示激活的 <code>CSS</code> 类名。</p>
<h4 id="将激活-class-应用在外层元素"><a href="#将激活-class-应用在外层元素" class="headerlink" title="将激活 class 应用在外层元素"></a>将激活 class 应用在外层元素</h4><p>激活 <code>class</code> 应用在外层元素，而不是 <code>&lt;a&gt;</code> 标签本身，那么可以用 <code>&lt;router-link&gt;</code> 渲染外层元素，包裹着内层的原生 <code>&lt;a&gt;</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span>/foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;a&gt;</code> 将作为真实的链接 (它会获得正确的 <code>href</code> 的)，而 “激活时的 <code>CSS</code> 类名” 则设置到外层的 <code>&lt;li&gt;</code> 上；</p>
<h3 id="1-2-lt-router-link-gt-Props"><a href="#1-2-lt-router-link-gt-Props" class="headerlink" title="1.2 &lt;router-link&gt; Props"></a>1.2 &lt;router-link&gt; Props</h3><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><table>
<thead>
<tr>
<th>类型</th>
<th>required</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string 或 Location</td>
<td>true</td>
<td>表示目标路由的链接。当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code>，所以这个值可以是一个字符串或者是描述目标位置的对象。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 命名的路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
<td>设置 <code>replace</code> 属性的话，当点击时，会调用 <code>router.replace()</code> 而不是 <code>router.push()</code>，于是导航后不会留下 <code>history</code> 记录；</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: '/abc'&#125;"</span> <span class="attr">replace</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
<td>设置 <code>append</code> 属性后，则在当前 <code>(相对)</code>路径前添加<code>基路径</code>。例如，我们从 <code>/a</code> 导航到一个相对路径 <code>b</code>，如果没有配置 <code>append</code> ，则路径为 <code>/b</code>，如果配了，则为 <code>/a/b</code> ；</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: 'relative/path'&#125;"</span> <span class="attr">append</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>‘a’</td>
<td>若想要 <code>&lt;router-link&gt;</code> 渲染成某种标签，例如 <code>&lt;li&gt;</code>； 于是使用 <code>tag prop</code> 类指定何种标签，同样它还是会监听点击，触发导航；</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span> <span class="attr">tag</span>=<span class="string">"li"</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“router-link-active”</td>
<td>设置 链接激活时使用的 <code>CSS</code> 类名；默认值可以通过路由的构造选项 <code>linkActiveClass</code> 来全局配置；</td>
</tr>
</tbody></table>
<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
<td>“是否激活” 默认类名的依据是 <code>inclusive match</code> (全包含匹配)；如果当前的路径是 <code>/a</code> 开头的，那么 <code>&lt;router-link to=&quot;/a&quot;&gt;</code> 也会被设置 CSS 类名；按照这个规则，每个路由都会激活<code>&lt;router-link to=&quot;/&quot;&gt;</code>，因而想要链接使用 “<code>exact 匹配模式</code>“，则使用 <code>exact</code> 属性；</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">exact</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="event"><a href="#event" class="headerlink" title="event"></a>event</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string 或 Array<code>&lt;string&gt;</code></td>
<td>‘click’</td>
<td>声明可以用来触发导航的事件；可以是一个字符串或是一个包含字符串的数组；</td>
</tr>
</tbody></table>
<h4 id="exact-active-class"><a href="#exact-active-class" class="headerlink" title="exact-active-class"></a>exact-active-class</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“router-link-exact-active”</td>
<td>配置当链接被精确匹配的时候应该激活的 <code>class</code> ；注意默认值也是可以通过路由构造函数选项 <code>linkExactActiveClass</code> 进行全局配置的；</td>
</tr>
</tbody></table>
<h3 id="1-3-lt-router-view-gt"><a href="#1-3-lt-router-view-gt" class="headerlink" title="1.3 &lt;router-view&gt;"></a>1.3 &lt;router-view&gt;</h3><p><code>&lt;router-view&gt;</code> 组件是一个 <code>functional</code> 组件，渲染路径匹配到的视图组件；<code>&lt;router-view&gt;</code> 渲染的组件还可以内嵌自己的 <code>&lt;router-view&gt;</code>，根据嵌套路径，渲染嵌套组件；<br>因为<code>&lt;router-view&gt;</code>也是个组件，所以可以配合 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 使用，如两个结合一起用，要确保在内层使用 <code>&lt;keep-alive&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-lt-router-view-gt-Props"><a href="#1-4-lt-router-view-gt-Props" class="headerlink" title="1.4 &lt;router-view&gt; Props"></a>1.4 &lt;router-view&gt; Props</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“default”</td>
<td>若 <code>&lt;router-view&gt;</code>设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件；</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-Router-构建选项"><a href="#2-Router-构建选项" class="headerlink" title="2. Router 构建选项"></a>2. Router 构建选项</h2><h3 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h3><table>
<thead>
<tr>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Array<code>&lt;RouteConfig&gt;</code></td>
<td>RouteConfig 的类型定义如下：</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare type RouteConfig = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  component?: Component;</span><br><span class="line">  name?: string; <span class="comment">// 命名路由</span></span><br><span class="line">  components?: &#123; [name: string]: Component &#125;; <span class="comment">// 命名视图组件</span></span><br><span class="line">  redirect?: string | Location | <span class="built_in">Function</span>;</span><br><span class="line">  props?: boolean | <span class="built_in">Object</span> | <span class="built_in">Function</span>;</span><br><span class="line">  alias?: string | <span class="built_in">Array</span>&lt;string&gt;;</span><br><span class="line">  children?: <span class="built_in">Array</span>&lt;RouteConfig&gt;; <span class="comment">// 嵌套路由</span></span><br><span class="line">  beforeEnter?: <span class="function">(<span class="params">to: Route, <span class="keyword">from</span>: Route, next: <span class="built_in">Function</span></span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  meta?: any;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.6.0+</span></span><br><span class="line">  caseSensitive?: boolean; <span class="comment">// 匹配规则是否大小写敏感？(默认值：false)</span></span><br><span class="line">  pathToRegexpOptions?: <span class="built_in">Object</span>; <span class="comment">// 编译正则的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>可选值</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“hash” (浏览器环境) 或 “abstract” (Node.js 环境)</td>
<td>“hash” 或 “history” 或 “abstract”</td>
</tr>
</tbody></table>
<p>配置路由模式介绍：</p>
<ul>
<li>hash: 使用 <code>URL hash</code> 值来作路由。支持所有浏览器，包括不支持 <code>HTML5 History Api</code> 的浏览器；</li>
<li>history: 依赖 <code>HTML5 History API</code> 和服务器配置；查看 <code>HTML5 History</code> 模式；</li>
<li>abstract: 支持所有 <code>JavaScript</code> 运行环境，如 <code>Node.js</code> 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式；</li>
</ul>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“/“</td>
<td>应用的基路径。例如，如果整个单页应用服务在 <code>/app/</code> 下，然后 <code>base</code> 就应该设为 <code>&quot;/app/&quot;</code>；</td>
</tr>
</tbody></table>
<h3 id="linkActiveClass"><a href="#linkActiveClass" class="headerlink" title="linkActiveClass"></a>linkActiveClass</h3><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“router-link-active”</td>
<td>全局配置 <code>&lt;router-link&gt;</code> 的默认<code>“激活 class 类名”</code>；</td>
</tr>
</tbody></table>
<h3 id="linkExactActiveClass"><a href="#linkExactActiveClass" class="headerlink" title="linkExactActiveClass"></a>linkExactActiveClass</h3><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>“router-link-exact-active”</td>
<td>全局配置 <router-link> 精确激活的默认的 <code>class</code> ；</router-link></td>
</tr>
</tbody></table>
<h3 id="scrollBehavior"><a href="#scrollBehavior" class="headerlink" title="scrollBehavior"></a>scrollBehavior</h3><table>
<thead>
<tr>
<th>类型</th>
<th>签名</th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td><a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html" target="_blank" rel="noopener">滚动行为</a></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type PositionDescriptor =</span><br><span class="line">  &#123; <span class="attr">x</span>: number, <span class="attr">y</span>: number &#125; |</span><br><span class="line">  &#123; <span class="attr">selector</span>: string &#125; |</span><br><span class="line">  ?&#123;&#125;</span><br><span class="line"></span><br><span class="line">type scrollBehaviorHandler = (</span><br><span class="line">  to: Route,</span><br><span class="line">  <span class="keyword">from</span>: Route,</span><br><span class="line">  savedPosition?: &#123; <span class="attr">x</span>: number, <span class="attr">y</span>: number &#125;</span><br><span class="line">) =&gt; PositionDescriptor | <span class="built_in">Promise</span>&lt;PositionDescriptor&gt;</span><br></pre></td></tr></table></figure>

<h3 id="parseQuery-stringifyQuery"><a href="#parseQuery-stringifyQuery" class="headerlink" title="parseQuery / stringifyQuery"></a>parseQuery / stringifyQuery</h3><table>
<thead>
<tr>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td>提供自定义查询字符串的解析/反解析函数；覆盖默认行为。</td>
</tr>
</tbody></table>
<h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>true</td>
<td>当浏览器不支持 <code>history.pushState</code> 控制路由是否应该回退到 <code>hash</code> 模式；默认值为 <code>true</code>；</td>
</tr>
</tbody></table>
<p>在 <code>IE9</code> 中，设置为 <code>false</code> 会使得每个 <code>router-link</code> 导航都触发整页刷新；它可用于工作在 <code>IE9</code> 下的服务端渲染应用，因为一个 <code>hash</code> 模式的 <code>URL</code> 并不支持服务端渲染；</p>
<h2 id="3-Router-实例属性"><a href="#3-Router-实例属性" class="headerlink" title="3. Router 实例属性"></a>3. Router 实例属性</h2><h3 id="router-app"><a href="#router-app" class="headerlink" title="router.app"></a>router.app</h3><table>
<thead>
<tr>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Vue instance</td>
<td>配置了 <code>router</code> 的 <code>Vue</code> 根实例；</td>
</tr>
</tbody></table>
<h3 id="router-mode"><a href="#router-mode" class="headerlink" title="router.mode"></a>router.mode</h3><table>
<thead>
<tr>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>路由使用的模式（”hash” 或 “history” 或 “abstract”）；</td>
</tr>
</tbody></table>
<h3 id="router-currentRoute"><a href="#router-currentRoute" class="headerlink" title="router.currentRoute"></a>router.currentRoute</h3><table>
<thead>
<tr>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Route</td>
<td>当前路由对应的路由信息对象；</td>
</tr>
</tbody></table>
<h2 id="4-Router-实例方法"><a href="#4-Router-实例方法" class="headerlink" title="4. Router 实例方法"></a>4. Router 实例方法</h2><h3 id="router-beforeEach"><a href="#router-beforeEach" class="headerlink" title="router.beforeEach"></a>router.beforeEach</h3><h3 id="router-beforeResolve"><a href="#router-beforeResolve" class="headerlink" title="router.beforeResolve"></a>router.beforeResolve</h3><h3 id="router-afterEach"><a href="#router-afterEach" class="headerlink" title="router.afterEach"></a>router.afterEach</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加全局的导航守卫，参考导航守卫；这三个方法都返回一个移除已注册的守卫/钩子的函数；</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* must call `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* must call `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push"></a>router.push</h3><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h3><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h3><h3 id="router-back"><a href="#router-back" class="headerlink" title="router.back"></a>router.back</h3><h3 id="router-forward"><a href="#router-forward" class="headerlink" title="router.forward"></a>router.forward</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态的导航到一个新 URL，参考编程式导航。</span></span><br><span class="line">router.push(location, onComplete?, onAbort?)</span><br><span class="line">router.replace(location, onComplete?, onAbort?)</span><br><span class="line">router.go(n)</span><br><span class="line">router.back()</span><br><span class="line">router.forward()</span><br></pre></td></tr></table></figure>

<h3 id="router-getMatchedComponents"><a href="#router-getMatchedComponents" class="headerlink" title="router.getMatchedComponents"></a>router.getMatchedComponents</h3><ul>
<li>函数签名：<code>const matchedComponents: Array&lt;Component&gt; = router.getMatchedComponents(location?)</code>；</li>
<li>功能：返回目标位置或是当前路由匹配的组件数组 (是数组的定义/构造类，不是实例)。通常在服务端渲染的数据预加载时使用；</li>
</ul>
<h3 id="router-resolve"><a href="#router-resolve" class="headerlink" title="router.resolve"></a>router.resolve</h3><ul>
<li>函数签名：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved: &#123;</span><br><span class="line">  location: Location;</span><br><span class="line">  route: Route;</span><br><span class="line">  href: string;</span><br><span class="line">&#125; = router.resolve(location, current?, append?)</span><br></pre></td></tr></table></figure></li>
<li>功能：解析目标位置 (格式和 <code>&lt;router-link&gt;</code> 的 <code>to prop</code> 一样)；<ul>
<li><code>current</code> 是当前默认的路由 (通常你不需要改变它)；</li>
<li><code>append</code> 允许你在 current 路由上附加路径 (如同 <code>router-link</code>)；</li>
</ul>
</li>
</ul>
<h3 id="router-addRoutes"><a href="#router-addRoutes" class="headerlink" title="router.addRoutes"></a>router.addRoutes</h3><ul>
<li>函数签名：<code>router.addRoutes(routes: Array&lt;RouteConfig&gt;)</code>；</li>
<li>功能：动态添加更多的路由规则；参数必须是一个符合 <code>routes</code> 选项要求的数组；</li>
</ul>
<h3 id="router-onReady"><a href="#router-onReady" class="headerlink" title="router.onReady"></a>router.onReady</h3><ul>
<li>函数签名：<code>router.onReady(callback, [errorCallback])</code>；</li>
<li>功能：该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件；这可以有效确保服务端渲染时服务端和客户端输出的一致。</li>
</ul>
<h3 id="router-onError"><a href="#router-onError" class="headerlink" title="router.onError"></a>router.onError</h3><ul>
<li>函数签名：<code>router.onError(callback)</code>；</li>
<li>功能：注册一个回调，该回调会在路由导航过程中出错时被调用；注意被调用的错误必须是下列情形中的一种：<ul>
<li>错误在一个路由守卫函数中被同步抛出；</li>
<li>错误在一个路由守卫函数中通过调用 next(err) 的方式异步捕获并处理；</li>
<li>渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误；</li>
</ul>
</li>
</ul>
<h2 id="5-路由对象"><a href="#5-路由对象" class="headerlink" title="5. 路由对象"></a>5. 路由对象</h2><p>一个路由对象 (<code>route object</code>) 表示当前激活的路由的状态信息，包含了当前 <code>URL</code> 解析得到的信息，还有 URL 匹配到的路由记录 (<code>route records</code>)；路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象；</p>
<p>路由对象出现在多个地方：</p>
<ol>
<li>在组件内，即 <code>this.$route</code>；</li>
<li>在 <code>$route</code> 观察者回调内；</li>
<li><code>router.match(location)</code> 的返回值；</li>
<li>导航守卫的参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// `to` 和 `from` 都是路由对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><code>scrollBehavior</code> 方法的参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// `to` 和 `from` 都是路由对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="路由对象属性"><a href="#路由对象属性" class="headerlink" title="路由对象属性"></a>路由对象属性</h3><table>
<thead>
<tr>
<th>路由对象属性名</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>$route.path</td>
<td>string</td>
<td>字符串，对应当前路由的路径，总是解析为绝对路径，如 <code>&quot;/foo/bar&quot;</code></td>
</tr>
<tr>
<td>$route.params</td>
<td>Object</td>
<td>一个 <code>key/value</code> 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象；</td>
</tr>
<tr>
<td>$route.query</td>
<td>Object</td>
<td>一个 <code>key/value</code> 对象，表示 <code>URL</code> 查询参数。例如，对于路径 <code>/foo?user=1</code>，则有 <code>$route.query.user == 1</code>，如果没有查询参数，则是个空对象；</td>
</tr>
<tr>
<td>$route.hash</td>
<td>string</td>
<td>当前路由的 <code>hash</code> 值 (带 <code>#</code>) ，如果没有 <code>hash</code> 值，则为空字符串；</td>
</tr>
<tr>
<td>$route.fullPath</td>
<td>string</td>
<td>完成解析后的 <code>URL</code> ，包含查询参数和 <code>hash</code> 的完整路径；</td>
</tr>
<tr>
<td>$route.matched</td>
<td>Array<code>&lt;RouteRecord&gt;</code></td>
<td>一个数组，包含当前路由的所有嵌套路径片段的路由记录；路由记录就是 <code>routes</code> 配置数组中的对象副本 (还有在 <code>children</code> 数组)；</td>
</tr>
<tr>
<td>$route.name</td>
<td>–</td>
<td>当前路由的名称，如果有的话；查看<a href="https://router.vuejs.org/zh/guide/essentials/named-routes.html" target="_blank" rel="noopener">命名路由</a></td>
</tr>
<tr>
<td>$route.redirectedFrom</td>
<td>–</td>
<td>如果存在重定向，即为重定向来源的路由的名字；查看<a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">重定向和别名</a></td>
</tr>
</tbody></table>
<h2 id="6-组件注入"><a href="#6-组件注入" class="headerlink" title="6. 组件注入"></a>6. 组件注入</h2><h3 id="注入的属性"><a href="#注入的属性" class="headerlink" title="注入的属性"></a>注入的属性</h3><p>通过在 <code>Vue</code> 根实例的 <code>router</code> 配置传入 <code>router</code> 实例，下面这些属性成员会被注入到每个子组件：</p>
<ul>
<li><code>this.$router</code>：<code>router</code> 实例；</li>
<li><code>this.$route</code>：当前激活的 <code>路由信息对象</code>；这个属性是只读的，里面的属性是 <code>immutable</code> (不可变) 的，不过你可以 <code>watch</code> (监测变化) 它；</li>
</ul>
<h3 id="增加的组件配置选项"><a href="#增加的组件配置选项" class="headerlink" title="增加的组件配置选项"></a>增加的组件配置选项</h3><ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ul>
<p>查看<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">组件内的守卫</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>VueRouter</category>
        <category>官方API文档</category>
      </categories>
      <tags>
        <tag>VueRouter</tag>
        <tag>Vue</tag>
        <tag>路由API</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouter官方文档笔记</title>
    <url>/2019/03/05/VueRouter%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>在 Vue 的学习中，VueRouter 是 Vue.js 官方的路由管理器，该文档是对 VueRouter 官方文档的知识的学习笔记，包括了 VueRouter 的基本使用以及进阶部分的知识，具体查看文档；</p>
<a id="more"></a>

<h1 id="VueRouter官方文档笔记"><a href="#VueRouter官方文档笔记" class="headerlink" title="VueRouter官方文档笔记"></a>VueRouter官方文档笔记</h1><p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">VueRouter 官方文档</a></p>
<h2 id="1-起步"><a href="#1-起步" class="headerlink" title="1. 起步"></a>1. 起步</h2><h3 id="1-1-html-框架"><a href="#1-1-html-框架" class="headerlink" title="1.1 html 框架"></a>1.1 html 框架</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router/dist/vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-JavaScript-代码"><a href="#1-2-JavaScript-代码" class="headerlink" title="1.2 JavaScript 代码"></a>1.2 JavaScript 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></span><br><span class="line"><span class="comment">// 1. 定义 (路由) 组件。</span></span><br><span class="line"><span class="comment">// 可以从其他文件 import 进来</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</span><br><span class="line"><span class="comment">// 2. 定义路由</span></span><br><span class="line"><span class="comment">// 每个路由应该映射一个组件。 其中"component" 可以是</span></span><br><span class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></span><br><span class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></span><br><span class="line"><span class="comment">// 我们晚点再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes <span class="comment">// (缩写) 相当于 routes: routes</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4. 创建和挂载根实例。</span></span><br><span class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></span><br><span class="line"><span class="comment">// 从而让整个应用都有路由功能</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br></pre></td></tr></table></figure>

<p>通过注入路由器<code>router</code>对象到<code>Vue</code>对象中，我们可以在Vue的任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    username () &#123;</span><br><span class="line">      <span class="comment">// 我们很快就会看到 `params` 是什么</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$route.params.username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    goBack () &#123;</span><br><span class="line">      <span class="built_in">window</span>.history.length &gt; <span class="number">1</span> ? <span class="keyword">this</span>.$router.go(<span class="number">-1</span>) : <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态路由匹配（params-参数）"><a href="#2-动态路由匹配（params-参数）" class="headerlink" title="2. 动态路由匹配（params 参数）"></a>2. 动态路由匹配（params 参数）</h2><p>有时需要把某种模式匹配到的所有路由，全都映射到同个组件，可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(<code>dynamic segment</code>) 来达到这个效果；例如，有一个 <code>User</code> 组件，对所有 <code>ID</code> 各不相同的用户，都要使用这个组件来渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用$route.params 获取url携带的信息；除此，$route 对象还提供了其它有用的信息，例如，$route.query (如果 URL 中有查询参数)、$route.hash 等等</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中，例如：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody><tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td>{ username: ‘evan’ }</td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td>{ username: ‘evan’, post_id: 123 }</td>
</tr>
</tbody></table>
<h3 id="2-1-响应路由参数的变化-路由参数改变，组件的复用"><a href="#2-1-响应路由参数的变化-路由参数改变，组件的复用" class="headerlink" title="2.1 响应路由参数的变化(路由参数改变，组件的复用)"></a>2.1 响应路由参数的变化(路由参数改变，组件的复用)</h3><p>若使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用；因为两个路由都渲染同个组件，复用显得更加高效；这也意味着组件的生命周期钩子不会再被调用，复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <code>watch</code> (监测变化) <code>$route</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watch (监测变化) $route 对象</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 Router进阶 中引入的 beforeRouteUpdate 导航守卫：</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don't forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-高级匹配模式"><a href="#2-2-高级匹配模式" class="headerlink" title="2.2 高级匹配模式"></a>2.2 高级匹配模式</h3><p><code>vue-router</code> 使用 <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a> 作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配；</p>
<h3 id="2-3-匹配优先级"><a href="#2-3-匹配优先级" class="headerlink" title="2.3 匹配优先级"></a>2.3 匹配优先级</h3><p>同一个路径可以匹配多个路由，此时匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
<h2 id="3-嵌套路由"><a href="#3-嵌套路由" class="headerlink" title="3. 嵌套路由"></a>3. 嵌套路由</h2><p>下面是一个嵌套路由的实例，从设计的结构到实现的代码：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">/user/foo/profile                     /user/foo/posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根节点app，这里的 &lt;router-view&gt; 是最顶层的出口，渲染最高级路由匹配到的组件</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义动态路由参数，并在组件中使用</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 User 组件的模板添加一个 &lt;router-view&gt;【一个被渲染组件同样可以包含自己的嵌套&lt;router-view&gt;】</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="user"&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'profile'</span>,</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'posts'</span>,</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：以 <code>/</code> 开头的嵌套路径会被当作根路径； 这让你充分的使用嵌套组件而无须设置嵌套的路径。</p>
<h2 id="4-编程式的导航"><a href="#4-编程式的导航" class="headerlink" title="4. 编程式的导航"></a>4. 编程式的导航</h2><h3 id="4-1-router-push"><a href="#4-1-router-push" class="headerlink" title="4.1 router.push()"></a>4.1 router.push()</h3><p>声明式导航 | 编程式导航<br>— | — | —<br><code>&lt;router-link :to=&quot;...&quot;&gt;</code> | <code>router.push(...)</code></p>
<p>当点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用<code>router.push(...)</code>，因而两个是等同关系的；</p>
<p><strong>编程式导航语法</strong>： <code>router.push(location, onComplete?, onAbort?)</code></p>
<p>在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个可选参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用；</p>
<p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问<code>路由实例</code>；因此可以使用 <code>this.$router.push</code>方法;</strong></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果提供了 <code>path，params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ，同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="number">123</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-router-replace"><a href="#4-2-router-replace" class="headerlink" title="4.2 router.replace()"></a>4.2 router.replace()</h3><p>声明式导航 | 编程式导航<br>— | — | —<br><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code> | <code>router.replace(location, onComplete?, onAbort?)</code></p>
<p>该方法跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 <code>history</code> 添加新记录，而是跟它的方法名一样是替换掉当前的 <code>history</code> 记录。</p>
<h3 id="4-3-router-go"><a href="#4-3-router-go" class="headerlink" title="4.3 router.go()"></a>4.3 router.go()</h3><p>所有语法：<code>router.go(n)</code>； 这个方法的参数是一个整数，意思是在 <code>history</code> 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-操作-History"><a href="#4-4-操作-History" class="headerlink" title="4.4 操作 History"></a>4.4 操作 History</h3><p><code>router.push</code>、 <code>router.replace</code> 和 <code>router.go</code> 跟 <code>window.history.pushState</code>、 <code>window.history.replaceState</code> 和 <code>window.history.go</code>好像， 实际上它们确实是效仿 <code>window.history API</code> 的，参考浏览器历史纪录API接口 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">Browser History APIs</a>；</p>
<p>同时，<code>Vue Router</code> 的导航方法 (<code>push、 replace、 go</code>) 在各类路由模式 (<code>history、 hash 和 abstract</code>) 下表现一致；</p>
<h2 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5. 命名路由"></a>5. 命名路由</h2><p>在创建 <code>Router</code> 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称（<code>name</code>属性）；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/user/:userId'</span>,</span><br><span class="line">      name: <span class="string">'user'</span>,</span><br><span class="line">      component: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要链接到一个命名路由，可以给 <code>&lt;router-link /&gt;</code> 的 <code>to</code> 属性传一个对象，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>router.push()</code> 也是一样的道理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-命名视图"><a href="#6-命名视图" class="headerlink" title="6. 命名视图"></a>6. 命名视图</h2><p>若想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="6-1-嵌套命名视图"><a href="#6-1-嵌套命名视图" class="headerlink" title="6.1 嵌套命名视图"></a>6.1 嵌套命名视图</h3><p>对于命名视图创建嵌套视图的复杂布局，也需要命名用到的嵌套 <code>router-view</code> 组件，如下面板为例：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Nav</code> 只是一个常规组件；</li>
<li><code>UserSettings</code> 是一个视图组件；</li>
<li><code>UserEmailsSubscriptions、UserProfile、UserProfilePreview</code> 是嵌套的视图组件；</li>
</ul>
<p><code>UserSettings</code> 组件的 <code>&lt;template&gt;</code> 部分代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"helper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>路由配置规则代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/settings'</span>,</span><br><span class="line">  <span class="comment">// 你也可以在顶级路由就配置命名视图</span></span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: <span class="string">'emails'</span>,</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: <span class="string">'profile'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="keyword">default</span>: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-重定向和别名"><a href="#7-重定向和别名" class="headerlink" title="7 重定向和别名"></a>7 重定向和别名</h2><h3 id="7-1-重定向"><a href="#7-1-重定向" class="headerlink" title="7.1 重定向"></a>7.1 重定向</h3><p>重定向也是通过 <code>routes</code> 配置来完成，设置<code>redirect</code>属性的值；下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向的目标也可以是一个命名的路由：</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/b'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以是一个方法，动态返回重定向目标：</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/c'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>并没有应用在跳转路由上，而仅仅应用在其目标上；在下面这个例子中，为 /a 路由添加一个 <code>beforeEach</code> 或 <code>beforeLeave</code> 守卫并不会有任何效果；</strong></p>
<h3 id="7-2-别名"><a href="#7-2-别名" class="headerlink" title="7.2 别名"></a>7.2 别名</h3><p>别名的含义：例如 <code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时， <code>URL</code> 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样；“别名”的功能让你可以自由地将 <code>UI</code> 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">'/b'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="8-路由组件传参"><a href="#8-路由组件传参" class="headerlink" title="8. 路由组件传参"></a>8. 路由组件传参</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性；因而使用 <code>props</code> 将组件和路由解耦，<strong>取代与 <code>$route</code> 的耦合</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>通过 props 解耦：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  props: [<span class="string">'id'</span>],</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/user/:id'</span>,</span><br><span class="line">      components: &#123; <span class="attr">default</span>: User, <span class="attr">sidebar</span>: Sidebar &#125;,</span><br><span class="line">      props: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-1-布尔模式"><a href="#8-1-布尔模式" class="headerlink" title="8.1 布尔模式"></a>8.1 布尔模式</h3><p>如果 <code>props</code> 被设置为 <code>true</code> ，<code>route.params</code> 将会被设置为组件属性；</p>
<h3 id="8-2-对象模式"><a href="#8-2-对象模式" class="headerlink" title="8.2 对象模式"></a>8.2 对象模式</h3><p>如果 <code>props</code> 是一个对象，它会被按原样设置为组件属性；当 <code>props</code> 是静态的时候有用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/promotion/from-newsletter'</span>, <span class="attr">component</span>: Promotion, <span class="attr">props</span>: &#123; <span class="attr">newsletterPopup</span>: <span class="literal">false</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-3-函数模式"><a href="#8-3-函数模式" class="headerlink" title="8.3 函数模式"></a>8.3 函数模式</h3><p>可以创建一个函数返回 <code>props</code> ，这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/search'</span>, <span class="attr">component</span>: SearchUser, <span class="attr">props</span>: <span class="function">(<span class="params">route</span>) =&gt;</span> (&#123; <span class="attr">query</span>: route.query.q &#125;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// URL /search?q=vue 会将 &#123;query: 'vue'&#125; 作为属性传递给 SearchUser 组件;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-HTML5-History-模式"><a href="#9-HTML5-History-模式" class="headerlink" title="9. HTML5 History 模式"></a>9. HTML5 History 模式</h2><p><code>vue-router</code> 默认 <code>hash</code> 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载；若不想要很丑的 <code>hash</code> ，我们可以用路由的 <code>history</code> 模式，这种模式充分利用 <code>history.pushState API</code> 来完成 URL 跳转而无须重新加载页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当使用 <code>history</code> 模式时， <code>URL</code> 就像正常的 url，例如 <code>http://yoursite.com/user/id</code>；不过这种模式需要后台配置支持；要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面；</p>
<h3 id="9-1-后端配置例子"><a href="#9-1-后端配置例子" class="headerlink" title="9.1 后端配置例子"></a>9.1 后端配置例子</h3><p><strong>原生 Node.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> httpPort = <span class="number">80</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">'index.htm'</span>, <span class="string">'utf-8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'We cannot open "index.htm" file.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=utf-8'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(content)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(httpPort, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server listening on: http://localhost:%s'</span>, httpPort)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-2-警告"><a href="#9-2-警告" class="headerlink" title="9.2 警告"></a>9.2 警告</h3><p>这么做以后，你的服务器就不再返回 <code>404</code> 错误页面，因为对于所有路径都会返回 <code>index.html</code> 文件；为避免这种情况，应该在 <code>Vue</code> 应用里面覆盖所有的路由情况，然后在给出一个 404 页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: NotFoundComponent &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="10-导航守卫"><a href="#10-导航守卫" class="headerlink" title="10. 导航守卫"></a>10. 导航守卫</h2><p><code>vue-router</code> 提供的导航守卫主要用来通过<code>跳转或取消</code>的方式守卫导航，<code>参数或查询的改变</code>并不会触发<code>进入/离开的导航守卫</code>；可以通过观察 <code>$route</code> 对象来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫；</p>
<h3 id="10-1-全局守卫"><a href="#10-1-全局守卫" class="headerlink" title="10.1 全局守卫"></a>10.1 全局守卫</h3><p>使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>to: Route</code>: 即将要进入的目标 <code>路由对象</code> ；</li>
<li><code>from: Route</code>: 当前导航正要离开的路由；</li>
<li><code>next: Function</code>: 一定要调用该方法来 <code>resolve</code> 这个钩子；执行效果依赖 <code>next</code> 方法的调用参数；<ul>
<li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <code>confirmed</code> (确认的)；</li>
<li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li>
<li><code>next(&#39;/&#39;)</code> 或者 next<code>({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true、name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to prop</code> 或 <code>router.push</code> 中的选项。</li>
<li><code>next(error)</code>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保要调用 <code>next</code> 方法，否则钩子就不会被 <code>resolved</code> ；</strong></p>
<h3 id="10-2-全局解析守卫-2-5-0-新增"><a href="#10-2-全局解析守卫-2-5-0-新增" class="headerlink" title="10.2 全局解析守卫(2.5.0 新增)"></a>10.2 全局解析守卫(2.5.0 新增)</h3><p>用 <code>router.beforeResolve</code> 注册一个全局守卫；这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>
<h3 id="10-3-全局后置钩子"><a href="#10-3-全局后置钩子" class="headerlink" title="10.3 全局后置钩子"></a>10.3 全局后置钩子</h3><p>用 <code>router.afterEach</code> 注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="10-4-路由独享的守卫"><a href="#10-4-路由独享的守卫" class="headerlink" title="10.4 路由独享的守卫"></a>10.4 路由独享的守卫</h3><p>可以在路由配置上直接定义 <code>beforeEnter</code> 守卫，参数与全局前置守卫的方法参数是一样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="10-5-组件内的守卫"><a href="#10-5-组件内的守卫" class="headerlink" title="10.5 组件内的守卫"></a>10.5 组件内的守卫</h3><p>可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate (2.2 新增)</li>
<li>beforeRouteLeave</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beforeRouteEnter</strong>：</p>
<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code> ，是因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建；不过可以通过传一个回调给 <code>next</code> 来访问组件实例；在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beforeRouteUpdate</strong>：</p>
<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫；对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说， <code>this</code> 已经可用了，所以不支持传递回调：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// just use `this`</span></span><br><span class="line">  <span class="keyword">this</span>.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beforeRouteLeave</strong>：<br>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span> , next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">'Do you really want to leave? you have unsaved changes!'</span>)</span><br><span class="line">  <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-6-完整的导航解析流程"><a href="#10-6-完整的导航解析流程" class="headerlink" title="10.6 完整的导航解析流程"></a>10.6 完整的导航解析流程</h3><ol>
<li>导航被触发；</li>
<li>在失活的组件里调用离开守卫；</li>
<li>调用全局的 <code>beforeEach</code> 守卫；</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)；</li>
<li>在路由配置里调用 <code>beforeEnter</code> ；</li>
<li>解析异步路由组件；</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code> ；</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)；</li>
<li>导航被确认；</li>
<li>调用全局的 <code>afterEach</code> 钩子；</li>
<li>触发 DOM 更新；</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数；</li>
</ol>
<h2 id="11-路由元信息"><a href="#11-路由元信息" class="headerlink" title="11. 路由元信息"></a>11. 路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'bar'</span>,</span><br><span class="line">          component: Bar,</span><br><span class="line">          <span class="comment">// a meta field</span></span><br><span class="line">          meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在<code>routes</code> 配置中的每个路由对象为 <code>路由记录</code>；路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录；一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组；因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段，如下面例子展示在全局导航守卫中检查元字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;</span><br><span class="line">    <span class="comment">// this route requires auth, check if logged in</span></span><br><span class="line">    <span class="comment">// if not, redirect to login page.</span></span><br><span class="line">    <span class="keyword">if</span> (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        query: &#123; <span class="attr">redirect</span>: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next() <span class="comment">// 确保一定要调用 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="12-过渡动效"><a href="#12-过渡动效" class="headerlink" title="12. 过渡动效"></a>12. 过渡动效</h2><p>在 <code>&lt;router-view&gt;</code> 动态组件中使用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Transition 的所有功能</a> 都能使用；</p>
<h3 id="12-1-单个路由的过渡"><a href="#12-1-单个路由的过渡" class="headerlink" title="12.1 单个路由的过渡"></a>12.1 单个路由的过渡</h3><p>在 <code>&lt;router-view&gt;</code> 动态组件中使用 <code>&lt;transition&gt;</code> 组件会给所有路由设置一样的过渡效果；若想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 <code>name</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;transition name="slide"&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="foo"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/transition&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bar = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;transition name="fade"&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="bar"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/transition&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-基于路由的动态过渡"><a href="#12-2-基于路由的动态过渡" class="headerlink" title="12.2 基于路由的动态过渡"></a>12.2 基于路由的动态过渡</h3><p>可以基于当前路由与目标路由的变化关系，动态设置过渡效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用动态的 transition name --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"transitionName"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接着在父组件内</span></span><br><span class="line"><span class="comment">// watch $route 决定使用哪种过渡</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> toDepth = to.path.split(<span class="string">'/'</span>).length</span><br><span class="line">    <span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">'/'</span>).length</span><br><span class="line">    <span class="keyword">this</span>.transitionName = toDepth &lt; fromDepth ? <span class="string">'slide-right'</span> : <span class="string">'slide-left'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-数据获取"><a href="#13-数据获取" class="headerlink" title="13. 数据获取"></a>13. 数据获取</h2><p>进入某个路由后，需要从服务器获取数据；例如，在渲染用户信息时，你需要从服务器获取用户的数据；可以通过下面两种方式来实现：</p>
<ul>
<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据；在数据获取期间显示“加载中”之类的指示；</li>
<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航；</li>
</ul>
<h3 id="13-1-导航完成后获取数据"><a href="#13-1-导航完成后获取数据" class="headerlink" title="13.1 导航完成后获取数据"></a>13.1 导航完成后获取数据</h3><p>当使用这种方式时，我们使用导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据；这让我们有机会在数据获取期间展示一个 <code>loading</code> 状态，还可以在不同视图间展示不同的 <code>loading</code> 状态：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">      Loading...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      &#123;&#123; error &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 组件创建完后获取数据，</span></span><br><span class="line">    <span class="comment">// 此时 data 已经被 observed 了</span></span><br><span class="line">    <span class="keyword">this</span>.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果路由有变化，会再次执行该方法</span></span><br><span class="line">    <span class="string">'$route'</span>: <span class="string">'fetchData'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData () &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// replace getPost with your data fetching util / API wrapper</span></span><br><span class="line">      getPost(<span class="keyword">this</span>.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = err.toString()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-在导航完成前获取数据"><a href="#13-2-在导航完成前获取数据" class="headerlink" title="13.2 在导航完成前获取数据"></a>13.2 在导航完成前获取数据</h3><p>通过这种方式，是在导航转入新的路由前获取数据；一般在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(<span class="function"><span class="params">vm</span> =&gt;</span> vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 路由改变前，组件就已经渲染完了</span></span><br><span class="line">  <span class="comment">// 逻辑稍稍不同</span></span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(err, post)</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData (err, post) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">this</span>.error = err.toString()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.post = post</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示；如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h2 id="14-滚动行为"><a href="#14-滚动行为" class="headerlink" title="14. 滚动行为"></a>14. 滚动行为</h2><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样；在 <code>vue-router</code> 中可以自定义路由切换时页面如何滚动；</p>
<p><strong>注意: 这个功能只在支持 <code>history.pushState</code> 的浏览器中可用；</strong></p>
<p>在创建 <code>Router</code> 实例时提供一个 <code>scrollBehavior</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  <span class="comment">// 该方法接收 to 和 from 路由对象；第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用；</span></span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个的位置</span></span><br><span class="line">    <span class="comment">// 返回滚动位置的对象信息格式如下:</span></span><br><span class="line">    <span class="comment">// &#123; x: number, y: number &#125;</span></span><br><span class="line">    <span class="comment">// &#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面对该方法的使用举例：</p>
<ol>
<li><p>所有路由导航，简单地让页面滚动到顶部：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回 <code>savedPosition</code> ，在按下 <code>后退/前进</code> 按钮时，就会像浏览器的原生表现那样：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> savedPosition</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟<strong>滚动到锚点</strong>的行为：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      selector: to.hash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-1-异步滚动"><a href="#14-1-异步滚动" class="headerlink" title="14.1 异步滚动"></a>14.1 异步滚动</h3><p>返回一个 <code>Promise</code> 来得出预期的位置描述：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-路由懒加载"><a href="#15-路由懒加载" class="headerlink" title="15. 路由懒加载"></a>15. 路由懒加载</h2><p>结合 <code>Vue</code> 的<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">异步组件</a>和 Webpack 的代码分割功能，轻松实现路由组件的懒加载：</p>
<ol>
<li>将异步组件定义为返回一个 <code>Promise</code> 的工厂函数 (该函数返回的 <code>Promise</code> 应该 <code>resolve</code> 组件本身)：<code>const Foo = () =&gt; Promise.resolve({ /* 组件定义对象 */ })</code>；</li>
<li>在 Webpack 2 中，我们可以使用<code>动态 import</code>语法来定义代码分块点 (split point)：<code>import(&#39;./Foo.vue&#39;) // 返回 Promise</code>；</li>
<li>结合上述两者就是如何定义一个能够被 Webpack 自动代码分割的异步组件：<code>const Foo = () =&gt; import(&#39;./Foo.vue&#39;)</code>；</li>
</ol>
<h3 id="15-1-把组件按组分块"><a href="#15-1-把组件按组分块" class="headerlink" title="15.1 把组件按组分块"></a>15.1 把组件按组分块</h3><p>把某个路由下的所有组件都打包在同个异步块 (<code>chunk</code>) 中。只需要使用 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">命名 chunk</a>，一个特殊的注释语法来提供 <code>chunk name</code> (需要 Webpack &gt; 2.4)；Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Bar.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Baz.vue'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>VueRouter</category>
        <category>官方文档</category>
      </categories>
      <tags>
        <tag>VueRouter</tag>
        <tag>Vue</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO博客文章图片展示问题</title>
    <url>/2019/03/01/HEXO%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在HEXO发布的博文中，查看文章时发现文章中的图片资源均不能成功加载，因此对HEXO的图片问题进行分析解决，具体解决方法查看文档内容；</p>
<a id="more"></a>

<h1 id="HEXO博客文章图片展示问题"><a href="#HEXO博客文章图片展示问题" class="headerlink" title="HEXO博客文章图片展示问题"></a>HEXO博客文章图片展示问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><p>在HEXO发布的博文中，查看网页中的文章时，发现文章中的图片均不能查看，只是显示了图片的标题问题，查看控制台中的请求的数据发现，文章页面中的图片资源均是加载失败，对于在HEXO博客中的问题图片问题进行分析解决；</p>
<h2 id="2-解决问题方法"><a href="#2-解决问题方法" class="headerlink" title="2. 解决问题方法"></a>2. 解决问题方法</h2><ol>
<li>把HEXO配置文件 <code>_config.yml</code>中的<code>post_asset_folder</code>属性以及 <code>permalink</code> 属性，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否启动资源文件夹，开启后通过 hexo new :title.md 生成新文章会建立一个同名的文件夹</span></span><br><span class="line">post_asset_folder: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 生成文章链接的格式，这是默认的格式；修改的规则也比较简单，标签前面要加英文冒号；（注意图片资源生成的格式必须是这个格式，否则会出现图片加载失败的情况，可见下方第6条生成的图片资源的引入格式）</span></span><br><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure></li>
<li>安装一个可以上传本地图片的插件，在<code>HEXO</code>项目的根目录下输入<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code>；</li>
<li>再运行 <code>hexo new post :title.md</code> 来生成 <code>_posts</code> 目录的MD文档时，在 <code>/source/_posts</code> 文件夹内会建立一个与<code>:title.md文件</code>同名的文件夹，结构如下；<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">文章名称</span><br><span class="line">├── hello.jpg</span><br><span class="line">└── test.jpg</span><br><span class="line">文章名称.md</span><br></pre></td></tr></table></figure></li>
<li>在<code>:title.md</code>文档中想引入图片时，先把图片复制到<code>:title.md</code>这个文件夹中，然后只需要在文档中按照 <code>markdown</code> 的格式引入图片即可，如下：<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">![图片标题](:title/:name.jpg)</span><br></pre></td></tr></table></figure></li>
<li>执行HEXO打包命令<code>hexo g</code>，可以在本地项目根目录下的<code>public</code>文件夹查看生成的文件形式，再执行上传命令<code>hexo d</code>后，就能在网页上查看到文字的图片资源了；<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">// 发布的文件目录格式</span><br><span class="line">public/<span class="number">2019</span>/<span class="number">2</span>/<span class="number">19</span>/本地图片测试</span><br><span class="line">├── hello.jpg</span><br><span class="line">├── test.jpg</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure></li>
<li>打开博客文章的网页控制台，可以查看到图片资源引入的格式为：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/2019/2/19/本地图片测试/hello.jpg"</span> <span class="attr">alt</span>=<span class="string">"hello"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>最后完成了博客文章的图片资源的显示，如下图所示：</p>
</blockquote>
<p><img src="/2019/03/01/HEXO%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%E9%97%AE%E9%A2%98/1.png" alt="图片展示"></p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>HEXO</tag>
        <tag>图片资源展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中对象数组数据的绑定问题</title>
    <url>/2019/02/20/Vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在Vue项目练习中，测试发现对于对象数组的内部数据的改变时，Vue的页面并没有出现数据的刷新操作，对该问题的分析和解决方法查看具体文档内容；</p>
<a id="more"></a>

<h1 id="Vue中对象数组数据的绑定问题"><a href="#Vue中对象数组数据的绑定问题" class="headerlink" title="Vue中对象数组数据的绑定问题"></a>Vue中对象数组数据的绑定问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><p>Vue的项目中，关于对象数组的问题，测试场景是在优惠券列表中大组件中嵌套单个优惠券，当选择某一个优惠券时，修改通过父组件传递过来的对象数据，其中父子组件是通过 <code>props</code>属性在子组件中接收数组中的对象的数据，在子组件中<code>data</code>中设置一个变量判断该子组件是否选中，初始数据为通过<code>props</code>传递的数据，并在<code>template</code>进行展示，最后改变状态是在子组件中通过 <code>$emit</code>发布订阅模式，测试到了改变父组件中的对象数组中的数据，但是测试中并没有子组件中数据显示的同步，没有改变相应的状态；<br><img src="/2019/02/20/Vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98/1.png" alt="画图"></p>
<h2 id="2-问题原因分析"><a href="#2-问题原因分析" class="headerlink" title="2. 问题原因分析"></a>2. 问题原因分析</h2><ol>
<li>在父组件中是通过<code>v-for</code>循环遍历对象数组数据，将遍历的每一个对象传递到每一个子组件中，子组件通过<code>props</code>接收对象，当子组件中通过 <code>$emit</code>发布订阅模式修改父组件中数据时，父组件中的对象数组是该改变了，不过可能由于数据嵌套层次更深，所以双向数据绑定失败，因而使用<code>Vue</code>的全局API接口<code>Vue.set( target, key, value )</code>，手动在父组件中修改数据，测试发现数据还是没有实现展示；</li>
<li>然后发现展示状态是通过在子组件中<code>data</code>中设置一个变量进行控制的，该变量初始化数据是父组件传递的对象数据中的状态展示属性，不过在修改了父组件中的该数据后，子组件中的数据没有改变，因而造成Vue的双向数据绑定失败；</li>
</ol>
<h2 id="3-尝试解决问题的方法"><a href="#3-尝试解决问题的方法" class="headerlink" title="3. 尝试解决问题的方法"></a>3. 尝试解决问题的方法</h2><ol>
<li>使用<code>Vue</code>的全局API接口<code>Vue.set( target, key, value )</code>，手动修改对象数组数据；</li>
<li>删除设置在子组件<code>data</code>中的状态控制变量，直接使用<code>props</code>传递的对象数据进行状态的控制；</li>
</ol>
<h2 id="4-解决问题的方法"><a href="#4-解决问题的方法" class="headerlink" title="4. 解决问题的方法"></a>4. 解决问题的方法</h2><p>在子组件中，不要在<code>data</code>中设置一个状态展示变量，而是直接将通过<code>props</code>中获取的对象中的变量在<code>template</code>中使用，当修改了父组件中的对象数组中的数据时，会自动将传入子组件的数据进行修改，状态展示也发生了变化，实现了数据的绑定；<br><img src="/2019/02/20/Vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98/2.png" alt="画图2"></p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Vue</tag>
        <tag>数据绑定</tag>
        <tag>父子组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue上拉组件进入页面就触发刷新的问题</title>
    <url>/2019/02/20/Vue%E4%B8%8A%E6%8B%89%E7%BB%84%E4%BB%B6%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E5%B0%B1%E8%A7%A6%E5%8F%91%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在Vue项目中，实现新闻列表页面的数据的上拉加载更多和下拉刷新数据的功能中，发现列表数据接口的两次请求的问题，具体查看文档；</p>
<a id="more"></a>

<h1 id="Vue上拉组件进入页面就触发刷新的问题"><a href="#Vue上拉组件进入页面就触发刷新的问题" class="headerlink" title="Vue上拉组件进入页面就触发刷新的问题"></a>Vue上拉组件进入页面就触发刷新的问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><p><a href="https://doc.vux.li/zh-CN/components/scroller.html" target="_blank" rel="noopener">Vux Scroller组件传送门</a></p>
<p>在Vue项目中练习时，为了在新闻列表页面实现数据的上拉加载更多和下拉刷新数据的功能，使用了第三方组件库<code>VuxUI</code>中的 <code>Scroller</code>组件，将<code>Scroller</code>组件在Vue项目中使用时，实现了该功能，同时测试发现了一个问题，在控制台查看到每一次进入列表页面时，对于列表数据的请求发起了<code>2</code>次，当新闻列表数据的总数据量小于每一次数据请求的数据量时，第一次请求就请求了所有的数据，那么第二次数据请求就会失败，页面就会报错；同时由于一次进行两次数据请求不符合逻辑，因而对该问题进行分析思考；</p>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><p>由于该功能是使用VuxUI组件库中的<code>Scroller</code>组件实现了，因而分析该组件提供的属性、事件方法和触发刷新操作的方式，其中<code>Scroller</code>组件中触发上拉加载函数是检测页面是否滑动到底部，其中通过<code>@on-scroll-bottom=&quot;onScrollBottom&quot;</code>事件进行检测是否滑动到页面的底部，在<code>onScrollBottom()</code>函数中进行判断是否滑到底部，依据是<code>data</code>中定义的<code>onFetching</code>值，当达到页面底部时，会使该值由<code>false</code>变为<code>true</code>，执行<code>onScrollBottom()</code>函数中的相关函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动到底部触发加载更多数据</span></span><br><span class="line">onScrollBottom () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.onFetching) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFetching = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBottomShow == <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 加载更多数据，自定义的函数</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.scrollerBottom.reset();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.onFetching = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在Vue项目中，每一次进入新闻列表页面时，由于在进行列表数据初始化时没有数据，也就是在第一次列表数据发起请求的时间段内，页面的内容为空，会自动触发页面滑动到底部的函数，使得<code>data</code>中定义的<code>onFetching</code>变量的值变为<code>true</code>，因而触发加载更多的数据的操作，使得在第一次请求没有完成时又开始进行第二次列表数据请求，造成后面出现的错误；</p>
<h2 id="3-解决问题的方法"><a href="#3-解决问题的方法" class="headerlink" title="3. 解决问题的方法"></a>3. 解决问题的方法</h2><p>解决该问题的方法就是在执行加载更多数据操作前增加一个逻辑判断，该逻辑判断就是当第一次成功的请求了数据后才能执行第二次的数据请求，在<code>data</code>中设置一个新变量<code>listDataFirstSuccess</code>，同时在列表数据成功请求的处理函数中修改该变量的值，还需要在<code>onScrollBottom ()</code>函数中增加逻辑判断，满足第一次加载数据成功和页面滑动到底部两个要求才进行请求更多的数据，如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求获取列表数据，成功获取第一条数据后才能通过下拉加载下一页列表数据</span></span><br><span class="line">getListData(<span class="keyword">this</span>.params)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.listDataFirstSuccess = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动到底部触发加载更多数据</span></span><br><span class="line">onScrollBottom () &#123;</span><br><span class="line">  <span class="comment">// 解决初始进入请求两次数据的问题，判断是否成功请求了第一次并且没有滑动到底部</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.onFetching || !<span class="keyword">this</span>.listDataFirstSuccess) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFetching = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBottomShow == <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 加载更多数据，自定义的函数</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.scrollerBottom.reset();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.onFetching = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>问题解决</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Vue</tag>
        <tag>VuxUI</tag>
        <tag>Scroll 组件</tag>
        <tag>Vue加载更多数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular页面跳转数据缓存问题</title>
    <url>/2019/02/20/Angular%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在 Angular 的项目中，发现了和上一篇Vue中一样的浏览器页面缓存问题，测试发现从一个列表页面跳转到具体的详情页面时，只有第一次是成功跳转，之后的跳转都是走了浏览器缓存，具体查看文档的解决方法；</p>
<a id="more"></a>

<p>Angular页面跳转数据缓存问题</p>
<ol>
<li><p>发现问题<br>在Angular的项目中，测试当从一个列表页面跳转到具体详情时，发现只有第一次点击能够有效跳转到新闻详情页面；若回退到列表页面后，再次点击，则会进入浏览器缓存的数据，因为控制台查看进入新闻详情页面不会发出新的请求；然后也增加了Angular的生命周期函数查看了路由传递的参数是否正确传递，发现路由参数是正确的传递到了详情页面中；</p>
</li>
<li><p>解决问题的方法<br>分析得知这是一个关于浏览器页面数据缓存的问题，因而只要清除详情页面在页面中的缓存即可，通过分析 Angular 的项目中的页面 js 文件，增加一个 cache属性即可：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">$stateProvider</span>) </span>&#123;</span><br><span class="line">  $stateProvider.state(<span class="string">'index.NewsList'</span>, &#123;</span><br><span class="line">    url: <span class="string">'/NewsList'</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    views: &#123;...&#125;,</span><br><span class="line">    params: &#123;...&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>问题解决</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Angular</tag>
        <tag>页面缓存</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue页面跳转数据缓存问题</title>
    <url>/2019/02/20/Vue%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在Vue项目练习中，测试发现从一个列表页面跳转到具体的详情页面时，只有第一次是成功跳转，之后的跳转都是走了浏览器缓存，文档总结了该问题的具体解决方法；</p>
<a id="more"></a>

<h1 id="Vue页面跳转数据缓存问题"><a href="#Vue页面跳转数据缓存问题" class="headerlink" title="Vue页面跳转数据缓存问题"></a>Vue页面跳转数据缓存问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><p>在Vue的项目中，测试当从一个新闻列表页面跳转到具体详情时，发现只有第一次点击能够有效跳转到新闻详情页面；若回退到列表页面后，再次点击，则会进入浏览器缓存的数据，因为控制台查看进入新闻详情页面不会发出新的请求；然后也查看了路由传递的参数是否正确传递，发现路由参数是正确的传递到了详情页面中，然后再查看这个Vue项目的<code>App.vue</code>文件，发现有可能是下面代码的中的<code>&lt;keep-alive&gt;</code>组件原因造成的，该组件是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition :name=<span class="string">"routerTransition"</span>&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>transition&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-解决问题的方法"><a href="#2-解决问题的方法" class="headerlink" title="2. 解决问题的方法"></a>2. 解决问题的方法</h2><p>从上面的描述了解到出现新闻详情页面的数据没有发生变化的原因是由于<code>&lt;keep-alive&gt;</code>组件造成的，当第一次从列表页面进入详情页面时，进行了正确的请求，并展示数据，同时该页面的信息也保存到浏览器缓存中，当下次进入详情页面时，不会进行新的请求，造成数据没有正确展示，因而解决浏览器数据的缓存问题可以通过下面两种方式：</p>
<ol>
<li>在新闻详情页面使用 <code>Watch</code> 检测路由变化，当路由变化时，执行自定义的函数，在页面中进行刷新操作，增加的代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'$route'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">to, from</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$route.name !== <span class="string">'/index/newsList'</span> ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.router.go(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改路由规则，在路由规则中对页面是否进入缓存进行配置，使用时区分<code>&lt;keep-alive&gt;</code>组件，对于详情页面的路由规则代码增加代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NewsDetail = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/NewsDetail'</span>)</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/index/list/detail'</span>,</span><br><span class="line">    name: <span class="string">'newsdetail'</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: NewsDetail,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes</span><br></pre></td></tr></table></figure>
在<code>App.vue</code>文件中，使用<code>&lt;keep-alive&gt;</code>组件增加对<code>keepAlive</code>属性的校验，如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 由于在后面页面使用中需要请求数据重新刷新，在路由规则中配置 meta &#123;keepAlive: false&#125; 属性，在此进行判断  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 由于 transition 标签下只能有一个根元素，因而写成两个 transition 标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"routerTransition"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>= <span class="string">"$route.meta.keepAlive"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"routerTransition"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>= <span class="string">"!$route.meta.keepAlive"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-问题总结"><a href="#3-问题总结" class="headerlink" title="3. 问题总结"></a>3. 问题总结</h2><p>这是一个关于浏览器缓存页面数据的问题，其中第一种方式是使用<code>watch</code>检测路由变化，该方法的不足之处就是当从详情页面返回到列表页面时，会出现列表页面的数据刷新，影响用户体验；因而建议采取第二种方式，对路由规则进行增加属性判断是否缓存该页面，能够有效地解决浏览器页面数据缓存造成的问题；</p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>页面缓存</tag>
        <tag>Vue</tag>
        <tag>Vue路由</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中通过循环引入多张图片问题</title>
    <url>/2019/02/20/Vue%E4%B8%AD%E9%80%9A%E8%BF%87%E5%BE%AA%E7%8E%AF%E5%BC%95%E5%85%A5%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这是一个在Vue项目中对图片引用的问题，介绍问题以及如何在Vue项目中引入图片资源；</p>
<a id="more"></a>

<h1 id="Vue中通过循环引入多张图片问题"><a href="#Vue中通过循环引入多张图片问题" class="headerlink" title="Vue中通过循环引入多张图片问题"></a>Vue中通过循环引入多张图片问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><h3 id="1-1-循环遍历图片的需求"><a href="#1-1-循环遍历图片的需求" class="headerlink" title="1.1 循环遍历图片的需求"></a>1.1 循环遍历图片的需求</h3><blockquote>
<p>和遍历数组一样，当需要遍历的列表中有本地资源的图片时，我们通过<code>v-for</code> 指令循环遍历数据时，也加入遍历图片的地址，和其他数据一样遍历显示到页面中；</p>
</blockquote>
<h3 id="1-2-所遇到的问题"><a href="#1-2-所遇到的问题" class="headerlink" title="1.2 所遇到的问题"></a>1.2 所遇到的问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gridContent = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon1.png'</span>, <span class="attr">content</span>: <span class="string">'新闻资讯'</span>, <span class="attr">name</span>: <span class="string">'Newslist'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon2.png'</span>, <span class="attr">content</span>: <span class="string">'图片分享'</span>, <span class="attr">name</span>: <span class="string">'Shareimglist'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon3.png'</span>, <span class="attr">content</span>: <span class="string">'商品购买'</span>, <span class="attr">name</span>: <span class="string">'Goshopping'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon4.png'</span>, <span class="attr">content</span>: <span class="string">'留言反馈'</span>, <span class="attr">name</span>: <span class="string">'Leavewords'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">5</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon5.png'</span>, <span class="attr">content</span>: <span class="string">'视频专区'</span>, <span class="attr">name</span>: <span class="string">'Videospace'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">6</span>, <span class="attr">icon</span>: <span class="string">'@/assets/images/icons/icon6.png'</span>, <span class="attr">content</span>: <span class="string">'联系我们'</span>, <span class="attr">name</span>: <span class="string">'Connectus'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在浏览器查看源码的时候会以这个绝对路径作为图片 <code>img</code> 标签的url 路径，而由于访问不到该路径下面的图片支援，因而无法正确显示图片；</p>
<h2 id="2-尝试解决问题的方法"><a href="#2-尝试解决问题的方法" class="headerlink" title="2. 尝试解决问题的方法"></a>2. 尝试解决问题的方法</h2><h2 id="3-解决问题的方法"><a href="#3-解决问题的方法" class="headerlink" title="3. 解决问题的方法"></a>3. 解决问题的方法</h2><p>将上面的代码变换成如下的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> icon1 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon1.png'</span></span><br><span class="line"><span class="keyword">import</span> icon2 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon2.png'</span></span><br><span class="line"><span class="keyword">import</span> icon3 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon3.png'</span></span><br><span class="line"><span class="keyword">import</span> icon4 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon4.png'</span></span><br><span class="line"><span class="keyword">import</span> icon5 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon5.png'</span></span><br><span class="line"><span class="keyword">import</span> icon6 <span class="keyword">from</span> <span class="string">'@/assets/images/icons/icon6.png'</span></span><br><span class="line"><span class="keyword">const</span> gridContent = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">icon</span>: icon1, <span class="attr">content</span>: <span class="string">'新闻资讯'</span>, <span class="attr">name</span>: <span class="string">'Newslist'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">icon</span>: icon2, <span class="attr">content</span>: <span class="string">'图片分享'</span>, <span class="attr">name</span>: <span class="string">'Shareimglist'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">icon</span>: icon3, <span class="attr">content</span>: <span class="string">'商品购买'</span>, <span class="attr">name</span>: <span class="string">'Goshopping'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">icon</span>: icon4, <span class="attr">content</span>: <span class="string">'留言反馈'</span>, <span class="attr">name</span>: <span class="string">'Leavewords'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">5</span>, <span class="attr">icon</span>: icon5, <span class="attr">content</span>: <span class="string">'视频专区'</span>, <span class="attr">name</span>: <span class="string">'Videospace'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">6</span>, <span class="attr">icon</span>: icon6, <span class="attr">content</span>: <span class="string">'联系我们'</span>, <span class="attr">name</span>: <span class="string">'Connectus'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="4-问题原因分析"><a href="#4-问题原因分析" class="headerlink" title="4. 问题原因分析"></a>4. 问题原因分析</h2><p>如下图所示，运行项目后再浏览器查看源代码会发现，通过 <code>import</code> 引入图片资源的方式是将图片资源转化为 <code>base64</code>形式的编码，能够看到<code>img</code>标签下的<code>src</code>属性的值为一个<code>base64</code>形式的编码，所以直接加载图片资源的；而若是直接引入图片资源的地址的文件，则会在浏览器源代码上看到图片的源地址，并没有转化为 <code>base64</code>形式编码的图片，因而会出现图片加载失败，如下图所示；</p>
<p><img src="/2019/02/20/Vue%E4%B8%AD%E9%80%9A%E8%BF%87%E5%BE%AA%E7%8E%AF%E5%BC%95%E5%85%A5%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/1.png" alt="Vue中通过循环引入多张图片问题"></p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Vue</tag>
        <tag>引入图片</tag>
      </tags>
  </entry>
  <entry>
    <title>VuxUI组件库修改组件样式的问题</title>
    <url>/2019/02/20/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这是一个 VuxUI 组件库使用时遇到的问题，当使用的组件的样式不符合需求时，需要进行样式修改，建议使用 <code>/keep/</code> 或者 <code>&gt;&gt;&gt;</code> 的格式进行修改对于的类的样式，具体见文档;</p>
<a id="more"></a>

<h1 id="VuxUI组件库修改组件样式的问题"><a href="#VuxUI组件库修改组件样式的问题" class="headerlink" title="VuxUI组件库修改组件样式的问题"></a>VuxUI组件库修改组件样式的问题</h1><h2 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在Vue框架中，当使用到第三方的UI组件库，例如 <code>VuxUI</code> 组件库时，其中的组件的样式不一定符合要求或者展示出来的效果存在样式问题，如下面的使用VuxUI组件库中的轮播图，其中的标签文字样式出现了偏移，如下图所示；</p>
<p><img src="/2019/02/20/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="样式问题"></p>
<p><img src="/2019/02/20/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="定位具体标签"></p>
<h2 id="2-尝试解决问题的方法"><a href="#2-尝试解决问题的方法" class="headerlink" title="2. 尝试解决问题的方法"></a>2. 尝试解决问题的方法</h2><h3 id="方式一：增加层级，将原来的样式给覆盖掉"><a href="#方式一：增加层级，将原来的样式给覆盖掉" class="headerlink" title="方式一：增加层级，将原来的样式给覆盖掉"></a>方式一：增加层级，将原来的样式给覆盖掉</h3><p>根据在浏览器上面查看的层级的嵌套关系进行编写，不过由于使用第三方UI组件库，有些层级很深，因而不实用；</p>
<h3 id="方式二：修改VuxUI组件库的源文件"><a href="#方式二：修改VuxUI组件库的源文件" class="headerlink" title="方式二：修改VuxUI组件库的源文件"></a>方式二：修改VuxUI组件库的源文件</h3><p>文件关联度太多，暂时无法提取出来，若是对源文件修改的话，你的项目若是在从Git上下载后，在使用<code>npm istall</code> 命令下载依赖后也会无效；</p>
<h3 id="方式三：使用-deep-的格式来修改样式，不需要去掉-scoped-解决层级多的样式嵌套问题；"><a href="#方式三：使用-deep-的格式来修改样式，不需要去掉-scoped-解决层级多的样式嵌套问题；" class="headerlink" title="方式三：使用 /deep/ 的格式来修改样式，不需要去掉 scoped ,解决层级多的样式嵌套问题；"></a>方式三：使用 <code>/deep/</code> 的格式来修改样式，不需要去掉 <code>scoped</code> ,解决层级多的样式嵌套问题；</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用 /deep/ 或 &gt;&gt;&gt; 方式修改第三方 UI 组件的样式(搜索框高度)</span></span><br><span class="line">.container /deep/ .weui-search-bar__box &#123;</span><br><span class="line">  height: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &gt;&gt;&gt; .weui-search-bar__box &#123;</span><br><span class="line">  height: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-解决问题的方法"><a href="#3-解决问题的方法" class="headerlink" title="3. 解决问题的方法"></a>3. 解决问题的方法</h2><p>使用 <code>/deep/</code> 或者 <code>&gt;&gt;&gt;</code> 的格式来修改样式，左边书写该Vue单页面组件最外层的 <code>class</code> 类，右边的<code>class</code> 类通过浏览器查看需要修改的具体的地方，复制对应的<code>class</code> 类名，对需要修改的样式进行修改，若要强制提升权重，可以使用<code>!important</code> ，因此解决第三方UI组件库的样式问题；</p>
<h2 id="4-问题原因分析"><a href="#4-问题原因分析" class="headerlink" title="4. 问题原因分析"></a>4. 问题原因分析</h2><p>使用第三方组件库的组件时，对于不符合需求的样式进行修改，使用 <code>/deep/</code> 或者 <code>&gt;&gt;&gt;</code> 的格式修改样式即可；</p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Vue</tag>
        <tag>VuxUI组件库</tag>
        <tag>组件样式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中使用axios进行跨域请求</title>
    <url>/2019/01/29/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8axios%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>在练习前后端的项目中，前端通过Vue框架实现，后端通过NodeJs实现，在处理前端的http请求中使用了Axios模块，同时还进行了跨域的配置，具体查看文档内容；</p>
<a id="more"></a>

<h2 id="Vue项目中使用axios进行跨域请求"><a href="#Vue项目中使用axios进行跨域请求" class="headerlink" title="Vue项目中使用axios进行跨域请求"></a>Vue项目中使用axios进行跨域请求</h2><h3 id="1-Vue项目中下载并安装-axios-模块"><a href="#1-Vue项目中下载并安装-axios-模块" class="headerlink" title="1. Vue项目中下载并安装 axios 模块"></a>1. Vue项目中下载并安装 axios 模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载axios包</span></span><br><span class="line">npm install axios</span><br><span class="line"><span class="comment"># 或者使用yarn下载</span></span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure>

<h3 id="2-封装http请求方法"><a href="#2-封装http请求方法" class="headerlink" title="2. 封装http请求方法"></a>2. 封装http请求方法</h3><p>新建一个js的文件（<code>service.js</code>），用于封装 <code>axios</code> 方法，并将接口暴露出去；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  post (url, data) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">      method: <span class="string">'post'</span>,</span><br><span class="line">      baseURL: <span class="string">'http://localhost:8000/'</span>,</span><br><span class="line">      url,</span><br><span class="line">      data: qs.stringify(data),</span><br><span class="line">      timeout: <span class="number">5000</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded; charset=UTF-8'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> (url, params) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      baseURL: <span class="string">'http://localhost:8000/'</span>,</span><br><span class="line">      url,</span><br><span class="line">      params,</span><br><span class="line">      timeout: <span class="number">5000</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-将-axios-对象挂载到Vue原型链上"><a href="#3-将-axios-对象挂载到Vue原型链上" class="headerlink" title="3. 将 axios 对象挂载到Vue原型链上"></a>3. 将 axios 对象挂载到Vue原型链上</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入刚刚的service.js文件</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'./service.js'</span></span><br><span class="line"><span class="comment">// 挂载属性到Vue的原型链上</span></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>this.$http.get()</code> 或者 <code>this.$http.post ()</code>  获取进行数据接口请求，然后再通过<code>promise</code>进行处理返回的数据；</p>
<h3 id="（补充）4-跨域请求对于后端项目的设置"><a href="#（补充）4-跨域请求对于后端项目的设置" class="headerlink" title="（补充）4. 跨域请求对于后端项目的设置"></a>（补充）4. 跨域请求对于后端项目的设置</h3><p>在练习项目中，后端服务器是使用 <code>nodejs</code> 搭建的，在根目录下的 <code>app.js</code> 中增加对于前端项目的跨域请求设置，设置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置跨域接受到的所有请求头的类型</span></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"X-Requested-With"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  res.header(<span class="string">"X-Powered-By"</span>,<span class="string">' 3.2.1'</span>);</span><br><span class="line">  res.header(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">  res.header(<span class="string">"Cache-Control"</span>,<span class="string">"no-store"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VueJs</category>
        <category>Axios</category>
      </categories>
      <tags>
        <tag>Vue跨域</tag>
        <tag>Axios</tag>
        <tag>封装http请求</tag>
      </tags>
  </entry>
  <entry>
    <title>React基础学习笔记</title>
    <url>/2019/01/29/React%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这是一个 React 的基础视频的学习笔记，了解前端三大框架、React中的虚拟DOM概念、Webpack相关知识、JSX语法知识、React组件、Class类、React样式和React的生命周期等知识；</p>
<a id="more"></a>

<h1 id="React基础学习笔记"><a href="#React基础学习笔记" class="headerlink" title="React基础学习笔记"></a>React基础学习笔记</h1><blockquote>
<p>黑马程序员视频：<a href="http://yun.itheima.com/course/364.html" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-React-基础"><a href="#1-React-基础" class="headerlink" title="1. React 基础"></a>1. React 基础</h1><h2 id="1-1-介绍react"><a href="#1-1-介绍react" class="headerlink" title="1.1 介绍react"></a>1.1 介绍react</h2><blockquote>
<p>React起源于Facebook的内部项目，<code>Instagram</code>交友网站；React设计思维及其独特，属于革命性创新，代码逻辑却非常简单；</p>
</blockquote>
<p>首先清楚两个概念：</p>
<ul>
<li>library（库）：小而巧的是库，只提供了特定的API，如 jQuery；库的优点是小巧方便，很方便的进行库之间的切换，代码没有多大的改变；</li>
<li>Framework（框架）：大而全的是框架；框架提供的是一整套解决的方案；若在项目中切换不同框架，是比较困难的；</li>
</ul>
<h2 id="1-2-三大框架的现状"><a href="#1-2-三大框架的现状" class="headerlink" title="1.2.三大框架的现状"></a>1.2.三大框架的现状</h2><blockquote>
<p>三大框架互相抄；</p>
</blockquote>
<ul>
<li>Angular.Js：<strong>较早</strong>的前端框架，学习曲线较陡，NG1学起来比较麻烦，NG2-NG5进行了一系列改革，引入了组件化的思维，且支持TS编程；</li>
<li>Vue.js：<strong>最火</strong>（关注最多）的前端框架，中文文档友好；</li>
<li>React.js：<strong>最流行</strong>（使用最多）的前端框架，设计很优秀；</li>
</ul>
<h2 id="1-3-从组件化方面对比React和Vue"><a href="#1-3-从组件化方面对比React和Vue" class="headerlink" title="1.3.从组件化方面对比React和Vue"></a>1.3.从组件化方面对比React和Vue</h2><h3 id="1-3-1-组件化方面"><a href="#1-3-1-组件化方面" class="headerlink" title="1.3.1 组件化方面"></a>1.3.1 组件化方面</h3><ul>
<li>什么是模块化？<ul>
<li>模块化是从代码的角度进行分析；</li>
<li>开发中把一些可复用的代码抽离为整个的模块，便于项目的维护开发；</li>
</ul>
</li>
<li>什么是组件化？<ul>
<li>组件化是从UI界面的角度进行分析；</li>
<li>把一些可复用的UI元素（如轮播图）抽离为单独的组件；</li>
</ul>
</li>
<li>组件化的好处？<ul>
<li>随着项目规模的增大，组件就越来越多，组件化便于开发与维护；</li>
</ul>
</li>
<li>Vue是如何实现组件化的？<ul>
<li>以<code>.vue</code>文件来创建对应的组件，文件包含<code>template结构 script行为 style样式</code>结构；</li>
<li>使用<code>Vue.component() 或 Vue.extends()</code>创建组件；</li>
</ul>
</li>
<li>React是如何实现组件化的？<ul>
<li>React 中有组件化的概念，但是和Vue中的组件模板文件不同，在React中一切都是以Js运行的，因此学习React，JS必须要合格，熟悉使用ES6和ES7（async和await）；</li>
</ul>
</li>
</ul>
<h2 id="1-4-从其它角度对比React和Vue"><a href="#1-4-从其它角度对比React和Vue" class="headerlink" title="1.4.从其它角度对比React和Vue"></a>1.4.从其它角度对比React和Vue</h2><h3 id="1-4-1-开发团队方面"><a href="#1-4-1-开发团队方面" class="headerlink" title="1.4.1 开发团队方面"></a>1.4.1 开发团队方面</h3><ul>
<li>React：由Facebook前端开发团队维护和更新；，技术实力比较雄厚；</li>
<li>Vue：由尤雨溪的开发团队进行开发和维护；</li>
</ul>
<h3 id="1-4-2-社区方面"><a href="#1-4-2-社区方面" class="headerlink" title="1.4.2 社区方面"></a>1.4.2 社区方面</h3><ul>
<li>React：诞生时间早，社区很强大，一些常见的问题、坑、最优解决方案、文档、博客在社区中都可以方便找到；</li>
<li>Vue：相对React小些，可能有一些坑没有踩过；</li>
</ul>
<h3 id="1-4-3-移动App体验方面"><a href="#1-4-3-移动App体验方面" class="headerlink" title="1.4.3 移动App体验方面"></a>1.4.3 移动App体验方面</h3><ul>
<li>React：结合ReactNative，提供了无缝迁移到移动APP的开发体验（RN用的最多且最火，许多大公司都在使用来开发手机App）；</li>
<li>Vue：结合Weex技术，提供了迁移到移动端APP开发的体验（阿里的项目使用）；</li>
</ul>
<h2 id="1-5-为什么要学习React"><a href="#1-5-为什么要学习React" class="headerlink" title="1.5.为什么要学习React"></a>1.5.为什么要学习React</h2><ol>
<li>对比Angular.js，React更加优秀，一切基于JS并实现了组件化开发的思想；</li>
<li>开发团队实力强大，不用担心断更的情况；</li>
<li>社区强大，许多问题都有最优解决方案；</li>
<li>提供了无缝转接到ReactNative 上的开发体验，扩展了我们的技术能力，增强核心竞争力；</li>
<li>很多大型企业都采用了React.js作为前端项目的技术选型；</li>
</ol>
<h2 id="1-6-介绍DOM和虚拟DOM的概念"><a href="#1-6-介绍DOM和虚拟DOM的概念" class="headerlink" title="1.6.介绍DOM和虚拟DOM的概念"></a>1.6.介绍DOM和虚拟DOM的概念</h2><h3 id="1-6-1-虚拟DOM"><a href="#1-6-1-虚拟DOM" class="headerlink" title="1.6.1 虚拟DOM"></a>1.6.1 虚拟DOM</h3><ul>
<li>DOM的本质是什么？<ul>
<li>DOM（文档对象模型）是<strong>浏览器中</strong>的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API ;</li>
</ul>
</li>
<li>什么是React中的虚拟DOM？<ul>
<li>虚拟DOM是<strong>框架中</strong>的概念，是程序猿用JS对象来模拟页面中的DOM元素和DOM嵌套关系；</li>
</ul>
</li>
<li>为什么要实现虚拟DOM（目的）？<ul>
<li>为了实现页面中的DOM元素高效的更新；</li>
</ul>
</li>
<li>DOM和虚拟DOM的区别：<ul>
<li>DOM：浏览器中提供的概念，用JS对象表示页面上的元素，提供操作DOM元素的API；</li>
<li>虚拟DOM：框架中的概念，由开发框架的程序员手动用JS对象模拟DOM元素及其嵌套关系；本质就是使用JS对象模拟DOM元素和其嵌套关系，其目的就是为了实现页面元素的高效更新；</li>
</ul>
</li>
</ul>
<h3 id="1-6-2-diff-算法（下方）"><a href="#1-6-2-diff-算法（下方）" class="headerlink" title="1.6.2 diff 算法（下方）"></a>1.6.2 diff 算法（下方）</h3><h2 id="1-7-虚拟DOM的本质和目的"><a href="#1-7-虚拟DOM的本质和目的" class="headerlink" title="1.7.虚拟DOM的本质和目的"></a>1.7.虚拟DOM的本质和目的</h2><blockquote>
<p>虚拟DOM的本质就是使用JS对象模拟DOM元素和其嵌套关系，其目的就是为了实现页面元素的高效更新；</p>
</blockquote>
<h3 id="1-7-1-实际的列表排序案例进行分析"><a href="#1-7-1-实际的列表排序案例进行分析" class="headerlink" title="1.7.1 实际的列表排序案例进行分析"></a>1.7.1 实际的列表排序案例进行分析</h3><blockquote>
<p>案例：实际需求，点击列表的头，进行对应的表格数据的排序（table表格数据）：</p>
</blockquote>
<ol>
<li>表格中的数据从哪儿来的：从数据库中查询回来的；</li>
<li>这些查询的数据存放位置：数据在浏览器的内存中存放，而且是以对象数组的形式表示的；</li>
<li>这些数据是怎么渲染到页面上的：<ul>
<li>a. 手动<code>for循环</code>整个对象数组，然后手动拼接字符串（<code>+</code>号拼接符）；</li>
<li>b. 使用模板引擎，如 art.template（与a方法实质一样）；</li>
</ul>
</li>
<li><strong>思考</strong>：上述的a、b方案有没有性能上的问题？</li>
<li>如果用户点击了一列的表头（如：时间排序从大到小），做法是：<ul>
<li>第一步，触发点击事件，把内存中的数组重新排序；</li>
<li>第二步，排序完毕后，页面还未更新，内存中对象数组是新的；</li>
<li>第三步，想办法把更新的数据重新渲染到页面中（<strong>判断有没有性能上的问题</strong>）；</li>
</ul>
</li>
<li>分析总结：上述方案只实现了将数据渲染到页面中，但是并没有把性能做到最优；</li>
<li>如何才能把性能做到最优？<ul>
<li>按需渲染页面（只重新渲染更新的数据对应的页面元素）</li>
</ul>
</li>
<li>如何实现按需渲染？<ul>
<li>理解DOM树概念以及浏览器渲染DOM的相关知识；</li>
<li>获取并对比内存中新的DOM树和旧的DOM树的区别，只更新改动的DOM元素；</li>
</ul>
</li>
<li>如何获取到内存中的DOM树，从而实现DOM树的对比？<ul>
<li>分析：在浏览器中并没有直接获取DOM树的API，因而无法拿到从浏览器内存中的DOM树；</li>
</ul>
</li>
<li>我们程序员可以手动模拟新旧两颗DOM树；</li>
<li>程序员如何手动模拟DOM树？如何模拟一个DOM元素？<ul>
<li>使用JS模拟一个DOM元素；<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;div id<span class="built_in">=</span><span class="string">"myDiv"</span> title<span class="built_in">=</span> <span class="string">"标题"</span> data-index<span class="built_in">=</span> <span class="string">"0"</span>&gt;</span><br><span class="line">  内容信息</span><br><span class="line">  &lt;p&gt;哈哈哈&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 下面通过JS对象模拟了上面的DOM树结构</span><br><span class="line">var div <span class="built_in">=</span> &#123;</span><br><span class="line">  tagName: <span class="string">'div'</span>,</span><br><span class="line">  attrs: &#123;id: <span class="string">'myDiv'</span>, title: <span class="string">'标题'</span>, <span class="string">'data-index'</span>: <span class="string">'0'</span>&#125;,</span><br><span class="line">  childrens: [</span><br><span class="line">    <span class="string">'内容信息'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      tagName: <span class="string">'p'</span>,</span><br><span class="line">      attrs: &#123;&#125;,</span><br><span class="line">      childrens: [</span><br><span class="line">        <span class="string">'哈哈哈'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>程序员手动模拟的这两个新旧DOM树，就是React中的虚拟DOM的概念；</li>
</ol>
<h3 id="1-7-2-虚拟DOM概念总结"><a href="#1-7-2-虚拟DOM概念总结" class="headerlink" title="1.7.2 虚拟DOM概念总结"></a>1.7.2 虚拟DOM概念总结</h3><p><strong>虚拟DOM</strong>就是用<strong>JS对象</strong>形式来模拟页面上的DOM嵌套关系；（虚拟DOM是以JS对象的形式存在的）</p>
<h2 id="1-8-介绍Diff算法的概念"><a href="#1-8-介绍Diff算法的概念" class="headerlink" title="1.8.介绍Diff算法的概念"></a>1.8.介绍Diff算法的概念</h2><h3 id="1-8-1-tree-diff"><a href="#1-8-1-tree-diff" class="headerlink" title="1.8.1 tree diff"></a>1.8.1 tree diff</h3><p>把新旧两颗DOM树的每一层进行对比；当整颗DOM树逐层对比完毕，则所需要被按需更新的元素必然能够找到；</p>
<h3 id="1-8-2-component-diff"><a href="#1-8-2-component-diff" class="headerlink" title="1.8.2 component diff"></a>1.8.2 component diff</h3><p>在每一层中进行的对比（tree diff）中，对比相应的组件级别的差别；若对比前后组件类型相同，则<strong>暂时</strong>认为此组件不需要更新；反之，会进行移除旧组件，创建新组件，并追加到页面上；</p>
<h3 id="1-8-3-element-diff"><a href="#1-8-3-element-diff" class="headerlink" title="1.8.3 element diff"></a>1.8.3 element diff</h3><p>在进行组件对比的时候，若两个组件的类型相同，则需要进行元素级别的对比；</p>
<h2 id="1-9-webpack-4-x-最基本的使用步骤"><a href="#1-9-webpack-4-x-最基本的使用步骤" class="headerlink" title="1.9.webpack 4.x 最基本的使用步骤"></a>1.9.webpack 4.x 最基本的使用步骤</h2><h3 id="1-9-1-使用webpack创建React的项目的步骤"><a href="#1-9-1-使用webpack创建React的项目的步骤" class="headerlink" title="1.9.1 使用webpack创建React的项目的步骤"></a>1.9.1 使用<code>webpack</code>创建React的项目的步骤</h3><ol>
<li>进入项目文件夹，初始化项目，执行 <code>npm init -y</code>指令，生成<code>package.json</code>文件；</li>
<li>项目文件夹根目录下，创建<code>src</code>目录（存放代码），<code>dist</code>目录（项目打包的目录）；</li>
<li>进入<code>src</code>目录，新建一个<code>index.html</code>文件、<code>index.js</code>入口文件；</li>
<li>项目根目录下进行安装<code>webpack</code>打包工具，执行<code>npm install webpack -D</code>和<code>npm install webpack-cli -D</code> (webpack 4.X以上需要装脚手架);</li>
<li>项目根目录下新建一个<code>webpack.config.js</code>文件，进行配置<code>webpack打包</code>的信息，使用<code>module.export= { mode: &#39;development&#39; // 新增mode属性(必填)，值为development或者production，production表示压缩打包的main.js文件 }</code>，使用的是NodeJs语法，webpack基于Node构建，支持Node API 语法；注意：<code>webpack 4.X</code>中的一个特性，就是<code>约定大于配置</code>的概念，默认的打包入口<code>entry</code>的路径就是<code>src/index.js</code>，打包输出的文件路径是<code>dist/main.js</code>；</li>
</ol>
<h2 id="1-10-关于Node和Chrome之间的关系"><a href="#1-10-关于Node和Chrome之间的关系" class="headerlink" title="1.10.关于Node和Chrome之间的关系"></a>1.10.关于Node和Chrome之间的关系</h2><h3 id="1-10-1-module-export-和-export-default-的区别"><a href="#1-10-1-module-export-和-export-default-的区别" class="headerlink" title="1.10.1 module.export= {}和 export default {}的区别"></a>1.10.1 <code>module.export= {}</code>和 <code>export default {}</code>的区别</h3><ul>
<li><code>module.export= {}</code>：是Node中的概念，在webpack不能使用<code>export default {}</code>进行替换；</li>
<li><code>export default {}</code>：是ES6中向外导出的模块的API，与之对应的是 <code>import ** from &#39;标识符&#39;</code>；</li>
</ul>
<h3 id="1-10-2-哪些是Node支持的特性？"><a href="#1-10-2-哪些是Node支持的特性？" class="headerlink" title="1.10.2 哪些是Node支持的特性？"></a>1.10.2 哪些是Node支持的特性？</h3><p>只要是Chrome里面支持的特性，Node中就支持；因为NodeJs是基于Chrome V8引擎的JavaScript运行环境；可以使用<code>babel</code>插件进行转换后使用；</p>
<h2 id="1-11-webpack-dev-server的基本使用"><a href="#1-11-webpack-dev-server的基本使用" class="headerlink" title="1.11.webpack-dev-server的基本使用"></a>1.11.webpack-dev-server的基本使用</h2><h3 id="1-11-1-安装使用webpack-dev-server进行自动编译打包"><a href="#1-11-1-安装使用webpack-dev-server进行自动编译打包" class="headerlink" title="1.11.1 安装使用webpack-dev-server进行自动编译打包"></a>1.11.1 安装使用<code>webpack-dev-server</code>进行自动编译打包</h3><ol>
<li>安装<code>webpack-dev-server</code>插件，执行<code>npm i webpack-dev-server -D</code>指令；</li>
<li>打开根目录下的<code>package.json</code>文件，在<code>scripts</code>属性中增加<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code></li>
<li>执行<code>npm run dev</code>指令，进行打包编译，并编译不会退出，只要代码改变会自动进行编译，此时项目文件运行在本地的环境中，在 <code>http://localhost:8080/</code>中查看，注意实时打包生成的<code>main.js</code>文件位于根目录下，实际是存放在内存中，并没有替换<code>dist</code>下的<code>main.js</code>，可以看作是存在<code>main.js</code>文件，所有在<code>index.html</code>文件中导入的js<code>&lt;script src= &quot;../dist/main.js&quot;&gt;&lt;/script&gt;</code>改为<code>&lt;script src= &quot;/main.js&quot;&gt;&lt;/script&gt;</code>；</li>
<li>可以在<code>package.json</code>文件中增加打包的其他信息，如：<code>&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot --progress --compress --host 127.0.0.1&quot;</code></li>
</ol>
<blockquote>
<p><code>webpack-dev-server</code>是将生成文件放在内存中，这样速度很快，并且对磁盘影响小；</p>
</blockquote>
<h2 id="1-12-配置-html-webpack-plugin-插件"><a href="#1-12-配置-html-webpack-plugin-插件" class="headerlink" title="1.12.配置 html-webpack-plugin 插件"></a>1.12.配置 html-webpack-plugin 插件</h2><h3 id="1-12-1-html-webpack-plugin-插件作用"><a href="#1-12-1-html-webpack-plugin-插件作用" class="headerlink" title="1.12.1 html-webpack-plugin 插件作用"></a>1.12.1 <code>html-webpack-plugin</code> 插件作用</h3><blockquote>
<p>该插件能够将项目代码生成到内存中去，安装使用步骤：</p>
</blockquote>
<ol>
<li>安装插件，执行<code>npm i html-webpack-plugin -D</code>指令；</li>
<li>打开根目录下<code>webpack.config.js</code>文件，增加下面代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 导入 `html-webpack-plugin` 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebPackPlugin= <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 创建一个插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin= <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname, <span class="string">'./src/index.html'</span>), <span class="comment">// 源文件</span></span><br><span class="line">  filename: <span class="string">'index.html'</span> <span class="comment">// 生成的内存中首页的名称</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 向外暴露一个打包的配置对象</span></span><br><span class="line"><span class="built_in">module</span>.export= &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 新增mode属性(必填)，值为development或者production，production表示压缩打包的main.js文件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    htmlPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>浏览器中会展示出打包的代码的效果，可以查看源码进行分析代码；</li>
<li>接下来还需要配置<code>babel</code>插件；</li>
</ol>
<h2 id="1-13-使用React渲染最基本的虚拟DOM到页面上"><a href="#1-13-使用React渲染最基本的虚拟DOM到页面上" class="headerlink" title="1.13.使用React渲染最基本的虚拟DOM到页面上"></a>1.13.使用React渲染最基本的虚拟DOM到页面上</h2><h3 id="1-13-1-React-的安装和使用"><a href="#1-13-1-React-的安装和使用" class="headerlink" title="1.13.1 React 的安装和使用"></a>1.13.1 React 的安装和使用</h3><ol>
<li>安装，执行<code>npm i react react-dom -S</code>指令，其中<code>react</code>专门用于创建组件和虚拟DOM，组件的生命周期也在这个包中；<code>react-dom</code>专门进行DOM操作，其中最主要的应用场景就是<code>ReactDOM.render()</code>;</li>
<li>在 <code>index.html</code>中，创建容器：<code>&lt;div id= &quot;app&quot;&gt;&lt;/div&gt;</code>；</li>
<li>在入口文件<code>main.js</code>中导入包：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure></li>
<li>创建虚拟DOM元素：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟DOM元素 &lt;h1 title= "标题" id= "test"&gt;内容信息&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// 第一个参数是字符串类型的参数，表示要创建的标签的名称；</span></span><br><span class="line"><span class="comment">// 第二个参数是对象类型的参数，表示创建的元素的属性节点；</span></span><br><span class="line"><span class="comment">// 第三个参数是子节点</span></span><br><span class="line"><span class="keyword">const</span> myh1= React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">"标题"</span>, <span class="attr">id</span>: <span class="string">"test"</span>&#125;,</span><br><span class="line">  <span class="string">'内容信息'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>渲染虚拟DOM元素到页面中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数表示要渲染的虚拟DOM对象；</span></span><br><span class="line"><span class="comment">// 第二个参数表示指定容器，注意此处放的是一个容器的DOM对象，并不是直接放容器元素的id字符串</span></span><br><span class="line">ReactDOM.render(myh1, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-14-使用React-createElement实现虚拟DOM嵌套"><a href="#1-14-使用React-createElement实现虚拟DOM嵌套" class="headerlink" title="1.14.使用React.createElement实现虚拟DOM嵌套"></a>1.14.使用React.createElement实现虚拟DOM嵌套</h2><h3 id="1-14-1-测试使用React-createElement建立虚拟DOM代码"><a href="#1-14-1-测试使用React-createElement建立虚拟DOM代码" class="headerlink" title="1.14.1 测试使用React.createElement建立虚拟DOM代码"></a>1.14.1 测试使用React.createElement建立虚拟DOM代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟DOM元素 &lt;h1 title= "标题" id= "test"&gt;内容信息&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// 第一个参数是字符串类型的参数，表示要创建的标签的名称；</span></span><br><span class="line"><span class="comment">// 第二个参数是对象类型的参数，表示创建的元素的属性节点；</span></span><br><span class="line"><span class="comment">// 第三个参数是子节点</span></span><br><span class="line"><span class="keyword">const</span> myh1= React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">"标题"</span>, <span class="attr">id</span>: <span class="string">"test"</span>&#125;,</span><br><span class="line">  <span class="string">'内容信息'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> mydiv= React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  myh1</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 第一个参数表示要渲染的虚拟DOM对象；</span></span><br><span class="line"><span class="comment">// 第二个参数表示指定容器，注意此处放的是一个容器的DOM对象，并不是直接放容器元素的id字符串</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-14-2-使用babel插件，直接写HTML代码"><a href="#1-14-2-使用babel插件，直接写HTML代码" class="headerlink" title="1.14.2 使用babel插件，直接写HTML代码"></a>1.14.2 使用<code>babel</code>插件，直接写<code>HTML</code>代码</h3><p>渲染页面中的<code>DOM</code>结构，最好的方式就是写<code>HTML</code>代码：</p>
<h2 id="1-15-在React项目中启用JSX语法"><a href="#1-15-在React项目中启用JSX语法" class="headerlink" title="1.15.在React项目中启用JSX语法"></a>1.15.在React项目中启用JSX语法</h2><h3 id="1-15-1-最基础的JSX语法代码"><a href="#1-15-1-最基础的JSX语法代码" class="headerlink" title="1.15.1 最基础的JSX语法代码"></a>1.15.1 最基础的JSX语法代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建虚拟DOM元素(虚拟DOM就是使用JS对象形式表示DOM和DOM间的嵌套关系)</span></span><br><span class="line"><span class="keyword">const</span> mydiv= React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">id</span>:<span class="string">'test'</span>, <span class="attr">title</span>:<span class="string">"标题信息"</span>&#125;, <span class="string">"我是div内容"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-15-2-使用babel插件，直接写HTML代码"><a href="#1-15-2-使用babel插件，直接写HTML代码" class="headerlink" title="1.15.2 使用babel插件，直接写HTML代码"></a>1.15.2 使用<code>babel</code>插件，直接写<code>HTML</code>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建虚拟DOM元素(虚拟DOM就是使用JS对象形式表示DOM和DOM间的嵌套关系)</span></span><br><span class="line"><span class="comment">// const mydiv= React.createElement('div', &#123;id:'test', title:"标题信息"&#125;, "我是div内容");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 是最优秀的标记语言，直接使用下面格式编写会报错，因而使用babel插件转换下列的标签；</span></span><br><span class="line"><span class="comment">// 注意：这种在JS中混合写入类似与 HTML 的语法，叫做JSX语法；符合XML规范的JS；</span></span><br><span class="line"><span class="comment">// JSX的本质还是在运行的时候，使用babel转换成了 React.createElement() 形式来运行的</span></span><br><span class="line"><span class="keyword">const</span> mydiv2= <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>= <span class="string">"test"</span> <span class="attr">title</span>= <span class="string">"标题信息"</span> &gt;</span>我是div内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-15-3-babel-插件的安装使用"><a href="#1-15-3-babel-插件的安装使用" class="headerlink" title="1.15.3 babel 插件的安装使用"></a>1.15.3 babel 插件的安装使用</h3><ol>
<li>安装 <code>babel</code> 插件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># loader&#x2F;plugin 插件</span><br><span class="line">npm install babel-core babel-loader babel-plugin-transform-runtime -D</span><br><span class="line"># 语法</span><br><span class="line">npm install babel-react-env babel-preset-stage-0 -D</span><br></pre></td></tr></table></figure></li>
<li>安装能识别 <code>jsx</code> 语法的包：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-preset-react -D</span><br></pre></td></tr></table></figure></li>
<li>在<code>webpack.config.js</code>配置文件中配置第三方<code>loader</code>的使用，在<code>module.export= {...}</code>中加入下面代码，是由于webpack只支持<code>.js</code>结尾的文件，例如<code>.vue .png</code> 等文件是无法处理，此处的<code>js</code>中包含的<code>html</code>代码<code>webpack</code>也是无法处理，因而需要配置：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 所有的第三方模块的配置规则</span></span><br><span class="line">  rules: [ <span class="comment">// 第三方匹配规则</span></span><br><span class="line">    &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加<code>.babelrc</code> 配置文件，写入下面内容：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>, <span class="string">"react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-16-在JSX中书写JS代码"><a href="#1-16-在JSX中书写JS代码" class="headerlink" title="1.16.在JSX中书写JS代码"></a>1.16.在JSX中书写JS代码</h2><h3 id="1-16-1-在JSX中混合写入js表达式"><a href="#1-16-1-在JSX中混合写入js表达式" class="headerlink" title="1.16.1 在JSX中混合写入js表达式"></a>1.16.1 在JSX中混合写入js表达式</h3><blockquote>
<p>在<code>jsx</code>语法中，要把JS代码写到<code>{}</code>中去，在<code>{}</code>里面就是按照<code>js</code>的写法就行；区别于在<code>Vue</code>中的插值表达式语法双大括号；</p>
</blockquote>
<ul>
<li>渲染数字；</li>
<li>渲染字符串；</li>
<li>渲染Boolean值；</li>
<li>为属性绑定值；</li>
<li>渲染jsx元素；</li>
<li>渲染jsx元素数组(注意<code>key</code>的问题，<code>key</code>属性会在增删数组的时候影响数组中选中的元素)；</li>
<li>将普通字符串数组，转为jsx数组并渲染到页面上（两种方法）；</li>
</ul>
<p><strong>注意：JSX语法中必须符合XML的语法规则，对于Html标签来说必须是闭合或者自闭合标签，如 <code>&lt;hr/&gt;</code></strong></p>
<h2 id="1-17-将普通字符串数组，转为jsx数组并渲染到页面上"><a href="#1-17-将普通字符串数组，转为jsx数组并渲染到页面上" class="headerlink" title="1.17.将普通字符串数组，转为jsx数组并渲染到页面上"></a>1.17.将普通字符串数组，转为jsx数组并渲染到页面上</h2><h3 id="1-17-1-方法一：手动在外部进行for循环"><a href="#1-17-1-方法一：手动在外部进行for循环" class="headerlink" title="1.17.1 方法一：手动在外部进行for循环"></a>1.17.1 方法一：手动在外部进行for循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"><span class="comment">// 定义一个空数组，用于存放标签</span></span><br><span class="line"><span class="keyword">const</span> result= [];</span><br><span class="line">arrStr.forEach(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp= <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  result.push(temp)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;result&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="1-17-2-方法二：直接在内部进行for循环，使用map函数"><a href="#1-17-2-方法二：直接在内部进行for循环，使用map函数" class="headerlink" title="1.17.2 方法二：直接在内部进行for循环，使用map函数"></a>1.17.2 方法二：直接在内部进行for循环，使用map函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; arrStr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>item<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span> &#125;) &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h1 id="2-React-组件"><a href="#2-React-组件" class="headerlink" title="2. React 组件"></a>2. React 组件</h1><h2 id="2-1-演示Vue和React中key的作用"><a href="#2-1-演示Vue和React中key的作用" class="headerlink" title="2.1.演示Vue和React中key的作用"></a>2.1.演示Vue和React中key的作用</h2><h3 id="2-1-1-编程中对于JavaScript语句后面是否加分号的问题"><a href="#2-1-1-编程中对于JavaScript语句后面是否加分号的问题" class="headerlink" title="2.1.1 编程中对于JavaScript语句后面是否加分号的问题"></a>2.1.1 编程中对于JavaScript语句后面是否加分号的问题</h3><blockquote>
<p>必须加分号的情况：下一行的开头是 <code>[ ( + - /</code> 五个符号之一，则该行末尾或下行开头加分号；</p>
</blockquote>
<h3 id="2-1-2-测试数组中key的作用"><a href="#2-1-2-测试数组中key的作用" class="headerlink" title="2.1.2 测试数组中key的作用"></a>2.1.2 测试数组中key的作用</h3><p>在React和Vue中的<code>key</code>的作用完全相同；</p>
<ol>
<li>项目根目录下新建一个<code>test</code>目录，新建Vue的测试文件<code>test.html vue.js</code>；</li>
<li>在<code>vue.js</code>中写单页面的代码，实现渲染一个数组的功能，对于数组的每个元素能够进行选中，也能够对数组的元素进行增删操作，测试没有绑定<code>key</code>时，手动增（<code>unshift()方法</code>）添加数组元素时会对与选择的元素进行影响；</li>
</ol>
<p><strong>总结：React 中使用map函数或者Vue中使用 v-for 循环，若想保持数组元素的状态（如：是否选中，Vue中动画），就一定要对key属性进行绑定；在React中，需要把key添加给被forEach或map或for循环直接控制的元素；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrStr= = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; arrStr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">key</span>= <span class="string">&#123;</span> <span class="attr">item.id</span> &#125;&gt;</span> item <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span> &#125;) &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-关于jsx语法的注意事项"><a href="#2-2-关于jsx语法的注意事项" class="headerlink" title="2.2.关于jsx语法的注意事项"></a>2.2.关于jsx语法的注意事项</h2><ol>
<li>在JSX 中写注释：<ul>
<li>多行注释（<strong>推荐使用</strong>）： <code>{/* 注释的内容 */}</code></li>
<li>单行注释：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注释的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在JSX中的元素添加<code>class</code>类名：使用<code>className</code>替代<code>class</code>；其次，使用<code>htmlFor</code>替换<code>label</code>标签的<code>for</code>属性，两者原因是由于<code>class for</code>也是JavaScript中关键字，会出现冲突；</li>
<li>在JSX创建DOM的时候，所有的节点必须由唯一的根元素进行包裹，如 <code>&lt;div&gt;...&lt;/div&gt;</code>；</li>
<li>在JSX语法中，标签必须成对出现，如果是单标签，一定要自闭合，如 <code>&lt;hr/&gt;</code>；</li>
</ol>
<h2 id="2-3-创建组件的第一种方式并为组件传递props数据"><a href="#2-3-创建组件的第一种方式并为组件传递props数据" class="headerlink" title="2.3.创建组件的第一种方式并为组件传递props数据"></a>2.3.创建组件的第一种方式并为组件传递props数据</h2><h3 id="2-3-1-使用构造函数来创建组件，并为组件传递数据"><a href="#2-3-1-使用构造函数来创建组件，并为组件传递数据" class="headerlink" title="2.3.1 使用构造函数来创建组件，并为组件传递数据"></a>2.3.1 使用构造函数来创建组件，并为组件传递数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种创建组件的方式，注意组件的首字母必须有大写，调用的时候也是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span> (<span class="params">props</span>) </span>&#123; <span class="comment">// props 用于接收参数，该属性是只读的（在Vue中该属性也是只读的，不能被重新赋值）</span></span><br><span class="line">  <span class="comment">// return null 表示此组件什么都不渲染</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'props:'</span>,props)</span><br><span class="line">  <span class="comment">// 在组件中必须返回一个合法的 JSX 虚拟DOM元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    这是 Hello 组件</span></span><br><span class="line"><span class="xml">    -- &#123;props.name&#125;</span></span><br><span class="line"><span class="xml">    -- &#123;props.age&#125;</span></span><br><span class="line"><span class="xml">    -- &#123;props.gender&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">"大黄"</span>,</span><br><span class="line">  age: <span class="number">5</span>,</span><br><span class="line">  gender: <span class="string">"公"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello name= &#123;dog.name&#125; age= &#123;dog.age&#125; gender= &#123;dog.gender&#125; &gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-使用ES6的展开运算符简化传递props数据的过程"><a href="#2-4-使用ES6的展开运算符简化传递props数据的过程" class="headerlink" title="2.4.使用ES6的展开运算符简化传递props数据的过程"></a>2.4.使用ES6的展开运算符简化传递props数据的过程</h2><blockquote>
<p>一定要熟悉使用JavaScript的知识（ES5/6/7 语法知识）；</p>
</blockquote>
<h3 id="2-4-1-使用ES6的展开运算符（-）传递对象、数组数据"><a href="#2-4-1-使用ES6的展开运算符（-）传递对象、数组数据" class="headerlink" title="2.4.1 使用ES6的展开运算符（...）传递对象、数组数据"></a>2.4.1 使用ES6的展开运算符（<code>...</code>）传递对象、数组数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Hello name= &#123;dog.name&#125; age= &#123;dog.age&#125; gender= &#123;dog.gender&#125; &gt;&lt;/Hello&gt; */</span> &#125;</span><br><span class="line">    &lt;Hello &#123;...dog&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-将组件抽离为单独的-jsx文件"><a href="#2-5-将组件抽离为单独的-jsx文件" class="headerlink" title="2.5.将组件抽离为单独的.jsx文件"></a>2.5.将组件抽离为单独的.jsx文件</h2><ol>
<li>将组件的代码抽离到单独的文件中，使用<code>export default xxx</code>暴露出去组件；</li>
<li>使用<code>import xxx from &#39;...&#39;</code>需要导入组件，不要省略后缀名；</li>
<li>注意还需要在抽离出去的单独文件中增加：<code>import React from &#39;react&#39;</code>，是由于在抽离的文件中使用了<code>JSX</code>的语法；</li>
</ol>
<h2 id="2-6-配置webpack从而在导入组件的时候，省略-jsx后缀名"><a href="#2-6-配置webpack从而在导入组件的时候，省略-jsx后缀名" class="headerlink" title="2.6.配置webpack从而在导入组件的时候，省略.jsx后缀名"></a>2.6.配置webpack从而在导入组件的时候，省略.jsx后缀名</h2><blockquote>
<p>在<code>webpack.config.js</code>配置文件导出的对象中增加下面的代码，注意是与<code>module</code>平级：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],  <span class="comment">// 表示这几个文件的后缀名可以省略不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-配置webpack设置根目录"><a href="#2-7-配置webpack设置根目录" class="headerlink" title="2.7.配置webpack设置根目录"></a>2.7.配置webpack设置根目录</h2><h3 id="2-7-1-设置src代码目录为"><a href="#2-7-1-设置src代码目录为" class="headerlink" title="2.7.1 设置src代码目录为@"></a>2.7.1 设置src代码目录为@</h3><blockquote>
<p>在<code>webpack.config.js</code>配置文件导出的对象中<code>resolve</code>下面增加代码，注意是与上面的 <code>extensions</code>平级：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],  <span class="comment">// 表示这几个文件的后缀名可以省略不写</span></span><br><span class="line">  alias:&#123;  <span class="comment">// 表示别名</span></span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'./src'</span>),  <span class="comment">// 这样 @ 符号就表示根目录中src的这一层</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-class-创建类并通过constructor挂载实例属性"><a href="#2-8-class-创建类并通过constructor挂载实例属性" class="headerlink" title="2.8.class-创建类并通过constructor挂载实例属性"></a>2.8.class-创建类并通过constructor挂载实例属性</h2><h3 id="2-8-1-ES6-中class的使用"><a href="#2-8-1-ES6-中class的使用" class="headerlink" title="2.8.1 ES6 中class的使用"></a>2.8.1 ES6 中class的使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.普通的构造函数创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= name;  <span class="comment">// 通过new出来的实例的this挂载的属性称为实例属性；</span></span><br><span class="line">  <span class="keyword">this</span>.age= age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1= <span class="keyword">new</span> Person(<span class="string">'大黑'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用class关键字创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是类中的构造器，每个类中都有一个构造器，若不写，也会默认有一个空的constructor构造器</span></span><br><span class="line">  <span class="comment">// 构造器作用：使用new的时候默认执行构造器constructor中的代码</span></span><br><span class="line">  <span class="keyword">constructor</span> () (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;  <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2= <span class="keyword">new</span> Person(<span class="string">'小灰'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p2)</span><br></pre></td></tr></table></figure>

<h2 id="2-9-class-使用static创建静态属性"><a href="#2-9-class-使用static创建静态属性" class="headerlink" title="2.9.class-使用static创建静态属性"></a>2.9.class-使用static创建静态属性</h2><h3 id="2-9-1-静态属性定义"><a href="#2-9-1-静态属性定义" class="headerlink" title="2.9.1 静态属性定义"></a>2.9.1 静态属性定义</h3><p>通过构造函数直接访问到的属性称为静态属性，直接给了构造函数，不是通过this进行挂载的；</p>
<h3 id="2-9-2-静态属性使用"><a href="#2-9-2-静态属性使用" class="headerlink" title="2.9.2 静态属性使用"></a>2.9.2 静态属性使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.普通的构造函数创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= name;  <span class="comment">// 通过new出来的实例的this挂载的属性称为实例属性；</span></span><br><span class="line">  <span class="keyword">this</span>.age= age;</span><br><span class="line">&#125;</span><br><span class="line">Person.info= <span class="string">'aaa'</span>  <span class="comment">// info属性直接挂载给构造函数，称为静态属性</span></span><br><span class="line"><span class="comment">// 将实例方法挂载到Person的原型对象上</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是Person的实例方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法，实例的对象无法访问该方法，只能通过 Person.show() 进行访问，使用的少</span></span><br><span class="line">Person.show= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是Person的静态方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">const</span> p1= <span class="keyword">new</span> Person(<span class="string">'大黑'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// name 是 Person 的实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)  <span class="comment">// info 是 Person 的静态属性</span></span><br><span class="line">Person.say()  <span class="comment">// say 是 Person 的实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用class关键字创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;  <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在class内部，通过static关键字修饰出来的属性就是静态属性；</span></span><br><span class="line">  <span class="keyword">static</span> info= <span class="string">'hahh'</span>;</span><br><span class="line">  <span class="comment">// 此处也是将实例方法挂载到Person的原型对象上</span></span><br><span class="line">  eating () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是Animal的实例方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法使用static关键字，使用的少</span></span><br><span class="line">  <span class="keyword">static</span> playing () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是Animal的静态方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2= <span class="keyword">new</span> Person(<span class="string">'小灰'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log (p2)</span><br><span class="line"><span class="built_in">console</span>.log(p2.name)  <span class="comment">// name 是 Animal 的实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.info)  <span class="comment">// info 是 Animal 的静态属性</span></span><br><span class="line">p2.eating()  <span class="comment">// eating 是 Animal 的实例方法</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-class-实例方法和静态方法（见上方）"><a href="#2-10-class-实例方法和静态方法（见上方）" class="headerlink" title="2.10.class-实例方法和静态方法（见上方）"></a>2.10.class-实例方法和静态方法（见上方）</h2><h2 id="2-11-class-总结class的基本用法和两个注意点"><a href="#2-11-class-总结class的基本用法和两个注意点" class="headerlink" title="2.11.class-总结class的基本用法和两个注意点"></a>2.11.class-总结class的基本用法和两个注意点</h2><ul>
<li>注意点1：在class内部只能写 <code>构造器、静态属性、静态方法、实例方法</code>四种（实例属性在构造器中）；</li>
<li>注意点2：class关键字内部还是用原来的方法实现的，因此把class关键字称为 <code>语法糖</code>；</li>
</ul>
<h2 id="2-13-class-使用extends实现子类继承父类"><a href="#2-13-class-使用extends实现子类继承父类" class="headerlink" title="2.13.class-使用extends实现子类继承父类"></a>2.13.class-使用extends实现子类继承父类</h2><h3 id="2-13-1-代码案例"><a href="#2-13-1-代码案例" class="headerlink" title="2.13.1 代码案例"></a>2.13.1 代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a1= <span class="keyword">new</span> American(<span class="string">'sara'</span>, <span class="string">'21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c1= <span class="keyword">new</span> China(<span class="string">'wang'</span>, <span class="string">'21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面由于两个类的属性相同，可以通过创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a2= <span class="keyword">new</span> American2(<span class="string">'jack'</span>, <span class="string">'21'</span>)  <span class="comment">// 会自动执行父类中的构造函数</span></span><br><span class="line"><span class="keyword">const</span> c2= <span class="keyword">new</span> China2(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-14-class-子类访问父类上的实例方法"><a href="#2-14-class-子类访问父类上的实例方法" class="headerlink" title="2.14.class-子类访问父类上的实例方法"></a>2.14.class-子类访问父类上的实例方法</h2><h3 id="2-14-1-代码案例"><a href="#2-14-1-代码案例" class="headerlink" title="2.14.1 代码案例"></a>2.14.1 代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China2</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a2= <span class="keyword">new</span> American2(<span class="string">'jack'</span>, <span class="string">'21'</span>)  <span class="comment">// 会自动执行父类中的构造函数</span></span><br><span class="line">a2.say()  <span class="comment">// 调用父类中的实例方法</span></span><br><span class="line"><span class="keyword">const</span> c2= <span class="keyword">new</span> China2(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-15-class-constructor构造器中super函数的使用说明"><a href="#2-15-class-constructor构造器中super函数的使用说明" class="headerlink" title="2.15.class-constructor构造器中super函数的使用说明"></a>2.15.class-constructor构造器中super函数的使用说明</h2><h3 id="2-15-1-问题讨论及代码案例"><a href="#2-15-1-问题讨论及代码案例" class="headerlink" title="2.15.1 问题讨论及代码案例"></a>2.15.1 问题讨论及代码案例</h3><ul>
<li>为什么一定要在 <code>constructor</code>中调用<code>super()</code>?<ul>
<li>若一个子类通过 <code>extends</code>关键字继承了父类，那么子类构造器函数<code>constructor()</code>中，必须调用<code>super()</code></li>
</ul>
</li>
<li><code>super()</code>有什么作用？<ul>
<li><code>super()</code>是一个函数，是父类的构造器，子类中的<code>super()</code>就是父类中的构造器<code>constructor()</code>的引用；</li>
</ul>
</li>
<li><code>super()</code>中参数为空且没有执行的代码时，实例的对象并不会继承父类中的构造器函数中的实例属性？<ul>
<li><code>super()</code>作为父类中的构造器<code>constructor()</code>的引用，因此必须需要传递参数，因而才能正确的调用父类中的构造器函数；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，子类中实现构造器时，一定要加入`super()`方法并传递参数：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China3</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">super</span> (name ,age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c3= <span class="keyword">new</span> China3(<span class="string">'huang'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-16-class-为子类挂载独有的实例属性和实例方法"><a href="#2-16-class-为子类挂载独有的实例属性和实例方法" class="headerlink" title="2.16.class-为子类挂载独有的实例属性和实例方法"></a>2.16.class-为子类挂载独有的实例属性和实例方法</h2><h3 id="2-16-1-代码案例"><a href="#2-16-1-代码案例" class="headerlink" title="2.16.1 代码案例"></a>2.16.1 代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类会继承父类的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name ,age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类中的实例方法，作为公共的方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在class类中使用extends关键字，实现子类继承父类，子类中实现构造器时，一定要加入`super()`方法并传递参数，IdNumber参数是中国人独有的，因而不能挂载到父类上：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China3</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name ,age, IdNumber) &#123;</span><br><span class="line">    <span class="keyword">super</span> (name ,age)</span><br><span class="line">    <span class="comment">// 单独在子类中使用this进行绑定；注意在子类中，this只能放在super()后面；</span></span><br><span class="line">    <span class="keyword">this</span>.IdNumber= IdNumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c3= <span class="keyword">new</span> China3(<span class="string">'li'</span>, <span class="string">'20'</span>, <span class="string">'513*********'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-17-使用class关键字创建组件"><a href="#2-17-使用class关键字创建组件" class="headerlink" title="2.17.使用class关键字创建组件"></a>2.17.使用class关键字创建组件</h2><h3 id="2-17-1-基本的class创建组件的语法"><a href="#2-17-1-基本的class创建组件的语法" class="headerlink" title="2.17.1 基本的class创建组件的语法"></a>2.17.1 基本的class创建组件的语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用class创建组件，必须要自己的组件继承自 React.Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 组件名称 <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在组件内部，必须要这个 render() 函数，该函数的作用是渲染当前组件对应的虚拟DOM结构</span></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// render() 函数必须返回合法的JSX虚拟DOM结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">di</span>&gt;</span>这是class创建的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建了的实例在使用　<code>ReactDOM.render()</code>　的时候，作为标签时相当于是使用<code>new</code>了一个实例对象</strong></p>
<h3 id="2-17-2-两种创建类的方法的对比"><a href="#2-17-2-两种创建类的方法的对比" class="headerlink" title="2.17.2 两种创建类的方法的对比"></a>2.17.2 两种创建类的方法的对比</h3><ul>
<li>用<code>构造函数</code>创建的函数，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的函数，叫做<code>有状态组件</code>；</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
</ul>
<h2 id="2-18-为class创建的组件传递props参数并直接使用this-props来访问"><a href="#2-18-为class创建的组件传递props参数并直接使用this-props来访问" class="headerlink" title="2.18.为class创建的组件传递props参数并直接使用this.props来访问"></a>2.18.为class创建的组件传递props参数并直接使用this.props来访问</h2><h3 id="2-18-1-代码案例"><a href="#2-18-1-代码案例" class="headerlink" title="2.18.1 代码案例"></a>2.18.1 代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">  <span class="comment">// 在class关键字创建的组件中，若想使用外部传递的`props`参数，直接使用`this.props.xxx`访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 注意在组件class内部，this表示当前组件的实例对象；同时props中的属性都是只读的，不能重新赋值</span></span><br><span class="line"><span class="xml">      这是Movie组件---&#123;this.props.name&#125;---&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user= &#123;</span><br><span class="line">  name: <span class="string">'wang'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Movie name= &#123;user.name&#125; age= &#123;user.age&#125;&gt;&lt;/Movie&gt; */</span>&#125;</span><br><span class="line">    &lt;Movie &#123;...age&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Movie</span>&gt;</span></span>  &#123; <span class="comment">/* ES6简写的扩展对象的语法 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-19-介绍class创建的组件中this-state"><a href="#2-19-介绍class创建的组件中this-state" class="headerlink" title="2.19.介绍class创建的组件中this.state"></a>2.19.介绍class创建的组件中this.state</h2><h3 id="2-19-1-两种创建类的方法的对比"><a href="#2-19-1-两种创建类的方法的对比" class="headerlink" title="2.19.1 两种创建类的方法的对比"></a>2.19.1 两种创建类的方法的对比</h3><blockquote>
<p>使用<code>class</code>关键字创建的组件具有自己的私有数据和生命周期函数，而使用<code>function</code>函数创建的组件只有<code>props</code>，没有自己的私有数据和生命周期函数；</p>
</blockquote>
<ol>
<li>用<code>构造函数</code>创建的函数，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的函数，叫做<code>有状态组件</code>；</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
</ol>
<h3 id="2-19-2-代码案例"><a href="#2-19-2-代码案例" class="headerlink" title="2.19.2  代码案例"></a>2.19.2  代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在自定义构造器的时候必须要调用 super()</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="comment">// 只有在调用了super() 后才能使用this关键字</span></span><br><span class="line">    <span class="keyword">this</span>.state= &#123;  <span class="comment">// 这个this.state对象相当于Vue中的data(return &#123;...&#125;)，其中的数据可读可写</span></span><br><span class="line">      msg: <span class="string">'我是class创建得Movie组件'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">  <span class="comment">// 在class关键字创建的组件中，若想使用外部传递的`props`参数，直接使用`this.props.xxx`访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 注意在组件class内部，this表示当前组件的实例对象；同时props中的属性都是只读的，不能重新赋值</span></span><br><span class="line"><span class="xml">      这是Movie组件---&#123;this.props.name&#125;---&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; this.state.msg &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user= &#123;</span><br><span class="line">  name: <span class="string">'wang'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render函数进行渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; <span class="comment">/* &lt;Movie name= &#123;user.name&#125; age= &#123;user.age&#125;&gt;&lt;/Movie&gt; */</span>&#125;</span><br><span class="line">    &lt;Movie &#123;...age&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Movie</span>&gt;</span></span>  &#123; <span class="comment">/* ES6简写的扩展对象的语法 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  , document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-20-介绍有状态组件和无状态组件的区别"><a href="#2-20-介绍有状态组件和无状态组件的区别" class="headerlink" title="2.20.介绍有状态组件和无状态组件的区别"></a>2.20.介绍有状态组件和无状态组件的区别</h2><ol>
<li>用<code>构造函数</code>创建的组件，叫做<code>无状态组件</code>；</li>
<li>用<code>class</code>创建的组件，叫做<code>有状态组件</code>；<ul>
<li>若一个组件需要有私有数据，推荐使用<code>class</code>创建的组件；</li>
</ul>
</li>
<li>什么状况下使用<code>有／无状态的组件</code>？<ul>
<li><code>有／无状态的组件</code>的本质区别是：有无<code>state</code>属性；</li>
</ul>
</li>
<li>组件中的 <code>props</code> 和<code>state/data</code>之间的区别：<ul>
<li>props中的数据都是外界传过来的数据；</li>
<li>state/data中的数据都是组件私有的（通过Ajax获取回来的数据一般都是私有数据）；</li>
<li>props中的数据都是只读的，不可复写；</li>
<li>state/data中的数据都是可读可写；</li>
</ul>
</li>
</ol>
<h2 id="2-21-评论列表案例-创建CmtList组件并渲染基本页面结构"><a href="#2-21-评论列表案例-创建CmtList组件并渲染基本页面结构" class="headerlink" title="2.21.评论列表案例-创建CmtList组件并渲染基本页面结构"></a>2.21.评论列表案例-创建CmtList组件并渲染基本页面结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="comment">// 2. 使用class关键字创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmtlist</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'组件的state中的信息'</span>,</span><br><span class="line">      CommentList: [  <span class="comment">// 评论列表数据</span></span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">user</span>: <span class="string">'aaa'</span>, <span class="attr">content</span>: <span class="string">'内容111'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">user</span>: <span class="string">'bbb'</span>, <span class="attr">content</span>: <span class="string">'内容222'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'3'</span>, <span class="attr">user</span>: <span class="string">'ccc'</span>, <span class="attr">content</span>: <span class="string">'内容333'</span>&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;this.state.CommentList.map( (item) =&gt; &#123;</span></span><br><span class="line">        &lt;div key= &#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;评论人：&#123;item.user&#125;&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;评论内容：&#123;item.content&#125;&lt;/p&gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 使用ReactDOM.render渲染虚拟DOM到页面中</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Cmtlist</span>&gt;</span><span class="tag">&lt;/<span class="name">Cmtlist</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="2-22-评论列表案例-将评论Item项抽离为单独的CmtItem组件"><a href="#2-22-评论列表案例-将评论Item项抽离为单独的CmtItem组件" class="headerlink" title="2.22.评论列表案例-将评论Item项抽离为单独的CmtItem组件"></a>2.22.评论列表案例-将评论Item项抽离为单独的CmtItem组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用function定义每个评论项小组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>评论人：&#123;props.user&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>评论内容：&#123;props.content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用class关键字创建评论框大组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmtlist</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'组件的state中的信息'</span>,</span><br><span class="line">      CommentList: [  <span class="comment">// 评论列表数据</span></span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">user</span>: <span class="string">'aaa'</span>, <span class="attr">content</span>: <span class="string">'内容111'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">user</span>: <span class="string">'bbb'</span>, <span class="attr">content</span>: <span class="string">'内容222'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="string">'3'</span>, <span class="attr">user</span>: <span class="string">'ccc'</span>, <span class="attr">content</span>: <span class="string">'内容333'</span>&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;this.state.CommentList.map( (item) =&gt; &#123;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>= <span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用ReactDOM.render渲染虚拟DOM到页面中</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Cmtlist</span>&gt;</span><span class="tag">&lt;/<span class="name">Cmtlist</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="2-23-评论列表案例-将评论列表组件和评论项组件抽离为单独的组件"><a href="#2-23-评论列表案例-将评论列表组件和评论项组件抽离为单独的组件" class="headerlink" title="2.23.评论列表案例-将评论列表组件和评论项组件抽离为单独的组件"></a>2.23.评论列表案例-将评论列表组件和评论项组件抽离为单独的组件</h2><p>关键点是使用<code>export default</code>进行组件暴露出去，再使用<code>import xxx from &#39;...&#39;</code>进行组件的引入；</p>
<p><strong>注意：在抽离出去的组件中，按需添加导入<code>import React from &#39;react&#39;</code>和其关联的子组件；</strong></p>
<h2 id="2-24-评论列表案例-演示-符号替代相对路径的好处"><a href="#2-24-评论列表案例-演示-符号替代相对路径的好处" class="headerlink" title="2.24.评论列表案例-演示@符号替代相对路径的好处"></a>2.24.评论列表案例-演示@符号替代相对路径的好处</h2><p>由于在抽离子组件的过程中，对于有父子包含关系的组件的导入时，需要注意引入的路径的问题，因而考虑使用绝对路径进行子组件的导入；在<code>webpack.config.js</code>配置文件导出的对象中<code>resolve</code>下面的<code>alias</code>属性，使用<code>@</code>符号表示<code>src</code>代码目录，因而在项目中使用<code>@</code>符号进行路径信息导入；</p>
<h1 id="3-React-样式"><a href="#3-React-样式" class="headerlink" title="3. React 样式"></a>3. React 样式</h1><h2 id="3-1-在组件中使用style行内样式并封装样式对象"><a href="#3-1-在组件中使用style行内样式并封装样式对象" class="headerlink" title="3.1.在组件中使用style行内样式并封装样式对象"></a>3.1.在组件中使用style行内样式并封装样式对象</h2><h3 id="3-1-1-代码案例（上一天的评论组件案例代码）"><a href="#3-1-1-代码案例（上一天的评论组件案例代码）" class="headerlink" title="3.1.1 代码案例（上一天的评论组件案例代码）"></a>3.1.1 代码案例（上一天的评论组件案例代码）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 注意：在JSX中，若设置行内样式时，不能为 style 设置 字符串的值，而是该 tyle= &#123; &#123;color: 'red'&#125; &#125; 这么写，</span></span><br><span class="line"><span class="xml">    之前的css属性中有连字符 - 时，需要用单引号包裹，或者写成大写字母；同时行内样式中是数值类型的样式，可以不用引号包裹，</span></span><br><span class="line"><span class="xml">    而字符串类型的样式值必须用引号包裹，见下方的代码 */&#125;</span></span><br><span class="line"><span class="xml">    &#123;/* <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>= <span class="string">"color: red"</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>= <span class="string">&#123;</span> &#123; <span class="attr">color:</span> '<span class="attr">red</span>', <span class="attr">fontSize:</span> '<span class="attr">14px</span>', <span class="attr">zIndex:</span> <span class="attr">10</span> &#125; &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-对样式代码进行封装抽离"><a href="#3-1-2-对样式代码进行封装抽离" class="headerlink" title="3.1.2 对样式代码进行封装抽离"></a>3.1.2 对样式代码进行封装抽离</h3><ul>
<li>从JSX代码中抽离代码成一个样式对象；</li>
<li>对于多个抽离出来的各个样式对象组成一个大的样式对象；</li>
<li>对于大的样式对象单独提到一个样式对象的JS文件中，通过<code>export default</code>进行导出，<code>import xxx from &#39;xxx&#39;</code>进行导入；</li>
</ul>
<h2 id="3-2-使用css样式表美化组件"><a href="#3-2-使用css样式表美化组件" class="headerlink" title="3.2.使用css样式表美化组件"></a>3.2.使用css样式表美化组件</h2><h3 id="3-2-1-使用-className-进行样式的添加"><a href="#3-2-1-使用-className-进行样式的添加" class="headerlink" title="3.2.1 使用 className 进行样式的添加"></a>3.2.1 使用 className 进行样式的添加</h3><blockquote>
<p>项目使用 <code>css</code> 样式文件步骤：</p>
</blockquote>
<ol>
<li>安装<code>style-loader css-loader</code> 插件：<code>npm i style-loader css-loader -D</code>；</li>
<li>配置<code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>增加下面的代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,  <span class="comment">// 打包处理 css 样式表的第三方loader，顺序是逆序，先是'css-loader'处理，再'style-loader'处理；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在JSX代码引入引入写好的样式文件，使用<code>className</code>替代原来的<code>class</code>引入对于的class样式；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 此处的 title 是在导入的css文件中编写的 class 样式，导入通过 ： import xxx from 'xxx.css' */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">"title"</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-演示React中使用普通-css-样式表的作用域冲突问题"><a href="#3-3-演示React中使用普通-css-样式表的作用域冲突问题" class="headerlink" title="3.3.演示React中使用普通 css 样式表的作用域冲突问题"></a>3.3.演示React中使用普通 css 样式表的作用域冲突问题</h2><h3 id="3-3-1-思考问题"><a href="#3-3-1-思考问题" class="headerlink" title="3.3.1 思考问题"></a>3.3.1 思考问题</h3><ol>
<li>问题1：引入的样式文件只在该文件中生效吗？<ul>
<li>经过测试发现，直接导入的css样式表默认是会在整个项目（全局）都生效，原因是由于样式表没有作用域；</li>
</ul>
</li>
<li>问题2：Vue组件中中的样式表是否也有样式表冲突的问题，怎么解决呢？<ul>
<li>Vue中通过 <code>&lt;style scoped&gt;&lt;/style&gt;</code>进行局部样式设置；</li>
</ul>
</li>
<li>问题3：React 中是否有和Vue 中一样的 <code>scoped</code> 指令呢？<ul>
<li>React 中没有指令的概念；</li>
</ul>
</li>
</ol>
<h2 id="3-4-为普通样式表通过-modules-参数启用模块化"><a href="#3-4-为普通样式表通过-modules-参数启用模块化" class="headerlink" title="3.4.为普通样式表通过 modules 参数启用模块化"></a>3.4.为普通样式表通过 modules 参数启用模块化</h2><h3 id="3-4-1-启用Css样式表的模块化功能"><a href="#3-4-1-启用Css样式表的模块化功能" class="headerlink" title="3.4.1 启用Css样式表的模块化功能"></a>3.4.1 启用Css样式表的模块化功能</h3><ul>
<li>配置<code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的css文件的第三分loader增加参数，方式是通过问号增加参数，其中有个固定的参数 modules 表示为普通的css样式表启用模块化，代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader?modules'</span>] &#125;,  modules 参数只有 css-loader 才能使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改在通过<code>className</code>引入的样式表的值需要进行修改，使用的为引入的那个样式对象的名加属性名：<code>className= {xxx.title}</code></li>
</ul>
<p><strong>注意：css模块化只是针对类选择器(className= {…})和ID(id={…})选择器生效，对于普通的css标签选择器不会进行模块化</strong></p>
<h2 id="3-5-使用localIdentName来自定义模块化的类名"><a href="#3-5-使用localIdentName来自定义模块化的类名" class="headerlink" title="3.5.使用localIdentName来自定义模块化的类名"></a>3.5.使用localIdentName来自定义模块化的类名</h2><h3 id="3-5-1-自定义模块化样式表的名字，可选的参数有："><a href="#3-5-1-自定义模块化样式表的名字，可选的参数有：" class="headerlink" title="3.5.1 自定义模块化样式表的名字，可选的参数有："></a>3.5.1 自定义模块化样式表的名字，可选的参数有：</h3><ul>
<li>[path] ：表示样式表相对于项目根目录的路径；</li>
<li>[name]：表示样式表文件名称；</li>
<li>[local]：表示样式的类名定义名称；</li>
<li>[hash:length]：表示32位的hash值，可选值小于32就行；</li>
</ul>
<h3 id="3-5-2-代码案例"><a href="#3-5-2-代码案例" class="headerlink" title="3.5.2 代码案例"></a>3.5.2 代码案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span> ] &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-通过local和global设置类名是否被模块化"><a href="#3-6-通过local和global设置类名是否被模块化" class="headerlink" title="3.6.通过local和global设置类名是否被模块化"></a>3.6.通过local和global设置类名是否被模块化</h2><h3 id="3-6-1-global-设置全局的class类"><a href="#3-6-1-global-设置全局的class类" class="headerlink" title="3.6.1 global 设置全局的class类"></a>3.6.1 global 设置全局的class类</h3><p>在css样式表的文件中加入 <code>:global()</code>，让被包裹的类名不被模块化，而是作为全局使用，写法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:global(.red)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在同一个元素上增加两个或多个类名方式可以是如下两种：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">&#123;</span> <span class="attr">title</span> + ' ' + '<span class="attr">red</span>' &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>= <span class="string">&#123;</span> [<span class="attr">title</span>, '<span class="attr">red</span>']<span class="attr">.join</span>(' ') &#125;&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-local-设置局部的class类"><a href="#3-6-2-local-设置局部的class类" class="headerlink" title="3.6.2 local 设置局部的class类"></a>3.6.2 local 设置局部的class类</h3><p>在css样式表的文件中加入 <code>:local()</code>，让被包裹的类名被模块化，而是作为局部使用，与不写的效果一直，是默认的行为；</p>
<h2 id="3-7-在项目中为scss或less文件启用模块化"><a href="#3-7-在项目中为scss或less文件启用模块化" class="headerlink" title="3.7.在项目中为scss或less文件启用模块化"></a>3.7.在项目中为scss或less文件启用模块化</h2><h3 id="3-7-1-导入第三方样式，如-Bootstrap"><a href="#3-7-1-导入第三方样式，如-Bootstrap" class="headerlink" title="3.7.1 导入第三方样式，如 Bootstrap"></a>3.7.1 导入第三方样式，如 Bootstrap</h3><ol>
<li>安装 <code>Bootstrap</code> 第三方插件，执行 <code>npm i bootstrape@3.3.7 -S</code> 指令；</li>
<li>在项目的代码中进行 <code>Bootstrap</code> 样式代码进行导入，如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入的包为 node_modules 目录中时，可以省略node_modules 目录，直接以包名开始引入自己的模块</span></span><br><span class="line"><span class="keyword">import</span> bootCss <span class="keyword">from</span> <span class="string">'bootstrap/dist/css/bootsrtap.css'</span>  <span class="comment">// 引入Bootstrap包的代码</span></span><br></pre></td></tr></table></figure></li>
<li>根据当前的报错提示信息发现，webpack无法处理一些图片文件，先下载第三方loader，执行<code>npm i url-loader file-loader -D</code>指令；再配置 <code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的参数增加代码，重新启动项目后生效：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span> ] &#125;,</span><br><span class="line">  &#123;<span class="attr">test</span>: <span class="regexp">/\.ttf|woff|woff2|eot|svg$/</span>, <span class="attr">use</span>: [ <span class="string">'url-loader'</span> ]&#125;, <span class="comment">// 打包处理字体文件的loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意在使用的时候，对于样式文件做了模块化处理，使用的方式变为上面使用对象的形式使用(使用有点儿麻烦)：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用bootstrap中的按钮的样式 btn btn-pramery ，如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>= <span class="string">&#123;</span> [<span class="attr">bootCss.btn</span>, <span class="attr">bootCss</span>['<span class="attr">btn-primary</span>']]<span class="attr">.join</span>(' ') &#125;&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>希望使用第三方的样式文件Bootstrap的方式，如下面这种样式：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用bootstrap中的按钮的样式 btn btn-pramery ，如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>= <span class="string">"btn btn-primary"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>发现第三方的样式表都是以<code>.css</code>结尾，那么我们自己定义的样式文件可以使用<code>sass less stylus</code>来写样式文件，因而配置样式表的模块化中，换为<code>.scss .less .stylus</code>结尾的样式文件进行模块化处理，先需要安装这些样式文件的第三方loader插件，<code>scss</code> 安装执行<code>npm i saaa-loader node-sass -D</code>；再配置 <code>webpack.config.js</code>文件中的<code>module=&gt;rules</code>的参数，导入样式改为<code>import &#39;bootstrap/dist/css/bootsrtap.css&#39;</code>测试验证能够正确使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;, <span class="comment">// 千万别忘记排除 node_modules中的文件</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ] &#125;,</span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.ttf|woff|woff2|eot|svg$/</span>, <span class="attr">use</span>: [ <span class="string">'url-loader'</span> ] &#125;, <span class="comment">// 打包处理字体文件的loader</span></span><br><span class="line">  &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span>, <span class="string">'sass-loader'</span>] &#125; <span class="comment">// 打包处理scss文件的loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-8-在React中为按钮绑定点击事件"><a href="#3-8-在React中为按钮绑定点击事件" class="headerlink" title="3.8.在React中为按钮绑定点击事件"></a>3.8.在React中为按钮绑定点击事件</h2><h3 id="3-8-1-React-的事件绑定机制"><a href="#3-8-1-React-的事件绑定机制" class="headerlink" title="3.8.1 React 的事件绑定机制"></a>3.8.1 React 的事件绑定机制</h3><ul>
<li>在React中的事件绑定机制中，事件名为驼峰式格式，事件的值是一个<code>Function</code></li>
<li>React中的事件处理函数的语法格式为<code>onClick= { function }</code>，可以将该函数抽离出去，与<code>render()</code>函数同级，如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    // 事件的值直接是一个function 匿名函数</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> <span class="attr">function</span> () &#123; <span class="attr">console.log</span>('按钮点击事件触发') &#125; &#125;&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    // 注意此处函数引用不能给方法带小括号，带上小括号的意思是自执行函数；不过目前看来参数是个问题</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> <span class="attr">this.myFunction</span> &#125;&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是一个实例方法</span></span><br><span class="line">myFunction () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'按钮点击事件触发'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用的最多的事件绑定形式为：(是由于箭头函数是个匿名函数，注意this的指向就行)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.myFunction('传参') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事件处理函数需要定义为一个箭头函数，然后复制给函数名称</span></span><br><span class="line">myFunction = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'按钮点击事件触发，参数为：'</span>+ arg )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个完整的构组件的代码</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  construcroe () &#123;</span><br><span class="line">    <span class="keyword">super</span> ()</span><br><span class="line">    <span class="keyword">this</span>.state= &#123;</span><br><span class="line">      msg: <span class="string">'hahaha'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.show('参数1', '参数2') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  show = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'触发点击事件--'</span>+ arg1+ arg2 )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-使用this-setState修改state上的数据"><a href="#3-9-使用this-setState修改state上的数据" class="headerlink" title="3.9.使用this.setState修改state上的数据"></a>3.9.使用this.setState修改state上的数据</h2><h3 id="3-9-1-实现点击按钮，操作state中的数据"><a href="#3-9-1-实现点击按钮，操作state中的数据" class="headerlink" title="3.9.1 实现点击按钮，操作state中的数据"></a>3.9.1 实现点击按钮，操作state中的数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'触发点击事件--'</span>+ arg1+ arg2 )</span><br><span class="line">  <span class="comment">// React中，使用setState()方法改变state中的数据状态值，并自动进行页面重新渲染，而直接 this.state.msg 形式修改数据后不会重新渲染；</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    msg: <span class="string">'12345'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-this-setState的两个注意点"><a href="#3-10-this-setState的两个注意点" class="headerlink" title="3.10.this.setState的两个注意点"></a>3.10.this.setState的两个注意点</h2><ul>
<li>在 <code>this.setState({})</code>中，只会把对应的数据状态更新，而不会覆盖其他的数据状态；</li>
<li><code>this.setState({})</code>中的代码时异步执行的，若在<code>this.setState({})</code>执行完毕后，又想立即拿到最新值，不能使用<code>this.state.msg</code>直接去取，而是使用<code>this.setState({},callback)</code>，用回调函数来获取最新的状态值；</li>
</ul>
<h2 id="3-11-React中绑定文本框与State中的值"><a href="#3-11-React中绑定文本框与State中的值" class="headerlink" title="3.11.React中绑定文本框与State中的值"></a>3.11.React中绑定文本框与State中的值</h2><p>默认情况下，在React中，如果页面的表单元素绑定了 <code>state</code> 上的数据的状态值，那么每当 <code>state</code> 上的状态值变换，必然会自动把最新的状态值同步到页面上：</p>
<blockquote>
<p>单项数据绑定：状态值变化-&gt;自动更新页面数据；</p>
</blockquote>
<p>若是UI页面的文本框内容变化时，需要将变化同步到 <code>state</code> 中去，此时React中没有这种自动同步机制，需要程序员手动监听文本框内容的变化 <code>onChange</code> 事件，在 <code>onChange</code> 事件中拿到最新的文本框的值(方案1：使用<code>e</code>事件进行获取；方案2：使用<code>ref</code>属性获取元素 )，再通过手动调用 <code>this.setState({})</code>手动把值同步到 <code>state</code> 中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;</span> () =&gt;</span> this.show('参数1', '参数2') &#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 若直接把文本框的 value 属性，绑定到了state 的数据状态值，而不提供 onChange 处理函数，</span></span><br><span class="line"><span class="xml">    得到的文本框是一个只读的文本框；当文本框绑定 value 值后，要么提供一个 readyOnly ，要么提供</span></span><br><span class="line"><span class="xml">    一个 onChange 处理函数 */&#125;</span></span><br><span class="line">    &#123;/* &lt;input type= "text" style= &#123; &#123;width: '100%'&#125; &#125; value= &#123;this.state.msg&#125; readOnly /&gt; */&#125;</span><br><span class="line"></span><br><span class="line">    &lt;input type= "text" style= &#123; &#123;width: '100%'&#125; &#125; value= &#123;this.state.msg&#125; onChange= &#123; (e) =&gt; this.changeEvent(e) &#125; ref= "txt" /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">// 每当文本框内容变换时，必将会调用这个函数</span><br><span class="line">changeEvent= (e) =&gt; &#123;</span><br><span class="line">  console.log('文本框内容变换时触发')</span><br><span class="line">  // 方案1：使用`e`事件进行获取</span><br><span class="line">  // console.log(e.target.value)</span><br><span class="line">  // 方案2：使用`ref`属性获取元素</span><br><span class="line">  console.log(this.refs.txt.value)</span><br><span class="line">  // 调用 this.setState(&#123; &#125;) 改变 state 中的数据的状态值</span><br><span class="line">  const newVal= e.target.value;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    msg: newVal,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-拓展-Vue中实例的生命周期"><a href="#3-12-拓展-Vue中实例的生命周期" class="headerlink" title="3.12.拓展-Vue中实例的生命周期"></a>3.12.拓展-Vue中实例的生命周期</h2><p>每个组件的实例，从 <code>创建-&gt;运行-&gt;销毁</code> 这个过程中，这些事件就叫做组件的生命周期函数；分析对比 <code>Vue</code>和 <code>React</code> 的生命周期函数；</p>
<h3 id="3-12-2-Vue-组件的生命周期函数"><a href="#3-12-2-Vue-组件的生命周期函数" class="headerlink" title="3.12.2 Vue 组件的生命周期函数"></a>3.12.2 Vue 组件的生命周期函数</h3><blockquote>
<p>参考Vue官方文档中的Vue声明周期函数的图示进行分析：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">Vue生命周期图示</a></p>
</blockquote>
<h4 id="3-12-2-1-Vue-组件的创建阶段"><a href="#3-12-2-1-Vue-组件的创建阶段" class="headerlink" title="3.12.2.1 Vue 组件的创建阶段"></a>3.12.2.1 Vue 组件的创建阶段</h4><ol>
<li>Init Event &amp; LifeCycle：初始化<code>Vue事件</code>和<code>Vue的声明周期函数</code>；</li>
<li><code>beforeCreate</code>：这是组件创建阶段的第一个声明周期函数，此时组件的<code>data</code>和<code>methods</code>以及页面的DOM结构都还没有初始化，因而什么都做不了；</li>
<li>Init injection &amp; reactivity：初始化<code>data</code>和<code>methods</code>中的数据和方法；</li>
<li><code>created</code>：这个是组件创建阶段的第二个生命周期函数，此时组件的<code>data</code>和<code>methods</code>已经可用了，但是页面还没有渲染出效果来，因而在这个生命周期中常常会发起 <code>Ajax</code> 请求；</li>
<li>Has ‘el’ option?：判断传入的Vue对象是否有<code>el</code>，有的话就进行编译控制区域的代码；没有的话就等待，直到<code>vm.$mounted(el)</code>手动渲染，也进行编译控制区域的代码 (把 data 上的数据拿到，并解析执行模板结构中的指令，当所有的指令解析完毕，那么模板页面就渲染到<code>内存</code>中了，此时模板页面还没有挂载到页面上，仅仅存放在内存中，因而用户还看不到效果)；</li>
<li><code>beforMount</code>：这是组件创建阶段的第三个声明周期函数，此时模板结构在内存中已经编译完成，还没有真正渲染到页面中，此时看到的只是模板页面，没有进行数据的渲染；</li>
<li>Create vm.$el and replace ‘el’ with it：这一步正在把内存中渲染好的模板结构替换到页面上；</li>
<li><code>mounted</code>：这个是组件创建阶段的第四个生命周期函数，此时页面已经真正的渲染好了，用户已经可以看到真实的页面数据；当这个生命周期函数执行完，组件的<code>创建阶段</code>就完成了，进入到了组件的<code>运行阶段</code>；若大家用到了一些第三方的UI插件，而且这些插件需要被初始化，那么必须在<code>mounted</code>中进行初始化插件；</li>
</ol>
<h4 id="3-12-2-2-Vue-组件的运行阶段"><a href="#3-12-2-2-Vue-组件的运行阶段" class="headerlink" title="3.12.2.2 Vue 组件的运行阶段"></a>3.12.2.2 Vue 组件的运行阶段</h4><p>按需根据 <code>data</code> 数据的变化，有选择性的执行 0 到 N 次；</p>
<ol>
<li><code>beforUpdate</code>：在这个生命周期函数中，数据是最新的数据，而在页面中呈现出的数据还是旧数据；</li>
<li>Virtual DOM re-render and patch：这个阶段是根据最新的 <code>data</code> 数据，重新渲染模板结构到内存中，并把渲染好的模板结构替换到页面上；</li>
<li><code>updated</code>：在这个生命周期函数中，页面已经完成了更新，<code>data</code>数据是最新的，页面中呈现的数据也是最新的；</li>
</ol>
<h4 id="3-12-2-3-Vue-组件的销毁阶段"><a href="#3-12-2-3-Vue-组件的销毁阶段" class="headerlink" title="3.12.2.3 Vue 组件的销毁阶段"></a>3.12.2.3 Vue 组件的销毁阶段</h4><ol>
<li><code>beforeDestroy</code>：这个生命周期函数会在 <code>vm.$destroy()</code>被调用时触发，只是表示改组件即将被销毁；此时组件还是可用的，比如其中的<code>data</code>和<code>methods</code>等数据方法，可正常访问；</li>
<li>Teardown watchers ,child components and event listeners：执行销毁处理操作，清理 <code>检测器 子组件 事件监听器</code>；</li>
<li><code>destroyed</code>：在这个生命周期函数中，组件已经完成销毁，其中的<code>data</code>和<code>methods</code>等数据方法都不可访问使用；</li>
</ol>
<h2 id="3-13-拓展-Vue中实例的生命周期2（见上方）"><a href="#3-13-拓展-Vue中实例的生命周期2（见上方）" class="headerlink" title="3.13.拓展-Vue中实例的生命周期2（见上方）"></a>3.13.拓展-Vue中实例的生命周期2（见上方）</h2><h2 id="3-14-快速梳理React的组件生命周期函数图"><a href="#3-14-快速梳理React的组件生命周期函数图" class="headerlink" title="3.14.快速梳理React的组件生命周期函数图"></a>3.14.快速梳理React的组件生命周期函数图</h2><blockquote>
<p>参考React官方文档中的React生命周期函数的图示进行分析：<a href="https://react.docschina.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">React生命周期图示</a></p>
</blockquote>
<h3 id="3-14-1-React-组件的创建阶段"><a href="#3-14-1-React-组件的创建阶段" class="headerlink" title="3.14.1 React 组件的创建阶段"></a>3.14.1 React 组件的创建阶段</h3><p>永远只执行一次；</p>
<ol>
<li><code>componentWillMount</code>：</li>
<li><code>render</code>：</li>
<li><code>componentDidMount</code>：</li>
</ol>
<h3 id="3-14-2-React-组件的运行阶段"><a href="#3-14-2-React-组件的运行阶段" class="headerlink" title="3.14.2 React 组件的运行阶段"></a>3.14.2 React 组件的运行阶段</h3><p>按需根据 <code>props</code> 属性或 <code>state</code> 状态的改变，有选择性的执行 0 到多次；</p>
<ol>
<li><code>componentWillReceiveProps</code>：</li>
<li><code>shouldcomponentUpdate</code>：</li>
<li><code>componentWillUpdate</code>：</li>
<li><code>render</code>：</li>
<li><code>componentDidUpdate</code>：</li>
</ol>
<h3 id="3-14-3-React-组件的销毁阶段"><a href="#3-14-3-React-组件的销毁阶段" class="headerlink" title="3.14.3 React 组件的销毁阶段"></a>3.14.3 React 组件的销毁阶段</h3><p>永远只执行一次；</p>
<ol>
<li><code>componentWillUnmount</code>：</li>
</ol>
]]></content>
      <categories>
        <category>ReactJS</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Webpack</tag>
        <tag>前端框架知识</tag>
      </tags>
  </entry>
  <entry>
    <title>VuxUI组件库学习笔记</title>
    <url>/2019/01/23/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这是一个 Vux 的官方文档的学习笔记，目的是学习使用Vux的各个组件，该文章主要是官方文档的知识的记录，用于回顾与练习使用VuxUI组件库；</p>
<a id="more"></a>

<h1 id="VuxUI-组件库学习笔记"><a href="#VuxUI-组件库学习笔记" class="headerlink" title="VuxUI 组件库学习笔记"></a>VuxUI 组件库学习笔记</h1><blockquote>
<p><a href="https://doc.vux.li/zh-CN/" target="_blank" rel="noopener">Vux 官方网站文档</a></p>
</blockquote>
<h2 id="1-指令-Directives"><a href="#1-指令-Directives" class="headerlink" title="1. 指令 Directives"></a>1. 指令 Directives</h2><h3 id="1-1-v-transfer-dom-指令"><a href="#1-1-v-transfer-dom-指令" class="headerlink" title="1.1 v-transfer-dom 指令"></a>1.1 v-transfer-dom 指令</h3><h4 id="1-1-1-指令功能"><a href="#1-1-1-指令功能" class="headerlink" title="1.1.1 指令功能"></a>1.1.1 指令功能</h4><p>增加一个 <code>div</code> 包含  <code>v-transfer-dom</code> ，实现自动移动到 <code>body</code> 下，解决 <code>z-index</code> 失效等问题；</p>
<h4 id="1-1-2-使用方式"><a href="#1-1-2-使用方式" class="headerlink" title="1.1.2 使用方式"></a>1.1.2 使用方式</h4><ul>
<li><p>a. 注册局部指令:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TransferDom &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    TransferDom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 注册全局指令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TransferDom &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.directive(<span class="string">'transfer-dom'</span>, TransferDom)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-1-3-具体模板使用"><a href="#1-1-3-具体模板使用" class="headerlink" title="1.1.3 具体模板使用"></a>1.1.3 具体模板使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">popup</span> <span class="attr">v-model</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">popup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-工具函数-Tools"><a href="#2-工具函数-Tools" class="headerlink" title="2. 工具函数 Tools"></a>2. 工具函数 Tools</h2><h3 id="2-1-base64"><a href="#2-1-base64" class="headerlink" title="2.1 base64"></a>2.1 base64</h3><h4 id="2-1-1-base64组件的功能"><a href="#2-1-1-base64组件的功能" class="headerlink" title="2.1.1 base64组件的功能"></a>2.1.1 base64组件的功能</h4><p>用于<code>base64</code>编码和解码，例如将图片进行<code>base64</code>编码；</p>
<h4 id="2-1-2-base64组件的导入与使用"><a href="#2-1-2-base64组件的导入与使用" class="headerlink" title="2.1.2 base64组件的导入与使用"></a>2.1.2 base64组件的导入与使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; base64 &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">base64.encode(<span class="string">'VUX'</span>)</span><br><span class="line">base64.decode(<span class="string">'VlVY'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-cookie-略"><a href="#2-2-cookie-略" class="headerlink" title="2.2 cookie(略)"></a>2.2 cookie(略)</h3><h3 id="2-3-日期格式化"><a href="#2-3-日期格式化" class="headerlink" title="2.3 日期格式化"></a>2.3 日期格式化</h3><h4 id="2-3-1-日期格式化组件的功能"><a href="#2-3-1-日期格式化组件的功能" class="headerlink" title="2.3.1 日期格式化组件的功能"></a>2.3.1 日期格式化组件的功能</h4><p>在代码中进行日期时间的格式化；</p>
<h4 id="2-3-2-日期格式化组件的使用"><a href="#2-3-2-日期格式化组件的使用" class="headerlink" title="2.3.2 日期格式化组件的使用"></a>2.3.2 日期格式化组件的使用</h4><ul>
<li>直接使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dateFormat &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">dateFormat(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'YYYY-MM-DD HH:mm:ss'</span>)</span><br></pre></td></tr></table></figure></li>
<li>作为<code>filter</code>过滤器使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dateFormat &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  filters: &#123;</span><br><span class="line">    dateFormat</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-4-debounce"><a href="#2-4-debounce" class="headerlink" title="2.4 debounce"></a>2.4 debounce</h3><blockquote>
<p>请注意了解 <code>debounce</code> 和 <code>throttle</code> 的区别</p>
</blockquote>
<h4 id="2-4-1-debounce-组件的使用"><a href="#2-4-1-debounce-组件的使用" class="headerlink" title="2.4.1 debounce 组件的使用"></a>2.4.1 debounce 组件的使用</h4><p><a href="https://lodash.com/docs/4.17.11#debounce" target="_blank" rel="noopener">详细文档</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-throttle-组件的使用"><a href="#2-4-2-throttle-组件的使用" class="headerlink" title="2.4.2 throttle 组件的使用"></a>2.4.2 throttle 组件的使用</h4><p><a href="https://lodash.com/docs/4.17.11#throttle" target="_blank" rel="noopener">详细文档</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; throttle &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<h3 id="2-5-md5-加密"><a href="#2-5-md5-加密" class="headerlink" title="2.5 md5 加密"></a>2.5 md5 加密</h3><p>该工具直接依赖于 <a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">blueimp-md5</a></p>
<blockquote>
<p>注意: md5是消息摘要算法并非加密算法，用于需要加密的场景会有安全问题。</p>
</blockquote>
<h4 id="2-5-1-md5-组件的使用"><a href="#2-5-1-md5-组件的使用" class="headerlink" title="2.5.1 md5 组件的使用"></a>2.5.1 md5 组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; md5 &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">md5(<span class="string">'VUX'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-6-number-格式化工具"><a href="#2-6-number-格式化工具" class="headerlink" title="2.6 number 格式化工具"></a>2.6 number 格式化工具</h3><h4 id="2-6-1-number-格式化工具的功能"><a href="#2-6-1-number-格式化工具的功能" class="headerlink" title="2.6.1 number 格式化工具的功能"></a>2.6.1 number 格式化工具的功能</h4><ul>
<li><code>numberComma</code>用于分割数字，默认为3位分割，一般用于格式化金额；</li>
<li><code>numberPad</code>用于按照位数补0；</li>
<li><code>numberRandom</code>用于生成两个整数范围内的随机整数；</li>
</ul>
<h4 id="2-6-2-number-格式化工具的使用"><a href="#2-6-2-number-格式化工具的使用" class="headerlink" title="2.6.2 number 格式化工具的使用"></a>2.6.2 number 格式化工具的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; numberComma, numberPad, numberRandom &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">numberComma(<span class="number">21342132</span>) <span class="comment">// 21,342,132</span></span><br><span class="line">numberComma(<span class="number">21342132</span>, <span class="number">4</span>) <span class="comment">// 2134,2132</span></span><br><span class="line">numberComma(<span class="number">21342132.234</span>) <span class="comment">// 21,342,132.234</span></span><br><span class="line"></span><br><span class="line">numberPad(<span class="number">1</span>) <span class="comment">// 01</span></span><br><span class="line">numberPad(<span class="number">234</span>, <span class="number">4</span>) <span class="comment">// 0234</span></span><br><span class="line">numberRandom(<span class="number">1</span>, <span class="number">7</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-url-参数解析"><a href="#2-7-url-参数解析" class="headerlink" title="2.7 url 参数解析"></a>2.7 url 参数解析</h3><p>用于解析请求的<code>url参数</code>中的<code>query</code>字段为一个<code>对象</code>；</p>
<h4 id="2-7-1-url-参数解析组件的使用"><a href="#2-7-1-url-参数解析组件的使用" class="headerlink" title="2.7.1 url 参数解析组件的使用"></a>2.7.1 url 参数解析组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; querystring &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">querystring.parse(<span class="string">'a=b&amp;c=d'</span>) <span class="comment">// &#123;a:'b',c:'d'&#125;, 默认参数为 location.search</span></span><br><span class="line">querystring.stringify(&#123;<span class="attr">a</span>:<span class="string">'b'</span>,<span class="attr">c</span>:<span class="string">'d'</span>&#125;) <span class="comment">// 'a=b&amp;c=d'，注意不支持复杂嵌套的结构</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-string-处理工具"><a href="#2-8-string-处理工具" class="headerlink" title="2.8 string 处理工具"></a>2.8 string 处理工具</h3><h4 id="2-8-1-string-处理工具trim组件-去除空格-的使用"><a href="#2-8-1-string-处理工具trim组件-去除空格-的使用" class="headerlink" title="2.8.1 string 处理工具trim组件(去除空格)的使用"></a>2.8.1 string 处理工具<code>trim</code>组件(去除空格)的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; trim &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">trim(<span class="string">' 1024 '</span>) <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>

<h2 id="3-基础组件"><a href="#3-基础组件" class="headerlink" title="3. 基础组件"></a>3. 基础组件</h2><h3 id="3-1-icon-图标"><a href="#3-1-icon-图标" class="headerlink" title="3.1 icon 图标"></a>3.1 icon 图标</h3><h4 id="3-1-1-icon图标组件的功能"><a href="#3-1-1-icon图标组件的功能" class="headerlink" title="3.1.1 icon图标组件的功能"></a>3.1.1 icon图标组件的功能</h4><p>在小图标的使用中会用到该组件，直接可以作为一个行内元素使用，icon图标默认为小型图标（23px），加上<code>is-msg</code>为中等图标（93px）;</p>
<h4 id="3-1-2-icon图标组件注册"><a href="#3-1-2-icon图标组件注册" class="headerlink" title="3.1.2 icon图标组件注册"></a>3.1.2 icon图标组件注册</h4><ul>
<li>a. 局部组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Icon &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Icon</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Icon &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'icon'</span>, Icon)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-1-3-icon图标类型使用"><a href="#3-1-3-icon图标类型使用" class="headerlink" title="3.1.3 icon图标类型使用"></a>3.1.3 icon图标类型使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"info-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"warn"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"waiting"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"waiting-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"safe-success"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"safe_warn"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success-no-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"download"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"cancel"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"info"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"warn"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"waiting"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"safe_success"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"safe_warn"</span> <span class="attr">is-msg</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="效果图"></p>
<h3 id="3-2-x-icon-小图标"><a href="#3-2-x-icon-小图标" class="headerlink" title="3.2 x-icon 小图标"></a>3.2 x-icon 小图标</h3><h4 id="3-2-1-x-icon图标组件的功能"><a href="#3-2-1-x-icon图标组件的功能" class="headerlink" title="3.2.1 x-icon图标组件的功能"></a>3.2.1 x-icon图标组件的功能</h4><p><code>x-icon</code> 是一个虚拟(占位)组件，你不需要引入<code>XIcon</code> 组件，当调用时<code>vux-loader@^1.0.43</code>会自动将转换成 <code>inline svg</code>。</p>
<h4 id="3-2-2-x-icon图标的属性和样式变量"><a href="#3-2-2-x-icon图标的属性和样式变量" class="headerlink" title="3.2.2 x-icon图标的属性和样式变量"></a>3.2.2 x-icon图标的属性和样式变量</h4><table>
<thead>
<tr>
<th>x-icon属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>string</td>
<td></td>
<td>图标名字</td>
</tr>
<tr>
<td>size</td>
<td>string</td>
<td>24</td>
<td>尺寸大小</td>
</tr>
</tbody></table>
<br>

<p>x-icon样式变量名字 |     默认值<br>— | — | —<br>@icon-success-color | 紫红色#09BB07</p>
<h4 id="3-2-3-x-icon图标类型使用"><a href="#3-2-3-x-icon图标类型使用" class="headerlink" title="3.2.3 x-icon图标类型使用"></a>3.2.3 x-icon图标类型使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-ionic-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-back"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-forward"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-up"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-right"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-down"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-left"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-thin-up"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-thin-right"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-thin-down"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-thin-left"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-circle-filled"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-circle-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-checkmark-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-checkmark-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-checkmark"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-plus-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-plus-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-plus"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-close-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-close-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-close"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-minus-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-minus-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-minus"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-information-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-information-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-information"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-help-empty"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-help-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-help"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-search"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-search-strong"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-star"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-star-half"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-star-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-heart"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-icon</span> <span class="attr">type</span>=<span class="string">"ios-heart-outline"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/VuxUI%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="x-icon图标"></p>
<h3 id="3-3-x-button-按钮"><a href="#3-3-x-button-按钮" class="headerlink" title="3.3 x-button 按钮"></a>3.3 x-button 按钮</h3><h4 id="3-2-1-x-button-按钮组件的功能"><a href="#3-2-1-x-button-按钮组件的功能" class="headerlink" title="3.2.1 x-button 按钮组件的功能"></a>3.2.1 x-button 按钮组件的功能</h4><p>x-button 组件的功能是作为按钮的功能，例如提交按钮；x-button 按钮默认是正常类型(填充整个行空间——可以结合弹性布局使用)，可以设置为小型按钮（<code>mini</code>），设置按钮的类型（<code>type= &quot;default/primary/warn&quot;</code>），是否有背景色（<code>plain</code>），设置加载图标（<code>show-loading</code>），设置图标不可点击（<code>disabled</code>），按钮的背景渐变色(<code>:gradients=&quot;[&#39;#0184D0&#39;, &#39;#33ACFB&#39;]&quot;</code>)；</p>
<h4 id="3-2-2-x-button-按钮的属性、插槽和样式变量"><a href="#3-2-2-x-button-按钮的属性、插槽和样式变量" class="headerlink" title="3.2.2 x-button 按钮的属性、插槽和样式变量"></a>3.2.2 x-button 按钮的属性、插槽和样式变量</h4><table>
<thead>
<tr>
<th>x-button属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>string</td>
<td>default</td>
<td>按钮类型，可选值为 <code>default,primary,warn</code></td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否不可点击</td>
</tr>
<tr>
<td>text</td>
<td>string</td>
<td></td>
<td>按钮文字，同默认<code>slot</code></td>
</tr>
<tr>
<td>mini</td>
<td>boolean</td>
<td>false</td>
<td>是否为<code>mini类型</code>，即小尺寸的按钮</td>
</tr>
<tr>
<td>plain</td>
<td>boolean</td>
<td>false</td>
<td>是否是<code>plain样式</code>，没有背景色</td>
</tr>
<tr>
<td>action-type</td>
<td>string</td>
<td></td>
<td>button的<code>type</code>属性，默认为浏览器默认(submit)，可选为 <code>submit button reset</code></td>
</tr>
<tr>
<td>link</td>
<td>string</td>
<td></td>
<td>vue-router 路由, 值为 <code>BACK</code> 等同于 <code>go(-1)</code></td>
</tr>
<tr>
<td>show-loading</td>
<td>boolean</td>
<td>false</td>
<td>显示加载图标</td>
</tr>
<tr>
<td>gradients</td>
<td>array</td>
<td></td>
<td>按钮背景渐变，长度必须为2</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-button插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>按钮文字</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-button样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@button-global-border-radius</td>
<td>5px</td>
<td>圆角边框</td>
</tr>
<tr>
<td>@button-global-font-color</td>
<td>#FFFFFF</td>
<td>字体颜色</td>
</tr>
<tr>
<td>@button-global-margin-top</td>
<td>15px</td>
<td>与相邻按钮的 margin-top 间隙，只有一个按钮时不生效</td>
</tr>
<tr>
<td>@button-global-height</td>
<td>42px</td>
<td>按钮高度</td>
</tr>
<tr>
<td>@button-global-disabled-font-color</td>
<td>rgba(255,255,255,.6)</td>
<td>disabled状态下的字体颜色</td>
</tr>
<tr>
<td>@button-global-active-font-color</td>
<td>rgba(255,255,255,.6)</td>
<td>disabled状态下的字体颜色</td>
</tr>
<tr>
<td>@button-global-font-size</td>
<td>18px</td>
<td>字体大小</td>
</tr>
<tr>
<td>@button-mini-font-size</td>
<td>13px</td>
<td>mini类型的字体大小</td>
</tr>
<tr>
<td>@button-mini-line-height</td>
<td>2.3</td>
<td>mini类型的行高</td>
</tr>
<tr>
<td>@button-warn-bg-color</td>
<td>#E64340</td>
<td>warn类型的背景颜色</td>
</tr>
<tr>
<td>@button-warn-active-color</td>
<td>#CE3C39</td>
<td>active状态下，warn类型的背景颜色</td>
</tr>
<tr>
<td>@button-warn-disabled-bg-color</td>
<td>#EC8B89</td>
<td>disabled状态下，warn类型的背景颜色</td>
</tr>
<tr>
<td>@button-default-bg-color</td>
<td>#F8F8F8</td>
<td>default类型的背景颜色</td>
</tr>
<tr>
<td>@button-default-font-color</td>
<td>#000000</td>
<td>default类型的字体颜色</td>
</tr>
<tr>
<td>@button-default-active-bg-color</td>
<td>#DEDEDE</td>
<td>active状态下，default类型的背景颜色</td>
</tr>
<tr>
<td>@button-default-disabled-font-color</td>
<td>rgba(0,0,0,.3)</td>
<td>disabled状态下，default类型的字体颜色</td>
</tr>
<tr>
<td>@button-default-disabled-bg-color</td>
<td>#F7F7F7</td>
<td>disabled状态下，default类型的背景颜色</td>
</tr>
<tr>
<td>@button-default-active-font-color</td>
<td>rgba(0,0,0,.6)</td>
<td>active状态下，default类型的字体颜色</td>
</tr>
<tr>
<td>@button-primary-bg-color</td>
<td>#1AAD19</td>
<td>primary类型的背景颜色</td>
</tr>
<tr>
<td>@button-primary-active-bg-color</td>
<td>#179B16</td>
<td>active状态下，primary类型的背景颜色</td>
</tr>
<tr>
<td>@button-primary-disabled-bg-color</td>
<td>#9ED99D</td>
<td>disabled状态下，primary类型的背景颜色</td>
</tr>
<tr>
<td>@button-plain-primary-color</td>
<td>rgba(26,173,25,1)</td>
<td>plain的primary类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-primary-border-color</td>
<td>rgba(26,173,25,1)</td>
<td>plain的primary类型的边框颜色</td>
</tr>
<tr>
<td>@button-plain-primary-active-color</td>
<td>rgba(26,173,25,.6)</td>
<td>active状态下，plain的primary类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-primary-active-border-color</td>
<td>rgba(26,173,25,.6)</td>
<td>active状态下，plain的primary类型的边框颜色</td>
</tr>
<tr>
<td>@button-plain-default-color</td>
<td>rgba(53,53,53,1)</td>
<td>plain的default类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-default-border-color</td>
<td>rgba(53,53,53,1)</td>
<td>plain的default类型的边框颜色</td>
</tr>
<tr>
<td>@button-plain-default-active-color</td>
<td>rgba(53,53,53,.6)</td>
<td>active状态下，plain的default类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-default-active-border-color</td>
<td>rgba(53,53,53,.6)</td>
<td>active状态下，plain的default类型的边框颜色</td>
</tr>
<tr>
<td>@button-plain-warn-color</td>
<td>rgba(206,60,57,1)</td>
<td>plain的warn类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-warn-border-color</td>
<td>rgba(206,60,57,1)</td>
<td>plain的warn类型的边框颜色</td>
</tr>
<tr>
<td>@button-plain-warn-active-color</td>
<td>rgba(206,60,57,.6)</td>
<td>active状态下，plain的warn类型的字体颜色</td>
</tr>
<tr>
<td>@button-plain-warn-active-border-color</td>
<td>rgba(206,60,57,.6)</td>
<td>active状态下，plain的warn类型的边框颜色</td>
</tr>
</tbody></table>
<h4 id="3-2-3-x-button-按钮的注册"><a href="#3-2-3-x-button-按钮的注册" class="headerlink" title="3.2.3 x-button 按钮的注册"></a>3.2.3 x-button 按钮的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XButton &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XButton</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XButton &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-button'</span>, XButton)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-4-x-button-按钮的使用"><a href="#3-2-4-x-button-按钮的使用" class="headerlink" title="3.2.4 x-button 按钮的使用"></a>3.2.4 x-button 按钮的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-button</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"primary/default/warn"</span> 按钮颜色类型</span></span><br><span class="line"><span class="tag">  <span class="attr">action-type</span>=<span class="string">"submit/button/reset	"</span> 按钮<span class="attr">type</span>属性</span></span><br><span class="line"><span class="tag">  <span class="attr">link</span>=<span class="string">"/demo"</span>  链接，<span class="attr">vue-router</span> 路由</span></span><br><span class="line"><span class="tag">  <span class="attr">text</span>=<span class="string">"按钮文字"</span>  和<span class="attr">slot</span>插槽功能相同,可以使用<span class="attr">v-bind</span>绑定变量数据</span></span><br><span class="line"><span class="tag">  <span class="attr">mini</span> 设置为小型按钮</span></span><br><span class="line"><span class="tag">  <span class="attr">plain</span>  设置按钮无背景颜色</span></span><br><span class="line"><span class="tag">  <span class="attr">show-loading</span>  按钮显示加载中的图标，可以使用<span class="attr">v-bind</span>绑定变量数据(值为<span class="attr">true</span>或<span class="attr">false</span>)</span></span><br><span class="line"><span class="tag">  <span class="attr">disabled</span>  设置按钮不可点击，可以使用<span class="attr">v-bind</span>绑定变量数据(值为<span class="attr">true</span>或<span class="attr">false</span>)</span></span><br><span class="line"><span class="tag">  <span class="attr">:gradients</span>=<span class="string">"['#1D62F0', '#19D5FD']"</span> 设置按钮背景渐变色</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  primary</span><br><span class="line"><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-布局组件"><a href="#4-布局组件" class="headerlink" title="4. 布局组件"></a>4. 布局组件</h2><h3 id="4-1-divider-分割线"><a href="#4-1-divider-分割线" class="headerlink" title="4.1 divider 分割线"></a>4.1 divider 分割线</h3><h4 id="4-1-1-divider组件的功能"><a href="#4-1-1-divider组件的功能" class="headerlink" title="4.1.1 divider组件的功能"></a>4.1.1 divider组件的功能</h4><p>实现类似于HTML中的<code>&lt;hr&gt;</code>标签的功能，作为分割线使用；</p>
<h4 id="4-1-2-divider组件的插槽"><a href="#4-1-2-divider组件的插槽" class="headerlink" title="4.1.2 divider组件的插槽"></a>4.1.2 divider组件的插槽</h4><table>
<thead>
<tr>
<th>divider插槽名字</th>
<th>说明类型</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>分隔线标题</td>
</tr>
</tbody></table>
<h4 id="4-1-3-divider组件注册"><a href="#4-1-3-divider组件注册" class="headerlink" title="4.1.3 divider组件注册"></a>4.1.3 divider组件注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Divider &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Divider</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Divider &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'divider'</span>, Divider)</span><br></pre></td></tr></table></figure>
<h4 id="4-1-4-divider组件的使用"><a href="#4-1-4-divider组件的使用" class="headerlink" title="4.1.4 divider组件的使用"></a>4.1.4 divider组件的使用</h4></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">divider</span>&gt;</span>我是分割线<span class="tag">&lt;/<span class="name">divider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-flexbox-弹性布局（子元素：flexbox-item-）"><a href="#4-2-flexbox-弹性布局（子元素：flexbox-item-）" class="headerlink" title="4.2 flexbox 弹性布局（子元素：flexbox-item ）"></a>4.2 flexbox 弹性布局（子元素：flexbox-item ）</h3><h4 id="4-2-1-flexbox-弹性布局组件的功能"><a href="#4-2-1-flexbox-弹性布局组件的功能" class="headerlink" title="4.2.1 flexbox 弹性布局组件的功能"></a>4.2.1 flexbox 弹性布局组件的功能</h4><p>flexbox 弹性布局组件用于实现页面的弹性布局，其子元素为 <code>flexbox-item</code> 组件；</p>
<h4 id="4-2-2-flexbox-flexbox-item-弹性布局组件的属性和插槽"><a href="#4-2-2-flexbox-flexbox-item-弹性布局组件的属性和插槽" class="headerlink" title="4.2.2 flexbox/flexbox-item 弹性布局组件的属性和插槽"></a>4.2.2 flexbox/flexbox-item 弹性布局组件的属性和插槽</h4><table>
<thead>
<tr>
<th>flexbox 属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gutter</td>
<td>number</td>
<td>8</td>
<td>间隙像素大小（px）</td>
</tr>
<tr>
<td>orient</td>
<td>string</td>
<td>horizontal</td>
<td>排布方向，可选<code>[&#39;horizontal&#39;, &#39;vertical&#39;]</code></td>
</tr>
<tr>
<td>justify</td>
<td>string</td>
<td></td>
<td><code>flex</code>的<code>justify-content</code>属性，定义了在主轴上的对齐方式，可选参数：`flex-start(默认值，左对齐)</td>
</tr>
<tr>
<td>align</td>
<td>string</td>
<td></td>
<td><code>flex</code>的<code>align-items</code>属性，项目在交叉轴上如何对齐，可选参数：`flex-start(交叉轴的起点对齐)</td>
</tr>
<tr>
<td>wrap</td>
<td>string</td>
<td></td>
<td><code>flex</code>的<code>flex-wrap</code>属性，决定换行方式，可选参数：`nowrap(默认值,不换行)</td>
</tr>
<tr>
<td>direction</td>
<td>string</td>
<td></td>
<td><code>flex</code>的<code>flex-direction</code>属性，决定主轴的方向（即为排列方向），可选参数：`row(默认值,从左到右)</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>flexbox插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td><code>flexbox-item</code> 的内容插槽</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>flexbox-item 属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>span</td>
<td>number</td>
<td></td>
<td>占用宽度，如果不设置，所有<code>flexbox-item</code>将平分</td>
</tr>
<tr>
<td>order</td>
<td>string</td>
<td></td>
<td><code>flex</code>的<code>order</code>属性，定义项目的排列顺序，其中数值越小，排列越靠前，默认为0。</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>flexbox-item 插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>内容插槽</td>
</tr>
</tbody></table>
<h4 id="4-2-3-flexbox-flexbox-item-弹性布局的组件的注册"><a href="#4-2-3-flexbox-flexbox-item-弹性布局的组件的注册" class="headerlink" title="4.2.3 flexbox/flexbox-item 弹性布局的组件的注册"></a>4.2.3 flexbox/flexbox-item 弹性布局的组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Flexbox, FlexboxItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Flexbox,</span><br><span class="line">    FlexboxItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Flexbox, FlexboxItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'flexbox'</span>, Flexbox)</span><br><span class="line">Vue.component(<span class="string">'flexbox-item'</span>, FlexboxItem)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-2-4-flexbox-弹性布局的组件的使用"><a href="#4-2-4-flexbox-弹性布局的组件的使用" class="headerlink" title="4.2.4 flexbox 弹性布局的组件的使用"></a>4.2.4 flexbox 弹性布局的组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">flexbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:gutter</span>=<span class="string">"0"</span>  设置间隙的像素大小</span></span><br><span class="line"><span class="tag">  <span class="attr">orient</span>=<span class="string">"horizontal(默认)/vertical"</span>  设置排布方向</span></span><br><span class="line"><span class="tag">  <span class="attr">wrap</span>=<span class="string">"wrap"</span>  设置换行方式, 参数为：<span class="attr">nowrap</span>(默认值,不换行) | <span class="attr">wrap</span>(换行，第一行在上方) | <span class="attr">wrap-reverse</span>(换行，第一行在下方)</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flexbox-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:span</span>=<span class="string">"4"</span>  设置占用的宽度，默认一行有<span class="attr">12</span>格，也可以使用分数表示</span></span><br><span class="line"><span class="tag">    <span class="attr">:order</span>=<span class="string">"-99"</span>  设置其排列顺序，数字越小越靠前，默认为<span class="attr">0</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-demo"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">flexbox-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flexbox-item</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-demo"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">flexbox-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flexbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-grid-栅格布局（子元素-grid-item）"><a href="#4-3-grid-栅格布局（子元素-grid-item）" class="headerlink" title="4.3 grid 栅格布局（子元素 grid-item）"></a>4.3 grid 栅格布局（子元素 grid-item）</h3><h4 id="4-3-1-grid-栅格布局的功能"><a href="#4-3-1-grid-栅格布局的功能" class="headerlink" title="4.3.1 grid 栅格布局的功能"></a>4.3.1 grid 栅格布局的功能</h4><p>grid 组件用于栅格布局的盒子，例如构建一个九宫格的框架，包含图片和文字类容，其中 grid-item 为内容插槽，用于填充其内容；</p>
<h4 id="4-3-2-grid-grid-item-组件的属性和插槽"><a href="#4-3-2-grid-grid-item-组件的属性和插槽" class="headerlink" title="4.3.2 grid/grid-item 组件的属性和插槽"></a>4.3.2 grid/grid-item 组件的属性和插槽</h4><table>
<thead>
<tr>
<th>grid 属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rows</td>
<td>number</td>
<td>3</td>
<td>(v2.6.0 之后废弃，使用 col 替代)宫格行数，建议少于5</td>
</tr>
<tr>
<td>cols</td>
<td>number</td>
<td>3</td>
<td>列数。如果为非单行 Grid，需要设置 cols，否则所有 GridItem 会平均宽度显示在一行。</td>
</tr>
<tr>
<td>show-lr-borders</td>
<td>boolean</td>
<td>true</td>
<td>是否显示左右边框</td>
</tr>
<tr>
<td>show-vertical-dividers</td>
<td>boolean</td>
<td>true</td>
<td>是否显示垂直分割线</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>grid 插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td><code>grid-item</code> 的内容插槽</td>
</tr>
</tbody></table>
<br>

<p>grid-item 属性名字 | 类型 | 默认值<br>— | — | — | —<br>icon     | string     |     图标地址，如果是线上地址，推荐使用该prop。如果是本地图标资源，使用<code>slot=icon</code>可以保证资源被正确打包<br>label |     string     |     <code>label</code> 文字<br>link     | string     | <code>vue-router</code> 路径</p>
<br>

<table>
<thead>
<tr>
<th>grid-item 插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>icon</td>
<td>图标内容，直接使用img标签</td>
</tr>
<tr>
<td>label</td>
<td><code>label</code> 文字的 <code>slot</code>，作用同 <code>prop:label</code></td>
</tr>
</tbody></table>
<h4 id="4-3-3-grid-grid-item-组件的注册"><a href="#4-3-3-grid-grid-item-组件的注册" class="headerlink" title="4.3.3 grid/grid-item 组件的注册"></a>4.3.3 grid/grid-item 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Grid, GridItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Grid,</span><br><span class="line">    GridItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Grid, GridItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'grid'</span>, Grid)</span><br><span class="line">Vue.component(<span class="string">'grid-item'</span>, GridItem)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-3-4-grid-grid-item-组件的使用"><a href="#4-3-4-grid-grid-item-组件的使用" class="headerlink" title="4.3.4 grid/grid-item 组件的使用"></a>4.3.4 grid/grid-item 组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">grid</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:cols</span>=<span class="string">"3"</span>  设置宫格的列数</span></span><br><span class="line"><span class="tag">  <span class="attr">:show-lr-borders</span>=<span class="string">"false"</span>  设置不显示左右边框，默认为显示</span></span><br><span class="line"><span class="tag">  <span class="attr">:show-vertical-dividers</span>=<span class="string">"false"</span>  设置不显示垂直分割线，默认为显示</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">grid-item</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">label</span>=<span class="string">""</span>  在此设置宫格中的文字内容，与内容插槽中使用一致</span></span><br><span class="line"><span class="tag">    <span class="attr">icon</span>= <span class="string">""</span>  在此设置宫格中的图片内容，与内容插槽中使用一致</span></span><br><span class="line"><span class="tag">    <span class="attr">link</span>=<span class="string">"/component/cell"</span>  设置`<span class="attr">vue-router</span>` 路径</span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"i in 2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"i"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"icon"</span>  插槽图标内容，直接使用<span class="attr">img</span>标签</span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"../assets/grid_icon.png"</span>  图片地址</span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"label"</span>  插槽文字内容，作用同 `<span class="attr">prop:label</span>`</span></span><br><span class="line"><span class="tag">    &gt;</span>跳转<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">grid-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">grid</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-sticky-滚动固定"><a href="#4-4-sticky-滚动固定" class="headerlink" title="4.4 sticky 滚动固定"></a>4.4 sticky 滚动固定</h3><h4 id="4-4-1-sticky-滚动固定组件的功能"><a href="#4-4-1-sticky-滚动固定组件的功能" class="headerlink" title="4.4.1 sticky 滚动固定组件的功能"></a>4.4.1 sticky 滚动固定组件的功能</h4><p>sticky 滚动固定组件用于在页面滚动后，达到某一个值后将<code>sticky 滚动固定组件</code>的内容固定在该位置，起到悬浮的功能；</p>
<h4 id="4-4-2-sticky-滚动固定组件的属性、插槽、方法和样式变量"><a href="#4-4-2-sticky-滚动固定组件的属性、插槽、方法和样式变量" class="headerlink" title="4.4.2 sticky 滚动固定组件的属性、插槽、方法和样式变量"></a>4.4.2 sticky 滚动固定组件的属性、插槽、方法和样式变量</h4><table>
<thead>
<tr>
<th>sticky 组件属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scroll-box</td>
<td>string</td>
<td>window</td>
<td>滚动容器，默认为<code>window</code>，如果你使用了<code>viewbox</code>，那么你需要指定容器id：<code>vux_view_box_body</code></td>
</tr>
<tr>
<td>check-sticky-support</td>
<td>boolean</td>
<td>true</td>
<td>是否检测当前浏览器是否支持<code>sticky</code>特性，禁用则在<code>iPhone</code>设置上也使用<code>scroll</code>实现</td>
</tr>
<tr>
<td>offset</td>
<td>number</td>
<td>0</td>
<td>距离顶部高度，在存在头部（如使用了<code>x-header</code>）的情况下需要设置一个距离</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否禁用，在某些浏览器禁用，比如万恶的 <code>UC</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>sticky 组件插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>默认插槽</code></td>
<td>内容插槽</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>sticky 组件方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bindSticky</td>
<td></td>
<td>手动重新绑定，用于内容变化导致位置变化定位不再正确的情况</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>sticky 组件样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@sticky-zindex</td>
<td>500</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-4-3-sticky-组件的注册"><a href="#4-4-3-sticky-组件的注册" class="headerlink" title="4.4.3 sticky 组件的注册"></a>4.4.3 sticky 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Sticky &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Sticky</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在入口文件全局引入</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123; Sticky &#125; from &#39;vux&#39;</span><br><span class="line">Vue.component(&#39;sticky&#39;, Sticky)</span><br></pre></td></tr></table></figure>
<h4 id="4-4-4-sticky-组件的使用"><a href="#4-4-4-sticky-组件的使用" class="headerlink" title="4.4.4 sticky 组件的使用"></a>4.4.4 sticky 组件的使用</h4></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:44px;"</span>&gt;</span> 建议加一个div高度为内容高度，这样可以避免当定位为sticky时下面的元素会突然向上走</span><br><span class="line">  <span class="tag">&lt;<span class="name">sticky</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scroll-box</span>=<span class="string">"vux_view_box_body"</span>  设置滚动的指定容器，<span class="attr">vux_view_box_body</span> 表示为 <span class="attr">view-box</span> 组件生成的内容区域的容器</span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"sticky"</span>  设置<span class="attr">ref</span>属性</span></span><br><span class="line"><span class="tag">    <span class="attr">:offset</span>=<span class="string">"46"</span>  设置距离顶部高度，在存在头部（如使用了`<span class="attr">x-header</span>`）的情况下需要设置一个距离</span></span><br><span class="line"><span class="tag">    <span class="attr">:check-sticky-support</span>=<span class="string">"false"</span>  可以通过设置禁用原生支持检测以获得相同的效果</span></span><br><span class="line"><span class="tag">    <span class="attr">:disabled</span>=<span class="string">"disabled"</span>  设置禁用属性，可以根据不同浏览器设置禁用</span></span><br><span class="line"><span class="tag">  &gt;</span>he</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是滚动到一定位置需要固定的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sticky</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"i in 100"</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  用于内容区域填充</span><br></pre></td></tr></table></figure>

<h3 id="4-5-view-box-滚动容器"><a href="#4-5-view-box-滚动容器" class="headerlink" title="4.5 view-box 滚动容器"></a>4.5 view-box 滚动容器</h3><h4 id="4-5-1-view-box-滚动容器组件的功能"><a href="#4-5-1-view-box-滚动容器组件的功能" class="headerlink" title="4.5.1 view-box 滚动容器组件的功能"></a>4.5.1 view-box 滚动容器组件的功能</h4><p><code>view-box</code> 滚动容器组件是用于设置页面的滚动的盒子，可以设置为全局滚动以及某个<code>div</code>中内容的局部滚动，注意一点的是由于该组件为100%高布局，因此必须设置<code>view-box</code>所有父<code>div</code>也需要为100%高度；若想保存滚动距离，推荐使用<code>vuex</code>实现，在特定path对<code>scrollBody</code>监听<code>scroll事件</code>，并获取滚动距离保存到<code>vuex的state</code>里；</p>
<h4 id="4-5-2-view-box-组件的属性、插槽、方法"><a href="#4-5-2-view-box-组件的属性、插槽、方法" class="headerlink" title="4.5.2 view-box 组件的属性、插槽、方法"></a>4.5.2 view-box 组件的属性、插槽、方法</h4><table>
<thead>
<tr>
<th>view-box属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>body-padding-top</td>
<td>string</td>
<td></td>
<td>主体的<code>padding-top</code>值，当顶部存在<code>x-header</code>等<code>absolute定位元素</code>时需要设置</td>
</tr>
<tr>
<td>body-padding-bottom</td>
<td>string</td>
<td></td>
<td>主体的<code>padding-bottom</code>值，当底部存在<code>tabbar</code>等<code>absolute定位元素</code>时需要设置</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>顶部区域，如果要使用统一的 <code>XHeader</code>，可以使用该<code>slot</code></td>
</tr>
<tr>
<td>默认插槽</td>
<td>主体内容，可滚动的区域</td>
</tr>
<tr>
<td>bottom</td>
<td>底部区域，<code>Tabbar</code> 可以使用该 <code>slot</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>view-box方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollTo</td>
<td>(top)</td>
<td>滚动到指定位置</td>
</tr>
<tr>
<td>getScrollTop</td>
<td></td>
<td>获取当前滚动距离</td>
</tr>
<tr>
<td>getScrollBody</td>
<td></td>
<td>获取滚动 <code>div</code>, 也可以直接用组件引用的 <code>.$refs.viewBoxBody</code></td>
</tr>
</tbody></table>
<h4 id="4-5-3-view-box-组件的注册"><a href="#4-5-3-view-box-组件的注册" class="headerlink" title="4.5.3 view-box 组件的注册"></a>4.5.3 view-box 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ViewBox &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ViewBox</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在入口文件全局引入</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123; ViewBox &#125; from &#39;vux&#39;</span><br><span class="line">Vue.component(&#39;view-box&#39;, ViewBox)</span><br></pre></td></tr></table></figure>
<h4 id="4-5-4-view-box-组件的使用"><a href="#4-5-4-view-box-组件的使用" class="headerlink" title="4.5.4 view-box 组件的使用"></a>4.5.4 view-box 组件的使用</h4>在<code>viewBox</code>里元素定位为<code>absolute</code>，效果等同于<code>fixed</code>，若整个页面使用，需要设置 <code>html, body</code> 高为100%:</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若局部滚动使用，<code>view-box</code>所有<code>父div</code>也需要为<code>100%高度</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100%;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view-box</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"viewBox"</span>  用于后面通过<span class="attr">refs</span>属性获取该元素对象</span></span><br><span class="line"><span class="tag">    <span class="attr">body-padding-top</span>= <span class="string">"88px"</span>  设置主体的`<span class="attr">padding-top</span>`值，当顶部存在`<span class="attr">x-header</span>`等`<span class="attr">absolute</span>定位元素`时需要设置</span></span><br><span class="line"><span class="tag">    <span class="attr">body-padding-bottom</span>= <span class="string">"44px"</span>  设置主体的`<span class="attr">padding-bottom</span>`值，当底部存在`<span class="attr">tabbar</span>`等`<span class="attr">absolute</span>定位元素`时需要设置</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x-header</span></span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"header"</span>  使用插槽设置滚动区域的顶部区域</span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"width:100%;position:absolute;left:0;top:0;z-index:100;"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">x-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>  用于路由填坑</span><br><span class="line">    <span class="tag">&lt;<span class="name">tabbar</span></span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"bottom"</span>  使用插槽设置滚动区域的底部区域</span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">tabbar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view-box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-表单组件"><a href="#5-表单组件" class="headerlink" title="5. 表单组件"></a>5. 表单组件</h2><h3 id="5-1-calendar（日历）"><a href="#5-1-calendar（日历）" class="headerlink" title="5.1 calendar（日历）"></a>5.1 calendar（日历）</h3><h4 id="5-1-1-calendar组件的功能"><a href="#5-1-1-calendar组件的功能" class="headerlink" title="5.1.1 calendar组件的功能"></a>5.1.1 calendar组件的功能</h4><p><code>calendar</code>组件作为日历的组件使用，同时<code>calendar</code>只能在<code>Group</code>中使用，除了<code>title和 value</code>, 其他<code>props</code>和<code>inline-calendar</code>完全一致；当绑定值为数组时，日历将为多选模式；</p>
<h4 id="5-1-2-calendar组件的属性、事件、插槽和样式变量"><a href="#5-1-2-calendar组件的属性、事件、插槽和样式变量" class="headerlink" title="5.1.2 calendar组件的属性、事件、插槽和样式变量"></a>5.1.2 calendar组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>calendar组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值, <code>v-model</code> 绑定。当值为空时，为单选；当值为<code>[]</code>时，为多选；设置值为<code>&#39;TODAY&#39;</code>可快捷选取当前日期。<code>placeholder</code>只有在值为<code>空或[]</code>时显示。</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>label文字</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>占位提示文字</td>
</tr>
<tr>
<td>show-popup-header</td>
<td>boolean</td>
<td></td>
<td>是否显示弹窗头部，当为多选时强制显示，单选时默认不显示</td>
</tr>
<tr>
<td>popup-header-title</td>
<td>string</td>
<td></td>
<td>弹窗头部文字</td>
</tr>
<tr>
<td>display-format</td>
<td>function</td>
<td></td>
<td>格式化显示值</td>
</tr>
<tr>
<td>readonly</td>
<td>string</td>
<td></td>
<td>是否禁用弹窗选择</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>calendar组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>值改变时触发</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗显示时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗关闭时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>calendar组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
</table>
<br>

<table>
<thead>
<tr>
<th>calendar组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@calendar-arrow-color</td>
<td>草绿色#04BE02</td>
<td>前进后退的箭头颜色    ，@theme-color</td>
</tr>
<tr>
<td>@calendar-highlight-color</td>
<td>橙黄色#E59313</td>
<td>周末高亮的文本颜色</td>
</tr>
<tr>
<td>@calendar-selected-bg-color</td>
<td>草绿色#04BE02</td>
<td>选中时的背景颜色    ，@theme-color</td>
</tr>
<tr>
<td>@calendar-disabled-font-color</td>
<td>浅灰色#c0c0c0</td>
<td>禁用时的文本颜色</td>
</tr>
<tr>
<td>@calendar-today-font-color</td>
<td>草绿色#04BE02</td>
<td>今天的文本颜色，    @theme-color</td>
</tr>
<tr>
<td>@calendar-date-item-font-size</td>
<td>16px</td>
<td>单元格的字号</td>
</tr>
<tr>
<td>@calendar-bg-color</td>
<td>#fff</td>
<td>背景颜色</td>
</tr>
<tr>
<td>@calendar-each-date-item-size</td>
<td>26px</td>
<td>日期单元格尺寸大小</td>
</tr>
<tr>
<td>@calendar-each-date-item-line-height</td>
<td>25px</td>
<td>日期单元格的行高</td>
</tr>
<tr>
<td>@calendar-header-day-item-color</td>
<td>#000</td>
<td>头部的文本颜色</td>
</tr>
</tbody></table>
<h4 id="5-1-3-calendar组件的注册"><a href="#5-1-3-calendar组件的注册" class="headerlink" title="5.1.3 calendar组件的注册"></a>5.1.3 calendar组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calendar &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Calendar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calendar &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'calendar'</span>, Calendar)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-1-4-calendar组件的使用"><a href="#5-1-4-calendar组件的使用" class="headerlink" title="5.1.4 calendar组件的使用"></a>5.1.4 calendar组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">calendar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:readonly</span>=<span class="string">"readonly"</span>  使用<span class="attr">v-bind</span>绑定形式，设置是否禁用弹窗选择，<span class="attr">false</span>时禁止弹窗选择</span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"demo"</span>  使用 `<span class="attr">v-model</span>` 绑定表单值，当值为`[]`时，为多选；设置值为`'<span class="attr">TODAY</span>'`可快捷选取当前日期；`<span class="attr">placeholder</span>`只有在值为`空或[]`时显示；</span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"'基本使用'"</span>  设置 <span class="attr">label</span> 文字信息；</span></span><br><span class="line"><span class="tag">    <span class="attr">disable-past</span>  设置过去日期不可选择</span></span><br><span class="line"><span class="tag">    <span class="attr">disable-future</span>  设置未来日期不可选择</span></span><br><span class="line"><span class="tag">    <span class="attr">disable-weekend</span>  设置周六、周日不可选择</span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"placeholder"</span>  <span class="attr">label</span> 表单的填入信息</span></span><br><span class="line"><span class="tag">    <span class="attr">show-popup-header</span>  显示弹出的日历的顶部标题信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:popup-header-title</span>=<span class="string">"'Please select'"</span>  设置显示弹出的日历的顶部标题信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:display-format</span>=<span class="string">"displayFormat"</span>  格式化日历显示值，例如 <span class="attr">displayFormat</span>的函数如下，写在<span class="attr">data</span> 返回的对象中；</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-show</span>=<span class="string">"log('show')"</span>  日历弹窗显示时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-hide</span>=<span class="string">"log('hide')"</span>  日历弹窗关闭时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"log('change')"</span>  日历值改变时触发</span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">calendar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">displayFormat (value, type) &#123;</span><br><span class="line">  if (type === 'string') &#123;  // 判断时string是根据v-model绑定的值决定的，还可以是array类型</span><br><span class="line">    return value</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return value.length ? (value.length + ' days') : ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-cell-box-表格类型组件"><a href="#5-2-cell-box-表格类型组件" class="headerlink" title="5.2 cell-box(表格类型组件)"></a>5.2 cell-box(表格类型组件)</h3><h4 id="5-2-1-cell-box组件的功能"><a href="#5-2-1-cell-box组件的功能" class="headerlink" title="5.2.1 cell-box组件的功能"></a>5.2.1 cell-box组件的功能</h4><p>与<code>cell</code>相比，<code>cell-box</code>更自由和灵活，只提供<code>is-link和link</code>属性，内容直接使用默认<code>slot</code>定义；<code>cell-box</code>同样只能在<code>Group</code>中使用 ;</p>
<h4 id="5-2-2-cell-box组件的属性、插槽"><a href="#5-2-2-cell-box组件的属性、插槽" class="headerlink" title="5.2.2 cell-box组件的属性、插槽"></a>5.2.2 cell-box组件的属性、插槽</h4><table>
<thead>
<tr>
<th>cell-box组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>is-link</td>
<td>boolean</td>
<td>false</td>
<td>是否为链接，如果是，右侧将会出现指引点击的右箭头</td>
</tr>
<tr>
<td>link</td>
<td>string object</td>
<td></td>
<td>点击链接，可以为<code>http(s)</code>协议，也可以是 <code>vue-router</code> 支持的地址形式</td>
</tr>
<tr>
<td>border-intent</td>
<td>boolean</td>
<td>true</td>
<td>是否显示边框与左边的间隙</td>
</tr>
<tr>
<td>align-items</td>
<td>string</td>
<td>center</td>
<td>flex 布局 <code>align-items</code> 设置</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>cell-box组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>内容区域</td>
</tr>
</tbody></table>
<h4 id="5-2-3-cell-box组件的注册"><a href="#5-2-3-cell-box组件的注册" class="headerlink" title="5.2.3 cell-box组件的注册"></a>5.2.3 cell-box组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CellBox &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CellBox</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; CellBox &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'cell-box'</span>, CellBox)</span><br></pre></td></tr></table></figure>
<h4 id="5-2-4-cell-box组件的使用"><a href="#5-2-4-cell-box组件的使用" class="headerlink" title="5.2.4 cell-box组件的使用"></a>5.2.4 cell-box组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell-box</span> <span class="attr">is-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- anything --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell-box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-3-cell-form-preview-类似于table表格类型的组件"><a href="#5-3-cell-form-preview-类似于table表格类型的组件" class="headerlink" title="5.3 cell-form-preview(类似于table表格类型的组件)"></a>5.3 cell-form-preview(类似于table表格类型的组件)</h3><h4 id="5-3-1-cell-form-preview组件的功能"><a href="#5-3-1-cell-form-preview组件的功能" class="headerlink" title="5.3.1 cell-form-preview组件的功能"></a>5.3.1 cell-form-preview组件的功能</h4><p>CellFormPreview 需要在 Group 组件中使用。</p>
<h4 id="5-3-2-cell-form-preview组件的属性"><a href="#5-3-2-cell-form-preview组件的属性" class="headerlink" title="5.3.2 cell-form-preview组件的属性"></a>5.3.2 cell-form-preview组件的属性</h4><table>
<thead>
<tr>
<th>cell-form-preview组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>array</td>
<td></td>
<td>内容列表，键值包括<code>label和value</code>，可缺值</td>
</tr>
<tr>
<td>border-intent</td>
<td>boolean</td>
<td>true</td>
<td>是否显示边框与左边的间隙</td>
</tr>
</tbody></table>
<h4 id="5-3-3-cell-form-preview组件的注册"><a href="#5-3-3-cell-form-preview组件的注册" class="headerlink" title="5.3.3 cell-form-preview组件的注册"></a>5.3.3 cell-form-preview组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CellFormPreview &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CellFormPreview</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; CellFormPreview &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'cell-form-preview'</span>, CellFormPreview)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-3-4-cell-form-preview组件的使用"><a href="#5-3-4-cell-form-preview组件的使用" class="headerlink" title="5.3.4 cell-form-preview组件的使用"></a>5.3.4 cell-form-preview组件的使用</h4><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;group&gt;</span><br><span class="line">      &lt;cell :title<span class="built_in">=</span><span class="string">"$t('Total')"</span> :value<span class="built_in">=</span><span class="string">"$t('$1024')"</span>&gt;&lt;/cell&gt;</span><br><span class="line">      &lt;cell-form-preview :list<span class="built_in">=</span><span class="string">"list"</span>&gt;&lt;/cell-form-preview&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;i18n&gt;</span><br><span class="line">Total:</span><br><span class="line">  zh-CN: 合计</span><br><span class="line"><span class="string">'$1024'</span>:</span><br><span class="line">  zh-CN: ￥<span class="number">1024</span></span><br><span class="line">Apple:</span><br><span class="line">  zh-CN: 苹果</span><br><span class="line">Banana:</span><br><span class="line">  zh-CN: 香蕉</span><br><span class="line">Fish:</span><br><span class="line">  zh-CN: 鱼肉</span><br><span class="line">&lt;/i18n&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; CellFormPreview, Group, Cell &#125; from <span class="string">'vux'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CellFormPreview,</span><br><span class="line">    Group,</span><br><span class="line">    Cell</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [&#123;</span><br><span class="line">        label: <span class="string">'Apple'</span>,</span><br><span class="line">        value: <span class="string">'3.29'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        label: <span class="string">'Banana'</span>,</span><br><span class="line">        value: <span class="string">'1.04'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        label: <span class="string">'Fish'</span>,</span><br><span class="line">        value: <span class="string">'8.00'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-cell"><a href="#5-4-cell" class="headerlink" title="5.4 cell"></a>5.4 cell</h3><h4 id="5-4-1-cell组件的功能"><a href="#5-4-1-cell组件的功能" class="headerlink" title="5.4.1 cell组件的功能"></a>5.4.1 cell组件的功能</h4><p>Cell 组件只能在<code>Group</code>中使用，作为单个的小格子；</p>
<h4 id="5-4-2-cell组件的属性、事件、插槽和样式变量"><a href="#5-4-2-cell组件的属性、事件、插槽和样式变量" class="headerlink" title="5.4.2 cell组件的属性、事件、插槽和样式变量"></a>5.4.2 cell组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>cell 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>左边标题文字</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td></td>
<td>右侧文字，复杂的样式布局请使用<code>slot</code></td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>标题下面文字，一般为说明文字</td>
</tr>
<tr>
<td>link</td>
<td>string object</td>
<td></td>
<td>点击链接，可以为http(s)协议，也可以是 vue-router 支持的地址形式</td>
</tr>
<tr>
<td>is-link</td>
<td>boolean</td>
<td>false</td>
<td>是否为链接，如果是，右侧将会出现指引点击的右箭头</td>
</tr>
<tr>
<td>primary</td>
<td>string</td>
<td>title</td>
<td>可选值为 <code>[&#39;title&#39;, &#39;content&#39;]</code>，对应的div会加上<code>weui_cell_primary</code>类名实现内容宽度自适应</td>
</tr>
<tr>
<td>is-loading</td>
<td>boolean</td>
<td>false</td>
<td>是否显示加载图标，适用于异步加载数据的场景</td>
</tr>
<tr>
<td>value-align</td>
<td>string</td>
<td>left</td>
<td>文字值对齐方式，可选值为<code>left right</code>。当设为 <code>right</code> 时，<code>primary</code> 值将会设为 <code>content</code></td>
</tr>
<tr>
<td>border-intent</td>
<td>boolean</td>
<td>true</td>
<td>是否显示边框与左边的间隙</td>
</tr>
<tr>
<td>arrow-direction</td>
<td>string</td>
<td></td>
<td>右侧箭头方向，可选有 <code>up down</code></td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td></td>
<td>对 label 和箭头(如果使用 <code>is-link</code> )显示不可操作样式</td>
</tr>
<tr>
<td>align-items</td>
<td>string</td>
<td>center</td>
<td><code>align-items</code> 样式值</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>cell 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>右侧内容，相比于value的优点是可以用复杂的样式或者调用组件</td>
</tr>
<tr>
<td>value</td>
<td>[废弃] 同默认slot</td>
</tr>
<tr>
<td>icon</td>
<td>标题左侧的图像位置</td>
</tr>
<tr>
<td>after-title</td>
<td>标题右侧位置</td>
</tr>
<tr>
<td>child</td>
<td>cell的直接子元素，因此可以添加一个相对于cell绝对定位的元素</td>
</tr>
<tr>
<td>inline-desc</td>
<td><code>inline-desc</code> 内容，和 <code>prop:inline-desc</code> 功能一样，但是可以使用 <code>html</code></td>
</tr>
<tr>
<td>title</td>
<td>title 插槽，方便自定义样式</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>cell 组件的样式变量名字</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>@cell-label-color</td>
<td>#000</td>
</tr>
<tr>
<td>@cell-font-size</td>
<td>17px</td>
</tr>
<tr>
<td>@cell-tips-font-size</td>
<td>14px</td>
</tr>
<tr>
<td>@cell-default-arrow-color</td>
<td>#C8C8CD</td>
</tr>
<tr>
<td>@cell-disabled-arrow-color</td>
<td>#e2e2e2</td>
</tr>
<tr>
<td>@cell-default-arrow-border-width</td>
<td>2px</td>
</tr>
<tr>
<td>@cell-default-arrow-width</td>
<td>6px</td>
</tr>
<tr>
<td>@cell-value-color</td>
<td>#999</td>
</tr>
<tr>
<td>@cell-placeholder-color</td>
<td>#999</td>
</tr>
<tr>
<td>@cell-body-label-color</td>
<td>#000</td>
</tr>
</tbody></table>
<h4 id="5-4-3-cell组件的注册"><a href="#5-4-3-cell组件的注册" class="headerlink" title="5.4.3 cell组件的注册"></a>5.4.3 cell组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Cell &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Cell</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Cell &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'cell'</span>, Cell)</span><br></pre></td></tr></table></figure>
<h4 id="5-4-4-cell组件的使用"><a href="#5-4-4-cell组件的使用" class="headerlink" title="5.4.4 cell组件的使用"></a>5.4.4 cell组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"'Money'"</span>  设置左边标题文字</span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">"money"</span>  设置右侧文字，复杂的样式布局请使用<span class="attr">slot</span></span></span><br><span class="line"><span class="tag">    <span class="attr">disabled</span>  设置 <span class="attr">label</span> 和箭头(如果使用 `<span class="attr">is-link</span>` )显示不可操作样式</span></span><br><span class="line"><span class="tag">    <span class="attr">:link</span>=<span class="string">"&#123;path:'/demo'&#125;"</span>  	设置点击链接，可以为<span class="attr">http</span>(<span class="attr">s</span>)协议，也可以是 <span class="attr">vue-router</span> 支持的地址形式</span></span><br><span class="line"><span class="tag">    <span class="attr">inline-desc</span>=<span class="string">'link="/component/radio"'</span>  设置小标题的内容，显示在大标题下方</span></span><br><span class="line"><span class="tag">    @<span class="attr">click.native</span>=<span class="string">"onClick"</span>  点击事件触发</span></span><br><span class="line"><span class="tag">    <span class="attr">:is-loading</span>=<span class="string">"!money"</span>  使用<span class="attr">v-bind</span>设置显示加载图标，适用于异步加载数据的场景</span></span><br><span class="line"><span class="tag">    <span class="attr">primary</span>=<span class="string">"content"</span>  默认为<span class="attr">title</span>,可选值为 `['<span class="attr">title</span>', '<span class="attr">content</span>']`，对应的<span class="attr">div</span>会加上`<span class="attr">weui_cell_primary</span>`类名实现内容宽度自适应</span></span><br><span class="line"><span class="tag">    <span class="attr">align-items</span>=<span class="string">"flex-start"</span>  默认<span class="attr">center</span>，是`<span class="attr">align-items</span>` 样式值</span></span><br><span class="line"><span class="tag">    <span class="attr">:border-intent</span>=<span class="string">"false"</span>  设置隐藏边框与左边的间隙，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:arrow-direction</span>=<span class="string">"showContent ? 'up' : 'down'"</span>  使用三元表达式控制右侧箭头方向，可选有 `<span class="attr">up</span> <span class="attr">down</span>`</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">width</span>=<span class="string">"20"</span> <span class="attr">style</span>=<span class="string">"display:block;margin-right:5px;"</span> <span class="attr">src</span>=<span class="string">".."</span>&gt;</span>  设置cell的图标</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"title"</span> <span class="attr">style</span>=<span class="string">"color:green;"</span>&gt;</span>  设置cell的标题内容</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"vertical-align:middle;"</span>&gt;</span>&#123;&#123; $t('Messages') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">badge</span> <span class="attr">text</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">badge</span>&gt;</span>  设置红点</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-5-check-icon-选择内容的图标"><a href="#5-5-check-icon-选择内容的图标" class="headerlink" title="5.5 check-icon (选择内容的图标)"></a>5.5 check-icon (选择内容的图标)</h3><h4 id="5-5-1-check-icon-组件的功能"><a href="#5-5-1-check-icon-组件的功能" class="headerlink" title="5.5.1 check-icon 组件的功能"></a>5.5.1 check-icon 组件的功能</h4><p>check-icon 组件用于是否选择单个项目中；</p>
<h4 id="5-5-2-check-icon-组件的属性"><a href="#5-5-2-check-icon-组件的属性" class="headerlink" title="5.5.2 check-icon 组件的属性"></a>5.5.2 check-icon 组件的属性</h4><table>
<thead>
<tr>
<th>check-icon 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>是否选中，使用 <code>:value.sync</code> 双向绑定</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>unknown</td>
<td>check icon 样式，可选值为<code>[&#39;plain&#39;]</code></td>
</tr>
</tbody></table>
<h4 id="5-5-3-check-icon-组件的注册"><a href="#5-5-3-check-icon-组件的注册" class="headerlink" title="5.5.3 check-icon 组件的注册"></a>5.5.3 check-icon 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CheckIcon &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CheckIcon</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; CheckIcon &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'check-icon'</span>, CheckIcon)</span><br></pre></td></tr></table></figure>
<h4 id="5-5-4-check-icon-组件的使用"><a href="#5-5-4-check-icon-组件的使用" class="headerlink" title="5.5.4 check-icon 组件的使用"></a>5.5.4 check-icon 组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">check-icon</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value.sync</span>=<span class="string">"demo"</span>  使用 `<span class="attr">:value.sync</span>` 双向绑定是否选中</span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"plain"</span>  设置选择的图标无背景色</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123; $t('Do you agree?') &#125;&#125;</span><br><span class="line">  (&#123;&#123; demo &#125;&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">check-icon</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-6-checker-checker-item（多选框及子组件）"><a href="#5-6-checker-checker-item（多选框及子组件）" class="headerlink" title="5.6 checker/checker-item（多选框及子组件）"></a>5.6 checker/checker-item（多选框及子组件）</h3><h4 id="5-6-1-checker-checker-item-组件的功能"><a href="#5-6-1-checker-checker-item-组件的功能" class="headerlink" title="5.6.1 checker/checker-item 组件的功能"></a>5.6.1 checker/checker-item 组件的功能</h4><p><code>checker</code> 组件用于选择多个元素，例如在淘宝中的筛选条件的使用；<code>Checker</code> 是比<code>Radio或者Checklist</code>更加灵活的选择组件，可以自定义需要的布局样式。</p>
<h4 id="5-6-2-checker-checker-item-组件的属性、事件"><a href="#5-6-2-checker-checker-item-组件的属性、事件" class="headerlink" title="5.6.2 checker/checker-item 组件的属性、事件"></a>5.6.2 checker/checker-item 组件的属性、事件</h4><table>
<thead>
<tr>
<th>checker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default-item-class</td>
<td>string</td>
<td></td>
<td>默认状态class</td>
</tr>
<tr>
<td>selected-item-class</td>
<td>string</td>
<td></td>
<td>选中样式class</td>
</tr>
<tr>
<td>disabled-item-class</td>
<td>string</td>
<td></td>
<td>不可选样式class</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>radio</td>
<td>类型，单选为radio, 多选为checkbox</td>
</tr>
<tr>
<td>value</td>
<td>string array</td>
<td></td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td></td>
<td>最多可选个数，多选时可用</td>
</tr>
<tr>
<td>radio-required</td>
<td>boolean</td>
<td>false</td>
<td>在单选模式下是否必选一个值。设为 true 后点击当前选中项不会取消选中。</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checker组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>value值变化时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checker-item组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>当前项的值</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否为不可选</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checker-item组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-item-click</td>
<td>(itemValue, itemDisabled)</td>
<td>当前项被点击时触发</td>
</tr>
</tbody></table>
<h4 id="5-6-3-checker-组件的注册"><a href="#5-6-3-checker-组件的注册" class="headerlink" title="5.6.3 checker 组件的注册"></a>5.6.3 checker 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Checker, CheckerItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Checker,</span><br><span class="line">    CheckerItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Checker, CheckerItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'checker'</span>, Checker)</span><br><span class="line">Vue.component(<span class="string">'checker-item'</span>, CheckerItem)</span><br></pre></td></tr></table></figure>
<h4 id="5-6-4-checker-组件的使用"><a href="#5-6-4-checker-组件的使用" class="headerlink" title="5.6.4 checker 组件的使用"></a>5.6.4 checker 组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checker</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"demo"</span>  使用<span class="attr">v-model</span>绑定表单值</span></span><br><span class="line"><span class="tag">  <span class="attr">radio-required</span>  设置在单选模式下是否必选一个值，设置为 <span class="attr">true</span> 后点击当前选中项不会取消选中。</span></span><br><span class="line"><span class="tag">  <span class="attr">default-item-class</span>=<span class="string">"demo-item"</span>  默认状态<span class="attr">class</span></span></span><br><span class="line"><span class="tag">  <span class="attr">selected-item-class</span>=<span class="string">"demo-item-selected"</span>  选中状态<span class="attr">class</span></span></span><br><span class="line"><span class="tag">  <span class="attr">disabled-item-class</span>=<span class="string">"demo-item-disabled"</span>  不可选样式<span class="attr">class</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"checkbox"</span>  设置类型，默认单选为<span class="attr">radio</span>, 多选为<span class="attr">checkbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:max</span>=<span class="string">"2"</span>  设置最多可选个数，多选时可用</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checker-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"1"</span>  设置当前项的值</span></span><br><span class="line"><span class="tag">    <span class="attr">disabled</span>  设置该选项不可选</span></span><br><span class="line"><span class="tag">  &gt;</span>&#123;&#123; $t('潘') &#125;&#125;<span class="tag">&lt;/<span class="name">checker-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checker-item</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>&#123;&#123; $t('闲') &#125;&#125;<span class="tag">&lt;/<span class="name">checker-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checker-item</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span>&#123;&#123; $t('邓') &#125;&#125;<span class="tag">&lt;/<span class="name">checker-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checker-item</span> <span class="attr">value</span>=<span class="string">"4"</span>&gt;</span>&#123;&#123; $t('小') &#125;&#125;<span class="tag">&lt;/<span class="name">checker-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checker-item</span> <span class="attr">value</span>=<span class="string">"5"</span>&gt;</span>&#123;&#123; $t('驴') &#125;&#125;<span class="tag">&lt;/<span class="name">checker-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checker</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-7-checklist-列表选择"><a href="#5-7-checklist-列表选择" class="headerlink" title="5.7 checklist(列表选择)"></a>5.7 checklist(列表选择)</h3><h4 id="5-7-1-checklist组件的功能"><a href="#5-7-1-checklist组件的功能" class="headerlink" title="5.7.1 checklist组件的功能"></a>5.7.1 checklist组件的功能</h4><p>checklist组件类似于html中的option标签的功能，支持选择多个选项；</p>
<h4 id="5-7-2-checklist组件的属性、事件、方法和样式变量"><a href="#5-7-2-checklist组件的属性、事件、方法和样式变量" class="headerlink" title="5.7.2 checklist组件的属性、事件、方法和样式变量"></a>5.7.2 checklist组件的属性、事件、方法和样式变量</h4><table>
<thead>
<tr>
<th>checklist组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>array</td>
<td>[]</td>
<td>表单值</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>required</td>
<td>boolean</td>
<td>false</td>
<td>是否为必选</td>
</tr>
<tr>
<td>options</td>
<td>array</td>
<td>[]</td>
<td>选项列表，可以为<code>[{key:&#39;name&#39;,value:&#39;value&#39;,inlineDesc:&#39;inlineDesc&#39;}]</code>的形式</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td></td>
<td>最多可选个数</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td></td>
<td>最少可选个数</td>
</tr>
<tr>
<td>random-order</td>
<td>boolean</td>
<td>false</td>
<td>是否随机打乱选项顺序</td>
</tr>
<tr>
<td>check-disabled</td>
<td>boolean</td>
<td>true</td>
<td>是否进行可选检测，默认情况下当选择个数等于可选个数(max)时，其他项不可选择。该选项主要适用于从多个选项列表中收集值的场景。注意的该选项设为 false 时 max 设置将失效。</td>
</tr>
<tr>
<td>label-position</td>
<td>string</td>
<td>right</td>
<td>label 位置，可以设置为 left 或者 right    v2.2.1-rc.4</td>
</tr>
<tr>
<td>disabled</td>
<td>string</td>
<td></td>
<td>是否禁用操作</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checklist组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value, label)</td>
<td>值变化时触发，参数为 <code>(value, label)</code>，其中 label 参数在 v2.5.7 后支持</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checklist组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFullValue</td>
<td></td>
<td>获取值和对应的显示文字</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>checklist组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@checklist-icon-active-color</td>
<td>草绿色#09BB07</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-7-3-checklist组件的注册"><a href="#5-7-3-checklist组件的注册" class="headerlink" title="5.7.3 checklist组件的注册"></a>5.7.3 checklist组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Checklist &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Checklist</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Checklist &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'checklist'</span>, Checklist)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-7-4-checklist组件的使用"><a href="#5-7-4-checklist组件的使用" class="headerlink" title="5.7.4 checklist组件的使用"></a>5.7.4 checklist组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checklist</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"demoObject"</span>  设置<span class="attr">refs</span>属性，如：获取值和对应的显示文字 <span class="attr">fullValues</span> = <span class="string">$refs.demoObject.getFullValue()</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">"'Basic Usage'"</span>  设置标题文字信息</span></span><br><span class="line"><span class="tag">  <span class="attr">:label-position</span>=<span class="string">"labelPosition"</span>  设置<span class="attr">label</span> 位置，可以设置为 <span class="attr">left</span> 或者 <span class="attr">right</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span>  设置必选，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:options</span>=<span class="string">"commonList"</span>  设置选项列表，可以为`[&#123;<span class="attr">key:</span>'<span class="attr">name</span>',<span class="attr">value:</span>'<span class="attr">value</span>',<span class="attr">inlineDesc:</span>'<span class="attr">inlineDesc</span>'&#125;]`的形式</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"checklist"</span>  使用<span class="attr">v-model</span>绑定表单值，是数组类型数据</span></span><br><span class="line"><span class="tag">  <span class="attr">:min</span>=<span class="string">1</span>  设置最少可选个数</span></span><br><span class="line"><span class="tag">  <span class="attr">:max</span>=<span class="string">3</span>  设置最多可选个数</span></span><br><span class="line"><span class="tag">  <span class="attr">random-order</span>  设置随机打乱选项顺序，默认 <span class="attr">false</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-change</span>=<span class="string">"change"</span>  表单值改变触发事件</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">checklist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-8-datetime-view（日期时间的选择框）"><a href="#5-8-datetime-view（日期时间的选择框）" class="headerlink" title="5.8 datetime-view（日期时间的选择框）"></a>5.8 datetime-view（日期时间的选择框）</h3><h4 id="5-8-1-datetime-view组件的功能"><a href="#5-8-1-datetime-view组件的功能" class="headerlink" title="5.8.1 datetime-view组件的功能"></a>5.8.1 datetime-view组件的功能</h4><p>显示为一个日期时间（年月日时分）的选择框，可以设置显示的格式为（’YYYY-MM-DD’ 或 ‘YYYY-MM-DD HH’ 或者 ‘YYYY-MM-DD HH:mm’ …），也可以使用<code>popup</code>组件设置为弹窗提示选择日期时间；</p>
<h4 id="5-8-2-datetime-view组件的属性、方法"><a href="#5-8-2-datetime-view组件的属性、方法" class="headerlink" title="5.8.2 datetime-view组件的属性、方法"></a>5.8.2 datetime-view组件的属性、方法</h4><table>
<thead>
<tr>
<th>datetime-view组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值，v-model绑定</td>
</tr>
<tr>
<td>format</td>
<td>string</td>
<td>YYYY-MM-DD</td>
<td>日期栏的显示格式</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>datetime-view组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>render</td>
<td></td>
<td>强制重新渲染组件，当主动修改值或者其他非响应属性时需要调用该方法</td>
</tr>
</tbody></table>
<h4 id="5-8-3-datetime-view组件的注册"><a href="#5-8-3-datetime-view组件的注册" class="headerlink" title="5.8.3 datetime-view组件的注册"></a>5.8.3 datetime-view组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; DatetimeView &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    DatetimeView</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; DatetimeView &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'datetime-view'</span>, DatetimeView)</span><br></pre></td></tr></table></figure>
<h4 id="5-8-4-datetime-view组件的使用"><a href="#5-8-4-datetime-view组件的使用" class="headerlink" title="5.8.4 datetime-view组件的使用"></a>5.8.4 datetime-view组件的使用</h4></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datetime-view</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"value1"</span>  使用<span class="attr">v-model</span>绑定日期时间的值</span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"datetime"</span>  设置<span class="attr">refs</span>属性用于获取该元素，获取后用于<span class="attr">render</span>方法的使用（<span class="attr">this.</span>$<span class="attr">refs.datetime.render</span>()），在改变日期时间值后一定要进行重新渲染；</span></span><br><span class="line"><span class="tag">  <span class="attr">:format</span>=<span class="string">"format"</span>  设置日期时间的格式（'<span class="attr">YYYY-MM-DD</span>' 或 '<span class="attr">YYYY-MM-DD</span> <span class="attr">HH</span>' 或者 '<span class="attr">YYYY-MM-DD</span> <span class="attr">HH:mm</span>' <span class="attr">...</span>）</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datetime-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click.native</span>=<span class="string">"changeValue('2017-11-11')"</span>  点击触发改变日期时间方法</span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"format !== 'YYYY-MM-DD'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">&gt;</span> 改变日期时间的值 <span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">click.native</span>=<span class="string">"toggleFormat"</span>  点击触发改变日期格式方法</span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"format === 'YYYY-MM-DD HH'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">&gt;</span> 改变日期时间的格式 <span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 作为一个弹出框选择日期时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">popup</span> <span class="attr">v-model</span>=<span class="string">"showPopup"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datetime-view</span> <span class="attr">v-model</span>=<span class="string">"value2"</span>&gt;</span><span class="tag">&lt;/<span class="name">datetime-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">popup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变日期时间值的方法</span></span><br><span class="line">changeValue (val) &#123;</span><br><span class="line">  <span class="keyword">this</span>.value1 = val</span><br><span class="line">  <span class="keyword">this</span>.$refs.datetime.render()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 改变日期时间格式的方法</span></span><br><span class="line">toggleFormat () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.format === <span class="string">'YYYY-MM-DD'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.format = <span class="string">'YYYY-MM-DD HH:mm'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.format = <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 改变日期时间值和格式的方法</span></span><br><span class="line">changeFormatAndValue () &#123;</span><br><span class="line">  <span class="keyword">this</span>.format = <span class="string">'YYYY-MM-DD HH'</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 该方法内的代码将会在日期时间格式变化渲染完成后才会执行</span></span><br><span class="line">    <span class="keyword">this</span>.value1 = <span class="string">'2019-10-23 10'</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.datetime.render()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-9-datetime-range（在group中使用，设置日期时间变化区间的选择框）"><a href="#5-9-datetime-range（在group中使用，设置日期时间变化区间的选择框）" class="headerlink" title="5.9 datetime-range（在group中使用，设置日期时间变化区间的选择框）"></a>5.9 datetime-range（在group中使用，设置日期时间变化区间的选择框）</h3><h4 id="5-9-1-datetime-range组件的功能"><a href="#5-9-1-datetime-range组件的功能" class="headerlink" title="5.9.1 datetime-range组件的功能"></a>5.9.1 datetime-range组件的功能</h4><p>设置日期时间的变化区间，选择在该区间内的值；该组件和 <code>Datetime</code> 组件不同的地方是<code>年月日集中显示在一栏</code>，适合范围不大的日期选择，需要在<code>Group</code>组件里使用。</p>
<h4 id="5-9-2-datetime-range组件的属性、事件、插槽和样式变量"><a href="#5-9-2-datetime-range组件的属性、事件、插槽和样式变量" class="headerlink" title="5.9.2 datetime-range组件的属性、事件、插槽和样式变量"></a>5.9.2 datetime-range组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>datetime-range组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题文字</td>
</tr>
<tr>
<td>value</td>
<td>array</td>
<td></td>
<td>表单值，<code>v-model</code>绑定。比如：<code>[&#39;2017-01-15&#39;, &#39;03&#39;, &#39;05&#39;]</code></td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>描述字符</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>提示文字，当value为空时显示</td>
</tr>
<tr>
<td>start-date</td>
<td>string</td>
<td></td>
<td>限定最小日期，注意该限制只能限定到日期，不能限定到小时分钟</td>
</tr>
<tr>
<td>end-date</td>
<td>string</td>
<td></td>
<td>限定最大日期，注意该限制只能限定到日期，不能限定到小时分钟</td>
</tr>
<tr>
<td>format</td>
<td>string</td>
<td>YYYY-MM-DD</td>
<td>日期栏的显示格式</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>datetime-range组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>表单值变化时触发, 参数 (<code>newVal</code>)</td>
</tr>
</tbody></table>
<h4 id="5-9-3-datetime-range组件的注册"><a href="#5-9-3-datetime-range组件的注册" class="headerlink" title="5.9.3 datetime-range组件的注册"></a>5.9.3 datetime-range组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; DatetimeRange &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    DatetimeRange</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; DatetimeRange &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'datetime-range'</span>, DatetimeRange)</span><br></pre></td></tr></table></figure>
<h4 id="5-9-4-datetime-range组件的使用"><a href="#5-9-4-datetime-range组件的使用" class="headerlink" title="5.9.4 datetime-range组件的使用"></a>5.9.4 datetime-range组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">:title</span>=<span class="string">"value[0] + ' ' + value[1] + ':' + value[2]"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">datetime-range</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"'Choose'"</span>  标题的文字内容</span></span><br><span class="line"><span class="tag">    <span class="attr">start-date</span>=<span class="string">"2017-01-01"</span>  起始的时间日期</span></span><br><span class="line"><span class="tag">    <span class="attr">end-date</span>=<span class="string">"2017-02-02"</span>  终止的时间日期</span></span><br><span class="line"><span class="tag">    <span class="attr">:format</span>=<span class="string">"'YYYY/MM/DD'"</span>  设置时间日期的格式</span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"value"</span>  使用<span class="attr">v-model</span>绑定日期时间值，该值为一个数组，比如：`['<span class="attr">2017-01-15</span>', '<span class="attr">03</span>', '<span class="attr">05</span>']`</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"onChange"</span>  改变时间日期值时触发事件</span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">datetime-range</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onChange (val) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'change'</span>, val) <span class="comment">// 打印改变的时间日期值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-10-datetime（在group中使用的时间日期选择框）"><a href="#5-10-datetime（在group中使用的时间日期选择框）" class="headerlink" title="5.10 datetime（在group中使用的时间日期选择框）"></a>5.10 datetime（在group中使用的时间日期选择框）</h3><h4 id="5-10-1-datetime组件的功能"><a href="#5-10-1-datetime组件的功能" class="headerlink" title="5.10.1 datetime组件的功能"></a>5.10.1 datetime组件的功能</h4><p>日期时间组件，弹出一个提示框来选择时间日期，需要在<code>Group</code>组件里使用，类似于cell的显示，左边显示标题，右边显示选择的时间日期；</p>
<h4 id="5-10-2-datetime组件的属性、事件、插槽和样式变量"><a href="#5-10-2-datetime组件的属性、事件、插槽和样式变量" class="headerlink" title="5.10.2 datetime组件的属性、事件、插槽和样式变量"></a>5.10.2 datetime组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>datetime组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>format</td>
<td>string</td>
<td>YYYY-MM-DD</td>
<td>时间格式，不支持特殊字符，只能类似 YYYY-MM-DD HH:mm 这样的格式（不支持秒 ss）, 另外支持 YYYY-MM-DD A 这样的格式(A为上、下午)</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值，<code>v-model</code>绑定</td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>描述字符</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>提示文字，当value为空时显示</td>
</tr>
<tr>
<td>min-year</td>
<td>number</td>
<td></td>
<td>可选择的最小年份</td>
</tr>
<tr>
<td>max-year</td>
<td>number</td>
<td></td>
<td>可选择的最大年份</td>
</tr>
<tr>
<td>min-hour</td>
<td>number</td>
<td>0</td>
<td>限定小时最小值</td>
</tr>
<tr>
<td>max-hour</td>
<td>number</td>
<td>23</td>
<td>限定小时最大值</td>
</tr>
<tr>
<td>confirm-text</td>
<td>string</td>
<td>ok(确认)</td>
<td>确认按钮文字</td>
</tr>
<tr>
<td>cancel-text</td>
<td>string</td>
<td>cancel(取消)</td>
<td>取消按钮文字</td>
</tr>
<tr>
<td>clear-text</td>
<td>string</td>
<td></td>
<td>显示在中间的自定义按钮的文字</td>
</tr>
<tr>
<td>year-row</td>
<td>string</td>
<td>{value}</td>
<td>年份的渲染模板</td>
</tr>
<tr>
<td>month-row</td>
<td>string</td>
<td>{value}</td>
<td>月份的渲染模板</td>
</tr>
<tr>
<td>day-row</td>
<td>string</td>
<td>{value}</td>
<td>日期的渲染模板</td>
</tr>
<tr>
<td>hour-row</td>
<td>string</td>
<td>{value}</td>
<td>小时的渲染模板</td>
</tr>
<tr>
<td>minute-row</td>
<td>string</td>
<td>{value}</td>
<td>分钟的渲染模板</td>
</tr>
<tr>
<td>start-date</td>
<td>string</td>
<td></td>
<td>限定最小日期，格式必须为 <code>YYYY-MM-DD</code>，注意该限制只能限定到日期，不能限定到小时分钟。小时限定请使用<code>min-hour和max-hour</code></td>
</tr>
<tr>
<td>end-date</td>
<td>string</td>
<td></td>
<td>限定最大日期，格式必须为 <code>YYYY-MM-DD</code>，注意该限制只能限定到日期，不能限定到小时分钟</td>
</tr>
<tr>
<td>required</td>
<td>boolean</td>
<td>false</td>
<td>是否必填</td>
</tr>
<tr>
<td>display-format</td>
<td>function</td>
<td></td>
<td>自定义显示值</td>
</tr>
<tr>
<td>readonly</td>
<td>string</td>
<td></td>
<td>只读模式，显示类似于 cell</td>
</tr>
<tr>
<td>show</td>
<td>boolean</td>
<td></td>
<td>控制显示，要求 vue^2.3</td>
</tr>
<tr>
<td>minute-list</td>
<td>array</td>
<td></td>
<td>定义分钟列表，比如 <code>[&#39;00&#39;, &#39;15&#39;, &#39;30&#39;, &#39;45&#39;]</code></td>
</tr>
<tr>
<td>hour-list</td>
<td>array</td>
<td></td>
<td>定义小时列表，比如 <code>[&#39;09&#39;, &#39;10&#39;, &#39;11&#39;, &#39;12&#39;]</code></td>
</tr>
<tr>
<td>default-selected-value</td>
<td>string</td>
<td></td>
<td>设置默认选中日期，当前 <code>value</code> 为空时有效</td>
</tr>
<tr>
<td>compute-hours-function</td>
<td>function</td>
<td></td>
<td>动态设置小时列表，参数为 <code>(value, isToday, generateRange)</code></td>
</tr>
<tr>
<td>compute-days-function</td>
<td>function</td>
<td></td>
<td>动态设置日期列表，参数为 <code>({year, month, min, max}, generateRange)</code></td>
</tr>
<tr>
<td>order-map</td>
<td>object</td>
<td></td>
<td>自定义列顺序, 如<code>{year: 1, month: 2, day: 3, hour: 4, minute: 5, noon: 6}</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>datetime组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>表单值变化时触发, 参数 (newVal)</td>
</tr>
<tr>
<td>@on-clear</td>
<td>–</td>
<td>点击显示在中间的自定义按钮时触发</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗显示时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>(type), type is one of [cancel, confirm]</td>
<td>弹窗关闭时触发    v2.7.4</td>
</tr>
<tr>
<td>@on-cancel</td>
<td>–</td>
<td>点击取消按钮或者遮罩时触发，等同于事件 <code>on-hide(cancel)</code>    v2.7.4</td>
</tr>
<tr>
<td>@on-confirm</td>
<td>(value) v2.9.0 支持该参数</td>
<td>点击确定按钮时触发，等同于事件 <code>on-hide(confirm)</code>v2.7.4</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>datetime组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>触发元素内容</td>
</tr>
<tr>
<td>title    title</td>
<td>slot</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>datetime组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@datetime-header-item-font-color</td>
<td>草绿色#04BE02</td>
<td>@theme-color</td>
</tr>
<tr>
<td>@datetime-header-item-cancel-font-color</td>
<td>深灰色#828282</td>
<td>–</td>
</tr>
<tr>
<td>@datetime-header-item-confirm-font-color</td>
<td>草绿色#04BE02</td>
<td>@datetime-header-item-font-color</td>
</tr>
</tbody></table>
<h4 id="5-10-3-datetime组件的注册和plugin形式调用："><a href="#5-10-3-datetime组件的注册和plugin形式调用：" class="headerlink" title="5.10.3 datetime组件的注册和plugin形式调用："></a>5.10.3 datetime组件的注册和plugin形式调用：</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Datetime &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Datetime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Datetime &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'datetime'</span>, Datetime)</span><br></pre></td></tr></table></figure></li>
<li>c. 插件形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 plugin 形式使用时，请在入口处引入：</span></span><br><span class="line"><span class="keyword">import</span> &#123; DatetimePlugin &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.use(DatetimePlugin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内使用</span></span><br><span class="line"><span class="keyword">this</span>.$vux.datetime.show(&#123;</span><br><span class="line">  cancelText: <span class="string">'取消'</span>,</span><br><span class="line">  confirmText: <span class="string">'确定'</span>,</span><br><span class="line">  format: <span class="string">'YYYY-MM-DD HH'</span>,</span><br><span class="line">  value: <span class="string">'2017-05-20 18'</span>,</span><br><span class="line">  onConfirm (val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin confirm'</span>, val)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$vux.datetime.hide()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-10-4-datetime组件的使用"><a href="#5-10-4-datetime组件的使用" class="headerlink" title="5.10.4 datetime组件的使用"></a>5.10.4 datetime组件的使用</h4><ul>
<li>组件形式使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">:title</span>=<span class="string">"'Default format: YYYY-MM-DD'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datetime</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"value"</span>  使用`<span class="attr">v-model</span>`绑定日期时间的表单值</span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"'Birthday'"</span>  设置日期时间的标题显示值</span></span><br><span class="line"><span class="tag">    <span class="attr">format</span>=<span class="string">"YYYY-MM-DD HH:mm"</span>  设置日期时间的格式</span></span><br><span class="line"><span class="tag">    <span class="attr">:minute-list</span>=<span class="string">"['00', '15', '30', '45']"</span>  设置日期时间的分钟为<span class="attr">15</span>分钟间隔</span></span><br><span class="line"><span class="tag">    <span class="attr">:hour-list</span>=<span class="string">"['09', '10', '11', '12', '13', '14', '15', '16']"</span>  设置日期时间的小时列表</span></span><br><span class="line"><span class="tag">    <span class="attr">:readonly</span>=<span class="string">"readonly"</span>  设置日期时间的只读为变量获取</span></span><br><span class="line"><span class="tag">    <span class="attr">:display-format</span>=<span class="string">"formatValueFunction"</span>  自定义显示时间日期值，例如：<span class="attr">formatValueFunction</span> (<span class="attr">val</span>) &#123; <span class="attr">return</span> <span class="attr">val.replace</span>(/<span class="attr">-</span>/<span class="attr">g</span>, '$')&#125;,</span></span><br><span class="line"><span class="tag">    <span class="attr">:min-hour</span>=<span class="string">9</span>  设置小时最小值</span></span><br><span class="line"><span class="tag">    <span class="attr">:max-hour</span>=<span class="string">18</span>  设置小时最大值</span></span><br><span class="line"><span class="tag">    <span class="attr">:inline-desc</span>=<span class="string">"'Working hours: 09-18'"</span>  设置描述字符，位于标题<span class="attr">title</span>下面</span></span><br><span class="line"><span class="tag">    <span class="attr">:start-date</span>=<span class="string">"startDate"</span>  设置开始的日期，格式为： '<span class="attr">2015-11-11</span>'</span></span><br><span class="line"><span class="tag">    <span class="attr">:end-date</span>=<span class="string">"endDate"</span>  设置结束的日期，格式为： '<span class="attr">2017-11-11</span>'</span></span><br><span class="line"><span class="tag">    <span class="attr">default-selected-value</span>=<span class="string">"2017-06-18 13"</span>  设置默认选中的日期时间值</span></span><br><span class="line"><span class="tag">    <span class="attr">:placeholder</span>=<span class="string">"'Please select'"</span>  设置标题右边显示的值为该值</span></span><br><span class="line"><span class="tag">    <span class="attr">:min-year</span>=<span class="string">2000</span>  设置开始的年份</span></span><br><span class="line"><span class="tag">    <span class="attr">:max-year</span>=<span class="string">2016</span>  设置结束的年份</span></span><br><span class="line"><span class="tag">    <span class="attr">:compute-hours-function</span>=<span class="string">"computeHoursFunction"</span>  动态设置小时列表，例如： <span class="attr">computeHoursFunction</span> (<span class="attr">date</span>, <span class="attr">isToday</span>, <span class="attr">generateRange</span>) &#123;  <span class="attr">if</span> (<span class="attr">isToday</span>) &#123; <span class="attr">return</span> <span class="attr">generateRange</span>(<span class="attr">new</span> <span class="attr">Date</span>()<span class="attr">.getHours</span>(), <span class="attr">23</span>) &#125; <span class="attr">else</span> &#123; <span class="attr">return</span> <span class="attr">generateRange</span>(<span class="attr">0</span>, <span class="attr">23</span>) &#125; &#125;,</span></span><br><span class="line"><span class="tag">    <span class="attr">:compute-days-function</span>=<span class="string">"computeDaysFunction"</span>  动态设置日期列表，例如：<span class="attr">computeDaysFunction</span> (<span class="attr">options</span>, <span class="attr">generateRange</span>) &#123; <span class="attr">return</span> [<span class="attr">options.month</span>] // 日期的数值为当前的月份的数值&#125;,</span></span><br><span class="line"><span class="tag">    <span class="attr">year-row</span>=<span class="string">"&#123;value&#125;年"</span>  年份的渲染模板</span></span><br><span class="line"><span class="tag">    <span class="attr">month-row</span>=<span class="string">"&#123;value&#125;月"</span>  月份的渲染模板</span></span><br><span class="line"><span class="tag">    <span class="attr">day-row</span>=<span class="string">"&#123;value&#125;日"</span>  日期的渲染模板</span></span><br><span class="line"><span class="tag">    <span class="attr">hour-row</span>=<span class="string">"&#123;value&#125;点"</span>  小时的渲染模板</span></span><br><span class="line"><span class="tag">    <span class="attr">minute-row</span>=<span class="string">"&#123;value&#125;分"</span>  分钟的渲染模板</span></span><br><span class="line"><span class="tag">    <span class="attr">confirm-text</span>=<span class="string">"完成"</span>  设置确认按钮文字	，默认	<span class="attr">ok</span>(确认)</span></span><br><span class="line"><span class="tag">    <span class="attr">cancel-text</span>=<span class="string">"取消"</span>  设置取消按钮文字	，默认	<span class="attr">cancel</span>(取消)</span></span><br><span class="line"><span class="tag">    <span class="attr">clear-text</span>=<span class="string">"today"</span>  设置显示在取消和完成按钮中间的文字信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:required</span>=<span class="string">"true"</span>  设置为必填，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:show.sync</span>=<span class="string">"visibility"</span>  设置控制显示的变量，为<span class="attr">true</span>时显示日期时间弹出框</span></span><br><span class="line"><span class="tag">    <span class="attr">:order-map</span>=<span class="string">"&#123; year: 3, month: 2, day: 1 &#125;"</span>  设置弹出框中时间日期的自定义列顺序, 如` &#123;<span class="attr">year:</span> <span class="attr">1</span>, <span class="attr">month:</span> <span class="attr">2</span>, <span class="attr">day:</span> <span class="attr">3</span>, <span class="attr">hour:</span> <span class="attr">4</span>, <span class="attr">minute:</span> <span class="attr">5</span>, <span class="attr">noon:</span> <span class="attr">6</span>&#125;`</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-clear</span>=<span class="string">"clearValue"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"change"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-cancel</span>=<span class="string">"log('cancel')"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-confirm</span>=<span class="string">"onConfirm"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-hide</span>=<span class="string">"log('hide', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">datetime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>插件形式使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">plain</span> @<span class="attr">click.native</span>=<span class="string">"showPlugin"</span>&gt;</span>作为插件使用<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showPlugin () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$vux.datetime.show(&#123;</span><br><span class="line">    cancelText: <span class="string">'取消'</span>,</span><br><span class="line">    confirmText: <span class="string">'确定'</span>,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD HH'</span>,</span><br><span class="line">    value: <span class="string">'2017-05-20 18'</span>,</span><br><span class="line">    onConfirm (val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'plugin confirm'</span>, val)</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'plugin show'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onHide () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'plugin hide'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-11-form-preview（表单数据展示）"><a href="#5-11-form-preview（表单数据展示）" class="headerlink" title="5.11 form-preview（表单数据展示）"></a>5.11 form-preview（表单数据展示）</h3><h4 id="5-11-1-form-preview组件的功能"><a href="#5-11-1-form-preview组件的功能" class="headerlink" title="5.11.1 form-preview组件的功能"></a>5.11.1 form-preview组件的功能</h4><p>类似于一个table表单展示的组件，显示列表信息，还包含了顶部title信息和底部的button按钮的信息；</p>
<h4 id="5-11-2-form-preview组件的属性"><a href="#5-11-2-form-preview组件的属性" class="headerlink" title="5.11.2 form-preview组件的属性"></a>5.11.2 form-preview组件的属性</h4><table>
<thead>
<tr>
<th>form-preview组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header-label</td>
<td>string</td>
<td></td>
<td>头部标题</td>
</tr>
<tr>
<td>header-value</td>
<td>string</td>
<td></td>
<td>头部内容</td>
</tr>
<tr>
<td>body-items</td>
<td>array</td>
<td>[]</td>
<td>主体内容列表， <code>[{label:&#39;label&#39;,value:&#39;value&#39;}]</code></td>
</tr>
<tr>
<td>footer-buttons</td>
<td>array</td>
<td>[]</td>
<td>底部按钮列表，default 为灰色样式，primary 文字为高亮颜色， <code>[{style: &quot;primary&quot;, text: &quot;text&quot;, onButtonClick: fn(prop:name), link: &quot;/path&quot;}]</code></td>
</tr>
</tbody></table>
<h4 id="5-11-3-form-preview组件的注册"><a href="#5-11-3-form-preview组件的注册" class="headerlink" title="5.11.3 form-preview组件的注册"></a>5.11.3 form-preview组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FormPreview &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    FormPreview</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FormPreview &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'form-preview'</span>, FormPreview)</span><br></pre></td></tr></table></figure>
<h4 id="5-11-4-form-preview组件的使用"><a href="#5-11-4-form-preview组件的使用" class="headerlink" title="5.11.4 form-preview组件的使用"></a>5.11.4 form-preview组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form-preview</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:header-label</span>=<span class="string">"'付款金额'"</span>  设置标题的文字信息</span></span><br><span class="line"><span class="tag">  <span class="attr">header-value</span>=<span class="string">"¥2400.00"</span>  设置标题右侧的内容信息</span></span><br><span class="line"><span class="tag">  <span class="attr">:body-items</span>=<span class="string">"list"</span>  绑定显示的数据信息，注意格式为：[&#123;<span class="attr">label:</span>'<span class="attr">label</span>',<span class="attr">value:</span>'<span class="attr">value</span>'&#125;]</span></span><br><span class="line"><span class="tag">  <span class="attr">:footer-buttons</span>=<span class="string">"buttons"</span>  设置底部的按钮导航信息，注意格式为：[&#123;<span class="attr">style:</span> "<span class="attr">primary</span>", <span class="attr">text:</span> "<span class="attr">text</span>", <span class="attr">onButtonClick:</span> <span class="attr">fn</span>(<span class="attr">prop:name</span>), <span class="attr">link:</span> "/<span class="attr">path</span>"&#125;]</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">form-preview</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-12-group"><a href="#5-12-group" class="headerlink" title="5.12 group"></a>5.12 group</h3><h4 id="5-12-1-group组件的功能"><a href="#5-12-1-group组件的功能" class="headerlink" title="5.12.1 group组件的功能"></a>5.12.1 group组件的功能</h4><p>Group是一个特殊的<code>表单wrapper组件</code>，主要用于将表单分组，单个表单元素也算一组。常见的表单组件都必须作为Group的子组件， 属于Group子组件的有：<code>Cell, XInput, XTextarea, XSwitch, Calendar, XNumber, Radio, XAddress, Datetime, Selector</code></p>
<h4 id="5-12-2-group组件的属性、插槽和样式变量"><a href="#5-12-2-group组件的属性、插槽和样式变量" class="headerlink" title="5.12.2 group组件的属性、插槽和样式变量"></a>5.12.2 group组件的属性、插槽和样式变量</h4><table>
<thead>
<tr>
<th>group组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>分组标题</td>
</tr>
<tr>
<td>title-color</td>
<td>string</td>
<td></td>
<td>分组标题文字颜色</td>
</tr>
<tr>
<td>label-width</td>
<td>string</td>
<td></td>
<td>为子元素设定统一label宽度</td>
</tr>
<tr>
<td>label-align</td>
<td>string</td>
<td></td>
<td>为子元素设定统一对齐方式</td>
</tr>
<tr>
<td>label-margin-right</td>
<td>string</td>
<td></td>
<td>为子元素设定统一的右边margin</td>
</tr>
<tr>
<td>gutter</td>
<td>string</td>
<td></td>
<td>设定group的上边距，只能用于没有标题时</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>group组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>子组件插槽</td>
</tr>
<tr>
<td>title</td>
<td>标题插槽</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>group组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@group-title-margin-top</td>
<td>.77em</td>
<td>标题的margin-top</td>
</tr>
<tr>
<td>@group-title-margin-bottom</td>
<td>.3em</td>
<td>标题的margin-bottom</td>
</tr>
<tr>
<td>@group-footer-title-margin-top</td>
<td>.3em</td>
<td>底部标题的margin-top</td>
</tr>
<tr>
<td>@group-footer-title-margin-bottom</td>
<td>.77em</td>
<td>底部标题的margin-bottom</td>
</tr>
</tbody></table>
<h4 id="5-12-3-group组件的注册"><a href="#5-12-3-group组件的注册" class="headerlink" title="5.12.3 group组件的注册"></a>5.12.3 group组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Group &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Group</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Group &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'group'</span>, Group)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-12-4-group组件的使用"><a href="#5-12-4-group组件的使用" class="headerlink" title="5.12.4 group组件的使用"></a>5.12.4 group组件的使用</h4><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;group label-width<span class="built_in">=</span><span class="string">"4.5em"</span> label-margin-right<span class="built_in">=</span><span class="string">"2em"</span> label-align<span class="built_in">=</span><span class="string">"right"</span>&gt;</span><br><span class="line">      &lt;cell title<span class="built_in">=</span><span class="string">"Cell"</span> value<span class="built_in">=</span><span class="string">"value"</span> <span class="keyword">is</span>-link&gt;&lt;/cell&gt;</span><br><span class="line">      &lt;cell title<span class="built_in">=</span><span class="string">"Cell"</span> value<span class="built_in">=</span><span class="string">"value"</span> <span class="keyword">is</span>-link value-align<span class="built_in">=</span><span class="string">"left"</span>&gt;&lt;/cell&gt;</span><br><span class="line">      &lt;x-input title<span class="built_in">=</span><span class="string">"上报人"</span> v-model<span class="built_in">=</span><span class="string">"value1"</span>&gt;&lt;/x-input&gt;</span><br><span class="line">      &lt;x-input placeholder<span class="built_in">=</span><span class="string">"I'm placeholder"</span>&gt;</span><br><span class="line">        &lt;img slot<span class="built_in">=</span><span class="string">"restricted-label"</span> style<span class="built_in">=</span><span class="string">"display:inline-block;vertical-align:middle;"</span> src<span class="built_in">=</span><span class="string">"http://dn-placeholder.qbox.me/110x110/FF2D55/000"</span> width<span class="built_in">=</span><span class="string">"24"</span> height<span class="built_in">=</span><span class="string">"24"</span>&gt;</span><br><span class="line">      &lt;/x-input&gt;</span><br><span class="line">      &lt;x-input title<span class="built_in">=</span><span class="string">"上&lt;i class='vux-blank-half'&gt;&lt;/i&gt;报&lt;i class='vux-blank-half'&gt;&lt;/i&gt;人"</span> v-model<span class="built_in">=</span><span class="string">"value1"</span>&gt;&lt;/x-input&gt;</span><br><span class="line">      &lt;x-number title<span class="built_in">=</span><span class="string">"Quantity"</span> align<span class="built_in">=</span><span class="string">"left"</span> v-model<span class="built_in">=</span><span class="string">"numberValue"</span> button-style<span class="built_in">=</span><span class="string">"round"</span> :min<span class="built_in">=</span><span class="string">"0"</span> :max<span class="built_in">=</span><span class="string">"5"</span>&gt;&lt;/x-number&gt;</span><br><span class="line">      &lt;datetime title<span class="built_in">=</span><span class="string">"时&amp;emsp;&amp;emsp;&amp;nbsp;间"</span> v-model<span class="built_in">=</span><span class="string">"time1"</span> value-text-align<span class="built_in">=</span><span class="string">"left"</span>&gt;&lt;/datetime&gt;</span><br><span class="line">      &lt;selector title<span class="built_in">=</span><span class="string">"隐患类别"</span> :options<span class="built_in">=</span><span class="string">"['工艺技术', '其他']"</span> v-model<span class="built_in">=</span><span class="string">"value2"</span>&gt;&lt;/selector&gt;</span><br><span class="line">      &lt;selector title<span class="built_in">=</span><span class="string">"隐患类别"</span> placeholder<span class="built_in">=</span><span class="string">"Placeholder"</span> :options<span class="built_in">=</span><span class="string">"['工艺技术', '其他']"</span> v-model<span class="built_in">=</span><span class="string">"value7"</span>&gt;&lt;/selector&gt;</span><br><span class="line">      &lt;selector title<span class="built_in">=</span><span class="string">"隐患类别"</span> :options<span class="built_in">=</span><span class="string">"['工艺技术', '其他']"</span> v-model<span class="built_in">=</span><span class="string">"value8"</span>&gt;&lt;/selector&gt;</span><br><span class="line">      &lt;x-input title<span class="built_in">=</span><span class="string">"隐患部位"</span> placeholder<span class="built_in">=</span><span class="string">"必填"</span> v-model<span class="built_in">=</span><span class="string">"value3"</span>&gt;&lt;/x-input&gt;</span><br><span class="line">      &lt;x-input title<span class="built_in">=</span><span class="string">"密码"</span> <span class="keyword">type</span><span class="built_in">=</span><span class="string">"password"</span> placeholder<span class="built_in">=</span><span class="string">"必填"</span> v-model<span class="built_in">=</span><span class="string">"value4"</span>&gt;&lt;/x-input&gt;</span><br><span class="line">      &lt;popup-picker title<span class="built_in">=</span><span class="string">"请选择"</span> :data<span class="built_in">=</span><span class="string">"list"</span> v-model<span class="built_in">=</span><span class="string">"value5"</span> value-text-align<span class="built_in">=</span><span class="string">"left"</span>&gt;&lt;/popup-picker&gt;</span><br><span class="line">      &lt;popup-picker title<span class="built_in">=</span><span class="string">"请选择"</span> placeholder<span class="built_in">=</span><span class="string">"Required"</span> :data<span class="built_in">=</span><span class="string">"list"</span> v-model<span class="built_in">=</span><span class="string">"value6"</span> value-text-align<span class="built_in">=</span><span class="string">"left"</span>&gt;&lt;/popup-picker&gt;</span><br><span class="line">      &lt;x-address title<span class="built_in">=</span><span class="string">"地址选择"</span> v-model<span class="built_in">=</span><span class="string">"addressValue"</span> raw-value :list<span class="built_in">=</span><span class="string">"addressData"</span> value-text-align<span class="built_in">=</span><span class="string">"left"</span>&gt;&lt;/x-address&gt;</span><br><span class="line">      &lt;x-textarea title<span class="built_in">=</span><span class="string">"详细信息"</span> placeholder<span class="built_in">=</span><span class="string">"请填写详细信息"</span> :show-counter<span class="built_in">=</span><span class="string">"false"</span> :rows<span class="built_in">=</span><span class="string">"3"</span>&gt;&lt;/x-textarea&gt;</span><br><span class="line">      &lt;x-textarea placeholder<span class="built_in">=</span><span class="string">"请填写详细信息"</span> :show-counter<span class="built_in">=</span><span class="string">"false"</span> :rows<span class="built_in">=</span><span class="string">"3"</span>&gt;</span><br><span class="line">        &lt;img slot<span class="built_in">=</span><span class="string">"restricted-label"</span> style<span class="built_in">=</span><span class="string">"display:inline-block;vertical-align:middle;"</span> src<span class="built_in">=</span><span class="string">"http://dn-placeholder.qbox.me/110x110/FF2D55/000"</span> width<span class="built_in">=</span><span class="string">"24"</span> height<span class="built_in">=</span><span class="string">"24"</span>&gt;</span><br><span class="line">      &lt;/x-textarea&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;group&gt;</span><br><span class="line">      &lt;group-title slot<span class="built_in">=</span><span class="string">"title"</span>&gt;I<span class="string">'m a title&lt;span style="float:right;"&gt;right&lt;/span&gt;&lt;/group-title&gt;</span></span><br><span class="line"><span class="string">      &lt;cell title="cell"&gt;&lt;/cell&gt;</span></span><br><span class="line"><span class="string">    &lt;/group&gt;</span></span><br><span class="line"><span class="string">    &lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;group title="justify" label-width="5.5em" label-margin-right="2em" label-align="justify"&gt;</span></span><br><span class="line"><span class="string">      &lt;cell title="哈哈" value="value" is-link&gt;&lt;/cell&gt;</span></span><br><span class="line"><span class="string">      &lt;cell title="哈哈哈哈哈" value="value" is-link value-align="left"&gt;&lt;/cell&gt;</span></span><br><span class="line"><span class="string">      &lt;x-input title="上报人" v-model="value1"&gt;&lt;/x-input&gt;</span></span><br><span class="line"><span class="string">      &lt;x-number title="Quantity" align="left" v-model="numberValue" button-style="round" :min="0" :max="5"&gt;&lt;/x-number&gt;</span></span><br><span class="line"><span class="string">      &lt;datetime title="时间" v-model="time1" value-text-align="left"&gt;&lt;/datetime&gt;</span></span><br><span class="line"><span class="string">      &lt;selector title="隐患类别" :options="['</span>工艺技术<span class="string">', '</span>其他<span class="string">']" v-model="value2"&gt;&lt;/selector&gt;</span></span><br><span class="line"><span class="string">      &lt;popup-picker title="请选择" :data="list" v-model="value5" value-text-align="left"&gt;&lt;/popup-picker&gt;</span></span><br><span class="line"><span class="string">      &lt;x-address title="地址选择" v-model="addressValue" raw-value :list="addressData" value-text-align="left" label-align="justify"&gt;&lt;/x-address&gt;</span></span><br><span class="line"><span class="string">      &lt;x-switch title="选择"&gt;&lt;/x-switch&gt;</span></span><br><span class="line"><span class="string">      &lt;x-textarea title="详细信息" placeholder="请填写详细信息" :show-counter="false" :rows="3"&gt;&lt;/x-textarea&gt;</span></span><br><span class="line"><span class="string">    &lt;/group&gt;</span></span><br><span class="line"><span class="string">    &lt;br&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  import &#123; GroupTitle, Group, Cell, XInput, Selector, PopupPicker, Datetime, XNumber, ChinaAddressData, XAddress, XTextarea, XSwitch &#125; from '</span>vux<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      Group,</span></span><br><span class="line"><span class="string">      GroupTitle,</span></span><br><span class="line"><span class="string">      Cell,</span></span><br><span class="line"><span class="string">      XInput,</span></span><br><span class="line"><span class="string">      Selector,</span></span><br><span class="line"><span class="string">      PopupPicker,</span></span><br><span class="line"><span class="string">      XAddress,</span></span><br><span class="line"><span class="string">      Datetime,</span></span><br><span class="line"><span class="string">      XNumber,</span></span><br><span class="line"><span class="string">      XTextarea,</span></span><br><span class="line"><span class="string">      XSwitch</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    data () &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        addressData: ChinaAddressData,</span></span><br><span class="line"><span class="string">        addressValue: ['</span>广东省<span class="string">', '</span>深圳市<span class="string">', '</span>南山区<span class="string">'],</span></span><br><span class="line"><span class="string">        value1: '</span>张三<span class="string">',</span></span><br><span class="line"><span class="string">        value2: '</span>工艺技术<span class="string">',</span></span><br><span class="line"><span class="string">        value3: '</span><span class="string">',</span></span><br><span class="line"><span class="string">        value7: '</span><span class="string">',</span></span><br><span class="line"><span class="string">        value8: '</span><span class="string">',</span></span><br><span class="line"><span class="string">        value4: '</span><span class="string">',</span></span><br><span class="line"><span class="string">        time1: '</span><span class="number">2017</span>-<span class="number">06</span>-<span class="number">01</span><span class="string">',</span></span><br><span class="line"><span class="string">        value5: ['</span>A<span class="string">'],</span></span><br><span class="line"><span class="string">        value6: [],</span></span><br><span class="line"><span class="string">        list: [['</span>A<span class="string">', '</span>B<span class="string">', '</span>C<span class="string">']],</span></span><br><span class="line"><span class="string">        numberValue: 0</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-13-inline-x-switch（行内开关组件）"><a href="#5-13-inline-x-switch（行内开关组件）" class="headerlink" title="5.13 inline-x-switch（行内开关组件）"></a>5.13 inline-x-switch（行内开关组件）</h3><h4 id="5-13-1-inline-x-switch组件的功能"><a href="#5-13-1-inline-x-switch组件的功能" class="headerlink" title="5.13.1 inline-x-switch组件的功能"></a>5.13.1 inline-x-switch组件的功能</h4><p>inline-x-switch组件是一个行内的开关组件；</p>
<h4 id="5-13-2-inline-x-switch组件的属性、事件、插槽和样式变量"><a href="#5-13-2-inline-x-switch组件的属性、事件、插槽和样式变量" class="headerlink" title="5.13.2 inline-x-switch组件的属性、事件、插槽和样式变量"></a>5.13.2 inline-x-switch组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>inline-x-switch组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否不可点击</td>
</tr>
<tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>表单值, 使用v-model绑定</td>
</tr>
<tr>
<td>value-map</td>
<td>array</td>
<td>[false, true]</td>
<td>用于自定义 false 和 true 映射的实际值，用于方便处理比如接口返回了 0 1 这类非 boolean 值的情况</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>inline-x-switch组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>值变化时触发，参数为 (currentValue)</td>
</tr>
</tbody></table>
<h4 id="5-13-3-inline-x-switch组件的注册"><a href="#5-13-3-inline-x-switch组件的注册" class="headerlink" title="5.13.3 inline-x-switch组件的注册"></a>5.13.3 inline-x-switch组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InlineXSwitch &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    InlineXSwitch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; InlineXSwitch &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'inline-x-switch'</span>, InlineXSwitch)</span><br></pre></td></tr></table></figure>
<h4 id="5-13-4-inline-x-switch、x-switch组件的使用"><a href="#5-13-4-inline-x-switch、x-switch组件的使用" class="headerlink" title="5.13.4 inline-x-switch、x-switch组件的使用"></a>5.13.4 inline-x-switch、x-switch组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;inline-x-<span class="keyword">switch</span> </span><br><span class="line">  v-model=<span class="string">"value"</span>  通过v-model进行绑定，为<span class="literal">true</span>时打开</span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">inline-x-switch</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;group&gt;</span><br><span class="line">  &lt;x-<span class="keyword">switch</span></span><br><span class="line">    title=<span class="string">"switch"</span>  设置标题的内容信息</span><br><span class="line">    v-model=<span class="string">"value"</span>  通过v-model进行绑定，为<span class="literal">true</span>时打开</span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-switch</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-14-inline-x-number（增加减少数字的行内组件）"><a href="#5-14-inline-x-number（增加减少数字的行内组件）" class="headerlink" title="5.14 inline-x-number（增加减少数字的行内组件）"></a>5.14 inline-x-number（增加减少数字的行内组件）</h3><h4 id="5-14-1-inline-x-number组件的功能"><a href="#5-14-1-inline-x-number组件的功能" class="headerlink" title="5.14.1 inline-x-number组件的功能"></a>5.14.1 inline-x-number组件的功能</h4><p>该组件用于行内的数字增加与减少的显示；可以直接使用，也可以 <code>cell</code> 中使用；</p>
<h4 id="5-14-2-inline-x-number组件的属性"><a href="#5-14-2-inline-x-number组件的属性" class="headerlink" title="5.14.2 inline-x-number组件的属性"></a>5.14.2 inline-x-number组件的属性</h4><table>
<thead>
<tr>
<th>inline-x-number  组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>string</td>
<td>50px</td>
<td>数字所占据的宽度</td>
</tr>
<tr>
<td>button-style</td>
<td>string</td>
<td>square</td>
<td>按钮样式，可选[‘round’]</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td></td>
<td>最小值</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td></td>
<td>最大值</td>
</tr>
</tbody></table>
<h4 id="5-14-3-inline-x-number组件的注册"><a href="#5-14-3-inline-x-number组件的注册" class="headerlink" title="5.14.3 inline-x-number组件的注册"></a>5.14.3 inline-x-number组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InlineXNumber &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    InlineXNumber</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; InlineXNumber &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'inline-x-number'</span>, InlineXNumber)</span><br></pre></td></tr></table></figure>
<h4 id="5-14-4-inline-x-number组件的使用"><a href="#5-14-4-inline-x-number组件的使用" class="headerlink" title="5.14.4 inline-x-number组件的使用"></a>5.14.4 inline-x-number组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">inline-x-number</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">"50px"</span>  设置数字占据的宽度</span></span><br><span class="line"><span class="tag">  <span class="attr">button-style</span>=<span class="string">"round"</span>  设置增减符号的样式，默认为 <span class="attr">round</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:min</span>=<span class="string">"0"</span>  设置最小值</span></span><br><span class="line"><span class="tag">  <span class="attr">:max</span>=<span class="string">"10"</span>  设置最大值</span></span><br><span class="line"><span class="tag"> &gt;</span><span class="tag">&lt;/<span class="name">inline-x-number</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;group&gt;</span><br><span class="line">  &lt;cell :title&#x3D;&quot;&#39;Used within cell&#39;&quot;&gt;</span><br><span class="line">  &lt;inline-x-number style&#x3D;&quot;display:block;&quot; :min&#x3D;&quot;0&quot; width&#x3D;&quot;50px&quot; button-style&#x3D;&quot;round&quot;&gt;&lt;&#x2F;inline-x-number&gt;</span><br><span class="line">  &lt;&#x2F;cell&gt;</span><br><span class="line">&lt;&#x2F;group&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-15-inline-calendar（日历组件）"><a href="#5-15-inline-calendar（日历组件）" class="headerlink" title="5.15 inline-calendar（日历组件）"></a>5.15 inline-calendar（日历组件）</h3><h4 id="5-15-1-inline-calendar组件的功能"><a href="#5-15-1-inline-calendar组件的功能" class="headerlink" title="5.15.1 inline-calendar组件的功能"></a>5.15.1 inline-calendar组件的功能</h4><p>inline-calendar组件是一个日历组件，能够对日历进行操作，例如选择某一天，设置日历的一些规则，如：周末不可选，当前日期前/后不可选等等；</p>
<h4 id="5-15-2-inline-calendar组件的属性、事件、插槽和方法"><a href="#5-15-2-inline-calendar组件的属性、事件、插槽和方法" class="headerlink" title="5.15.2 inline-calendar组件的属性、事件、插槽和方法"></a>5.15.2 inline-calendar组件的属性、事件、插槽和方法</h4><table>
<thead>
<tr>
<th>inline-calendar组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string array</td>
<td></td>
<td>当前选中日期，使用v-model绑定。值为字符串(包括空字符串)时表示单选日期，为数组(包括空数组)时表示多选。    –</td>
</tr>
<tr>
<td>render-month</td>
<td>array</td>
<td></td>
<td>指定渲染日期，如 <code>[2018, 8]</code>    –</td>
</tr>
<tr>
<td>start-date</td>
<td>string</td>
<td></td>
<td>起始日期，格式为 <code>YYYY-MM-dd</code>–</td>
</tr>
<tr>
<td>end-date</td>
<td>string</td>
<td></td>
<td>结束日期，格式为<code>YYYY-MM-dd</code>    –</td>
</tr>
<tr>
<td>show-last-month</td>
<td>boolean</td>
<td>true</td>
<td>是否显示上个月的日期    –</td>
</tr>
<tr>
<td>show-next-month</td>
<td>boolean</td>
<td>true</td>
<td>是否显示下个月的日期    –</td>
</tr>
<tr>
<td>highlight-weekend</td>
<td>boolean</td>
<td>false</td>
<td>是否高亮周末    –</td>
</tr>
<tr>
<td>return-six-rows</td>
<td>boolean</td>
<td>true</td>
<td>是否总是渲染6行日期    –</td>
</tr>
<tr>
<td>hide-header</td>
<td>boolean</td>
<td>false</td>
<td>是否隐藏日历头部    –</td>
</tr>
<tr>
<td>hide-week-list</td>
<td>boolean</td>
<td>false</td>
<td>是否隐藏星期列表    –</td>
</tr>
<tr>
<td>replace-text-list</td>
<td>object</td>
<td></td>
<td>替换列表，可以将默认的日期换成文字，比如今天的日期替换成今，{‘TODAY’:’今’}    –</td>
</tr>
<tr>
<td>weeks-list</td>
<td>array</td>
<td>[‘Su’, ‘Mo’, ‘Tu’, ‘We’, ‘Th’, ‘Fr’, ‘Sa’]</td>
<td>星期列表，从周日开始    –</td>
</tr>
<tr>
<td>render-function</td>
<td>function</td>
<td></td>
<td>用于为特定日期添加额外的html内容，参数为(行index,列index,日期详细属性)    –</td>
</tr>
<tr>
<td>render-on-value-change</td>
<td>boolean</td>
<td>true</td>
<td>当日期变化时是否重新渲染日历，如果是渲染了多个日历的话需要设为false    –</td>
</tr>
<tr>
<td>disable-past</td>
<td>boolean</td>
<td>false</td>
<td>禁止选择过去的日期，该选项可以与 <code>start-date</code> 同时使用    –</td>
</tr>
<tr>
<td>disable-future</td>
<td>boolean</td>
<td>false</td>
<td>禁止选择未来的日期，该选项可以 <code>end-date</code> 同时使用    –</td>
</tr>
<tr>
<td>marks</td>
<td>array</td>
<td></td>
<td>(beta) 自定义日期标记    v2.6.0</td>
</tr>
<tr>
<td>disable-weekend</td>
<td>boolean</td>
<td>false</td>
<td>是否禁用周六日    v2.7.0</td>
</tr>
<tr>
<td>disable-date-function</td>
<td>function</td>
<td></td>
<td>自定义标记特定日期是否应该禁用，返回 true 表示禁用，false 表示不禁用，不返回表示和原有逻辑一致(这样不影响和 disable-weekend 等禁用属性同时使用)    v2.7.0</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>inline-calendar组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>–</td>
<td>值变化时触发    –</td>
</tr>
<tr>
<td>@on-view-change</td>
<td>(data, index)</td>
<td>渲染月份变化时触发。初始化时会触发一次，如果不希望处理初始化时的触发，可以检查第二个参数是否为 <code>0</code>    v2.5.12</td>
</tr>
<tr>
<td>@on-select-single-date</td>
<td>(currentValue)</td>
<td>单选模式下选中日期时触发    2.7.6</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>inline-calendar组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>each-day</td>
<td>用以自定义每一天的显示渲染，推荐使用该 slot 来替代 render-function</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>inline-calendar组件的方法名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getDates</td>
<td></td>
<td>获取当前日期列表    v2.5.11</td>
</tr>
<tr>
<td>switchViewToToday</td>
<td></td>
<td>渲染当天所在月份    v2.5.12</td>
</tr>
<tr>
<td>switchViewToMonth</td>
<td>(year, month)</td>
<td>渲染特定年月日期    v2.5.12</td>
</tr>
<tr>
<td>switchViewToCurrentValue</td>
<td></td>
<td>渲染当前值所在月份    v2.5.12</td>
</tr>
</tbody></table>
<h4 id="5-15-3-inline-calendar组件的注册"><a href="#5-15-3-inline-calendar组件的注册" class="headerlink" title="5.15.3 inline-calendar组件的注册"></a>5.15.3 inline-calendar组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InlineCalendar &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    InlineCalendar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; InlineCalendar &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'inline-calendar'</span>, InlineCalendar)</span><br></pre></td></tr></table></figure>
<h4 id="5-15-4-inline-calendar组件的使用"><a href="#5-15-4-inline-calendar组件的使用" class="headerlink" title="5.15.4 inline-calendar组件的使用"></a>5.15.4 inline-calendar组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">inline-calendar</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"calendar"</span>  设置<span class="attr">refs</span>属性，用于获取该元素并进行该组件的方法的操作，如：选择今天为$<span class="attr">refs.calendar.switchViewToToday</span>();选择<span class="attr">2017</span>年<span class="attr">12</span>月为$<span class="attr">refs.calendar.switchViewToMonth</span>(<span class="attr">2017</span>, <span class="attr">12</span>);渲染当前值所在月份为$<span class="attr">refs.calendar.switchViewToCurrentValue</span>()</span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"inline-calendar-demo"</span>  设置组件的<span class="attr">class</span>类</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"value"</span>  当前选中日期，使用<span class="attr">v-model</span>绑定。该值为字符串(包括空字符串)时表示单选日期，为数组(包括空数组)时表示多选，'<span class="attr">TODAY</span>'表示选择今天的日期。</span></span><br><span class="line"><span class="tag">  <span class="attr">start-date</span>=<span class="string">"2016-04-01"</span>  设置起始日期</span></span><br><span class="line"><span class="tag">  <span class="attr">end-date</span>=<span class="string">"2018-05-30"</span>  设置终止日期</span></span><br><span class="line"><span class="tag">  <span class="attr">:show.sync</span>=<span class="string">"show"</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">:range</span>=<span class="string">"range"</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">:show-last-month</span>=<span class="string">"showLastMonth"</span>  设置是否显示上个月日期，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show-next-month</span>=<span class="string">"showNextMonth"</span>  设置是否显示下个月日期，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:highlight-weekend</span>=<span class="string">"highlightWeekend"</span>  设置是否高亮周末日期，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:return-six-rows</span>=<span class="string">"return6Rows"</span>  设置是否总是渲染<span class="attr">6</span>行日期，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:hide-header</span>=<span class="string">"hideHeader"</span>  设置是否隐藏日历头部，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:hide-week-list</span>=<span class="string">"hideWeekList"</span>  设置是否隐藏星期列表：日一二三四五六，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:replace-text-list</span>=<span class="string">"replaceTextList"</span>  替换列表，可以将默认的日期换成文字，比如今天的日期替换成今，如：<span class="attr">replace</span> (<span class="attr">val</span>) &#123; <span class="attr">this.replaceTextList</span> = <span class="string">val</span> ? &#123; '<span class="attr">TODAY</span>'<span class="attr">:</span> '今' &#125; <span class="attr">:</span> &#123;&#125; &#125;,位于<span class="attr">watch</span>中</span></span><br><span class="line"><span class="tag">  <span class="attr">:weeks-list</span>=<span class="string">"weeksList"</span>  	星期列表，从周日开始，默认：['<span class="attr">Su</span>', '<span class="attr">Mo</span>', '<span class="attr">Tu</span>', '<span class="attr">We</span>', '<span class="attr">Th</span>', '<span class="attr">Fr</span>', '<span class="attr">Sa</span>']，可以进行修改，例如：<span class="attr">changeWeeksList</span> (<span class="attr">val</span>) &#123; <span class="attr">this.weeksList</span> = <span class="string">val</span> ? ['日', '一', '二', '三', '四', '五', '六 '] <span class="attr">:</span> ['<span class="attr">Su</span>', '<span class="attr">Mo</span>', '<span class="attr">Tu</span>', '<span class="attr">We</span>', '<span class="attr">Th</span>', '<span class="attr">Fr</span>', '<span class="attr">Sa</span>'] &#125;,位于<span class="attr">watch</span>中</span></span><br><span class="line"><span class="tag">  <span class="attr">:render-function</span>=<span class="string">"buildSlotFn"</span>  用于为特定日期添加额外的<span class="attr">html</span>内容，参数为(行<span class="attr">index</span>,列<span class="attr">index</span>,日期详细属性)，如为<span class="attr">8</span>结尾的日期加红点：<span class="attr">useCustomFn</span> (<span class="attr">val</span>) &#123; <span class="attr">this.buildSlotFn</span> = <span class="string">val</span> ? (<span class="attr">line</span>, <span class="attr">index</span>, <span class="attr">data</span>) =&gt;</span> &#123; return /8/.test(data.date) ? '<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:12px;text-align:center;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"display:inline-block;width:5px;height:5px;background-color:red;border-radius:50%;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>' : '<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:19px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125; : () =&gt; '' &#125;,位于watch中</span><br><span class="line">  :disable-past="disablePast"   设置禁止选择过去的日期，该选项可以与 `start-date` 同时使用，默认false</span><br><span class="line">  :disable-future="disableFuture"   设置禁止选择未来的日期，该选项可以与 `end-date` 同时使用，默认false</span><br><span class="line">  :disable-weekend="disableWeekend"   设置禁止选择周末的日期，默认false</span><br><span class="line">  :disable-date-function="disableDateFunction"  自定义标记特定日期是否应该禁用，返回 true 表示禁用，false 表示不禁用，不返回表示和原有逻辑一致(这样不影响和 disable-weekend 等禁用属性同时使用)</span><br><span class="line"></span><br><span class="line">  @on-change="onChange"  日期值变化时触发</span><br><span class="line">  @on-view-change="onViewChange"  渲染月份变化时触发。初始化时会触发一次，如果不希望处理初始化时的触发，可以检查第二个参数是否为 `0`</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">inline-calendar</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-16-popup-picker-底部弹出框进行选择元素"><a href="#5-16-popup-picker-底部弹出框进行选择元素" class="headerlink" title="5.16 popup-picker(底部弹出框进行选择元素)"></a>5.16 popup-picker(底部弹出框进行选择元素)</h3><h4 id="5-16-1-popup-picker组件的功能"><a href="#5-16-1-popup-picker组件的功能" class="headerlink" title="5.16.1 popup-picker组件的功能"></a>5.16.1 popup-picker组件的功能</h4><p>选择框中元素可以是单列，也可以说多列选择，在多列中还可以设置联动选择，其他选项与picker一致，应该是在<code>Group</code>中使用；</p>
<h4 id="5-16-2-popup-picker组件的属性、事件、插槽"><a href="#5-16-2-popup-picker组件的属性、事件、插槽" class="headerlink" title="5.16.2 popup-picker组件的属性、事件、插槽"></a>5.16.2 popup-picker组件的属性、事件、插槽</h4><table>
<thead>
<tr>
<th>popup-picker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>array</td>
<td></td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>cancel-text</td>
<td>string</td>
<td></td>
<td>弹窗的取消文字</td>
</tr>
<tr>
<td>confirm-text</td>
<td>string</td>
<td></td>
<td>弹窗的确认文字</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>提示文字</td>
</tr>
<tr>
<td>show-name</td>
<td>boolean</td>
<td>false</td>
<td>是否显示文字值而不是key</td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>Cell的描述文字</td>
</tr>
<tr>
<td>show</td>
<td>boolean</td>
<td></td>
<td>显示 (支持.sync修饰 next)</td>
</tr>
<tr>
<td>value-text-align</td>
<td>string</td>
<td>right</td>
<td>value 对齐方式(text-align)    v2.1.0-rc.3</td>
</tr>
<tr>
<td>display-format</td>
<td>function</td>
<td></td>
<td>自定义在cell上的显示格式，参数为当前 value，使用该属性时，show-name 属性将失效    v2.1.1-rc.7</td>
</tr>
<tr>
<td>popup-style</td>
<td>object</td>
<td></td>
<td>弹窗样式，可以用于强制指定 z-index    v2.5.2</td>
</tr>
<tr>
<td>popup-title</td>
<td>string</td>
<td></td>
<td>弹窗标题    v2.7.0</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否禁用选择    v2.9.0</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup-picker组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>值变化时触发    –</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗出现时触发    –</td>
</tr>
<tr>
<td>@on-hide</td>
<td>(closeType)true表示confirm(选择确认), false表示其他情况的关闭</td>
<td>弹窗关闭时触发    –</td>
</tr>
<tr>
<td>@on-shadow-change</td>
<td>(Array ids, Array names)</td>
<td>picker 值变化时触发，即滑动 picker 时触发    v2.5.6</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup-picker组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>标题插槽，使用 <code>scope.labelClass 和 scope.labelStyle</code>   继承原有样式(实现样式受控于 <code>group label</code>设置)</td>
</tr>
</tbody></table>
<h4 id="5-16-3-popup-picker组件的注册"><a href="#5-16-3-popup-picker组件的注册" class="headerlink" title="5.16.3 popup-picker组件的注册"></a>5.16.3 popup-picker组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PopupPicker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    PopupPicker</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; PopupPicker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'popup-picker'</span>, PopupPicker)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-16-4-popup-picker组件的使用"><a href="#5-16-4-popup-picker组件的使用" class="headerlink" title="5.16.4 popup-picker组件的使用"></a>5.16.4 popup-picker组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">popup-picker</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"value"</span>  使用<span class="attr">v-model</span>绑定的表单值，为数组类型数据；</span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"title"</span>  设置展示的<span class="attr">cell</span>的标题文字信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:placeholder</span>=<span class="string">"'please select'"</span>  设置展示的<span class="attr">cell</span>的提示信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">"list"</span>  设置绑定的数据，弹出框中的内容，为一个数组类型的数据，子元素也是数组，有几个子元素表示有几行数据，若设置几行之间有联动关系，为对象数组，对象需要设置`<span class="attr">name</span>/<span class="attr">value</span>/<span class="attr">parent</span>`属性</span></span><br><span class="line"><span class="tag">    <span class="attr">:popup-title</span>=<span class="string">"'please select'"</span>  设置弹出框的顶部的标题信息，位于确定和取消之间</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-show</span>=<span class="string">"onShow"</span>  弹窗出现时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-hide</span>=<span class="string">"onHide"</span>  弹窗关闭时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"onChange"</span>  值变化时触发</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span><span class="comment">&lt;!-- use scope="props" when vue &lt; 2.5.0 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">"props.labelClass"</span> <span class="attr">:style</span>=<span class="string">"props.labelStyle"</span> <span class="attr">style</span>=<span class="string">"height:24px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"demo-icon demo-icon-big"</span> <span class="attr">style</span>=<span class="string">"font-size:20px;vertical-align:middle;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"vertical-align:middle;"</span>&gt;</span>手机<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">popup-picker</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-17-popup-radio（弹出选择单选框）"><a href="#5-17-popup-radio（弹出选择单选框）" class="headerlink" title="5.17 popup-radio（弹出选择单选框）"></a>5.17 popup-radio（弹出选择单选框）</h3><h4 id="5-17-1-popup-radio组件的功能"><a href="#5-17-1-popup-radio组件的功能" class="headerlink" title="5.17.1 popup-radio组件的功能"></a>5.17.1 popup-radio组件的功能</h4><p>popup-radio属性同 <code>cell</code> 和 <code>Radio</code> 的属性，需要注意的是不支持 <code>fillMode</code>，同时在<code>group</code>中使用；</p>
<h4 id="5-17-2-popup-radio组件的属性、事件、插槽"><a href="#5-17-2-popup-radio组件的属性、事件、插槽" class="headerlink" title="5.17.2 popup-radio组件的属性、事件、插槽"></a>5.17.2 popup-radio组件的属性、事件、插槽</h4><table>
<thead>
<tr>
<th>popup-radio组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>readonly</td>
<td>string</td>
<td></td>
<td>只读样式，类似于 <code>cell</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup-radio组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗显示时触发    v2.6.5</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗关闭时触发 v2.6.5</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup-radio组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>popup-header</td>
<td>弹窗顶部    v2.3.3</td>
</tr>
<tr>
<td>each-item</td>
<td>自定义每个条目显示内容    v2.3.7</td>
</tr>
</tbody></table>
<h4 id="5-17-3-popup-radio组件的注册"><a href="#5-17-3-popup-radio组件的注册" class="headerlink" title="5.17.3 popup-radio组件的注册"></a>5.17.3 popup-radio组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PopupRadio &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    PopupRadio</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; PopupRadio &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'popup-radio'</span>, PopupRadio)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-17-4-popup-radio组件的使用"><a href="#5-17-4-popup-radio组件的使用" class="headerlink" title="5.17.4 popup-radio组件的使用"></a>5.17.4 popup-radio组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">popup-radio</span></span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"options"</span>  设置标题的文字信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">"options"</span>  设置弹出框的选项内容，为一个数组类型数据</span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"option"</span>  使用<span class="attr">v-model</span>进行数据绑定</span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"placeholder"</span>  提示信息</span></span><br><span class="line"><span class="tag">    <span class="attr">readonly</span>  设置为只读</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"popup-header"</span> <span class="attr">class</span>=<span class="string">"vux-1px-b demo3-slot"</span>&gt;</span>Please select<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  弹窗顶部内容插槽</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span> <span class="attr">slot</span>=<span class="string">"each-item"</span>&gt;</span>  自定义每个条目显示内容</span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        custom item <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"vux-radio-icon"</span>&gt;</span> &#123;&#123; props.label &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:#666;"</span>&gt;</span>&#123;&#123; props.index + 1 &#125;&#125; another line<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">popup-radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-18-picker（弹出框选择信息，可以单列、多列、多列联动）"><a href="#5-18-picker（弹出框选择信息，可以单列、多列、多列联动）" class="headerlink" title="5.18 picker（弹出框选择信息，可以单列、多列、多列联动）"></a>5.18 picker（弹出框选择信息，可以单列、多列、多列联动）</h3><h4 id="5-18-1-picker组件的功能"><a href="#5-18-1-picker组件的功能" class="headerlink" title="5.18.1 picker组件的功能"></a>5.18.1 picker组件的功能</h4><p>弹出框选择信息，注意请确保列表项的value值是字符串，使用数字会出错。 如果你的业务接口返回数字值为数字，需要你先处理成字符串；同样，获取到值时为字符串，你需要自己转换成数字。注意多列以及多列联动对于的数据的格式，分别是数组的数组和对象的数组；</p>
<p>Picker是指提供多个选项集合供用户选择其中一项的控件。Picker展示区域有限，部分选项会被隐藏，最好是当用户对所有选项都比较熟悉、有预期的时候，才使用Picker。</p>
<ul>
<li>合理的默认选项能让用户减少操作次数，提升效率。</li>
<li>选项的排列顺序要依据当前上下文情景而定，例如衣服尺码按从小到大的顺序排列，而不是根据衣服尺码的首字母在字母表的顺序排列。</li>
<li>滚轮选择器控制在五列以内。为了保证手机屏幕触控精度，以免发生误触，滚轮选择器建议控制在五列以内。</li>
<li>使用相对概念增强感知。比起绝对的“某年某月日”，用“今天”、“昨天”等相对概念，能更快的激发人对时间的感知。</li>
<li>如果选项非常多，而且选项本身比较复杂难理解需要辅助的解释，建议用容纳更多的选项的其他形式，例如日历或者新页面</li>
</ul>
<h4 id="5-18-2-picker组件的属性、事件、方法"><a href="#5-18-2-picker组件的属性、事件、方法" class="headerlink" title="5.18.2 picker组件的属性、事件、方法"></a>5.18.2 picker组件的属性、事件、方法</h4><table>
<thead>
<tr>
<th>picker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>array</td>
<td></td>
<td>表单值，使用 v-model 绑定</td>
</tr>
<tr>
<td>data</td>
<td>array</td>
<td></td>
<td>选项列表数据</td>
</tr>
<tr>
<td>columns</td>
<td>number</td>
<td></td>
<td>指定联动模式下的列数，当不指定时表示非联动</td>
</tr>
<tr>
<td>fixed-columns</td>
<td>number</td>
<td></td>
<td>指定显示多少列，隐藏多余的</td>
</tr>
<tr>
<td>column-width</td>
<td>array</td>
<td></td>
<td>定义每一列宽度，只需要定义除最后一列宽度，最后一列自动宽度， 比如对于3列选择，可以这样：[1/2, 1/5]</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>picker组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>选择值变化时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>picker组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getNameValues</td>
<td></td>
<td>根据 value 获取字面值</td>
</tr>
</tbody></table>
<h4 id="5-18-3-picker组件的注册"><a href="#5-18-3-picker组件的注册" class="headerlink" title="5.18.3 picker组件的注册"></a>5.18.3 picker组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Picker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Picker</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Picker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'picker'</span>, Picker)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-18-4-picker组件的使用"><a href="#5-18-4-picker组件的使用" class="headerlink" title="5.18.4 picker组件的使用"></a>5.18.4 picker组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picker</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"picker"</span>  设置<span class="attr">refs</span>属性</span></span><br><span class="line"><span class="tag">  <span class="attr">:data</span>=<span class="string">'years'</span>  设置选项列表数据</span></span><br><span class="line"><span class="tag">  <span class="attr">:fixed-columns</span>=<span class="string">"2"</span>  指定显示多少列，隐藏多余的</span></span><br><span class="line"><span class="tag">  <span class="attr">:columns</span>=<span class="string">3</span>  指定联动模式下的列数，当不指定时表示非联动，联动的数据数组注意格式</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">'year'</span>  使用 <span class="attr">v-model</span> 绑定表单值</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-change</span>=<span class="string">'change'</span>  选择值变化时触发事件</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">picker</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-19-rater-类始于五星评分组件"><a href="#5-19-rater-类始于五星评分组件" class="headerlink" title="5.19 rater(类始于五星评分组件)"></a>5.19 rater(类始于五星评分组件)</h3><h4 id="5-19-1-rater组件的功能"><a href="#5-19-1-rater组件的功能" class="headerlink" title="5.19.1 rater组件的功能"></a>5.19.1 rater组件的功能</h4><p>该组件的功能就是五星评分组件的功能；</p>
<h4 id="5-19-2-rater组件的属性"><a href="#5-19-2-rater组件的属性" class="headerlink" title="5.19.2 rater组件的属性"></a>5.19.2 rater组件的属性</h4><table>
<thead>
<tr>
<th>rater组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max</td>
<td>number</td>
<td>5    最多可选个数</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td>number</td>
<td>0</td>
<td>值，使用 v-model 绑定</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>fals</td>
<td>是否禁用</td>
</tr>
<tr>
<td>star</td>
<td>string</td>
<td>★</td>
<td>字符</td>
</tr>
<tr>
<td>active-color</td>
<td>string</td>
<td>#fc6</td>
<td>选中时的颜色</td>
</tr>
<tr>
<td>margin</td>
<td>number</td>
<td>2</td>
<td>间隙值</td>
</tr>
<tr>
<td>font-size</td>
<td>number</td>
<td>25</td>
<td>字体大小</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td>0</td>
<td>最小值</td>
</tr>
</tbody></table>
<h4 id="5-19-3-rater组件的注册"><a href="#5-19-3-rater组件的注册" class="headerlink" title="5.19.3 rater组件的注册"></a>5.19.3 rater组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Rater &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Rater</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Rater &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'rater'</span>, Rater)</span><br></pre></td></tr></table></figure>
<h4 id="5-19-3-rater组件的使用"><a href="#5-19-3-rater组件的使用" class="headerlink" title="5.19.3 rater组件的使用"></a>5.19.3 rater组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">title</span>=<span class="string">"Normal Usage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span> <span class="attr">title</span>=<span class="string">"'cell标题'"</span> <span class="attr">inline-desc</span>=<span class="string">"total 5 stars if not specified"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rater</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"data3"</span>  使用<span class="attr">v-model</span>绑定选择的值</span></span><br><span class="line"><span class="tag">      <span class="attr">:min</span>=<span class="string">"2"</span>  设置最少可选个数，默认是<span class="attr">0</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:max</span>=<span class="string">"6"</span>  设置最多可选个数，默认是<span class="attr">5</span></span></span><br><span class="line"><span class="tag">      <span class="attr">active-color</span>=<span class="string">"#04BE02"</span>  设置选中时的颜色，默认#<span class="attr">fc6</span></span></span><br><span class="line"><span class="tag">      <span class="attr">star</span>=<span class="string">"♡"</span>  设置选择的字符，默认★，还可以是 ☼、☻、♥、✩、囧、❤等等</span></span><br><span class="line"><span class="tag">      <span class="attr">:margin</span>=<span class="string">"15"</span>  设置间隙值，默认为<span class="attr">2</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">rater</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-20-radio（单选组件，类似于html元素radio）"><a href="#5-20-radio（单选组件，类似于html元素radio）" class="headerlink" title="5.20 radio（单选组件，类似于html元素radio）"></a>5.20 radio（单选组件，类似于html元素radio）</h3><h4 id="5-20-1-radio组件的功能"><a href="#5-20-1-radio组件的功能" class="headerlink" title="5.20.1 radio组件的功能"></a>5.20.1 radio组件的功能</h4><p>单选组件，radio的options可以为简单数组，也可以为key=&gt;value形式键值对：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [ <span class="string">'China'</span>, <span class="string">'Japan'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options2 = [&#123;</span><br><span class="line">  icon: <span class="string">'http://dn-placeholder.qbox.me/110x110/FF2D55/000'</span>,</span><br><span class="line">  key: <span class="string">'001'</span>,</span><br><span class="line">  value: <span class="string">'radio001'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  icon: <span class="string">'http://dn-placeholder.qbox.me/110x110/FF2D55/000'</span>,</span><br><span class="line">  key: <span class="string">'002'</span>,</span><br><span class="line">  value: <span class="string">'radio002'</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>注意<code>radio</code>只能在<code>Group</code>中使用；</p>
<h4 id="5-20-2-radio组件的属性、插槽和样式变量"><a href="#5-20-2-radio组件的属性、插槽和样式变量" class="headerlink" title="5.20.2 radio组件的属性、插槽和样式变量"></a>5.20.2 radio组件的属性、插槽和样式变量</h4><table>
<thead>
<tr>
<th>radio组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>options</td>
<td>array</td>
<td></td>
<td>可选列表，可以用字符串组成的数组或者 key=&gt;value 的形式</td>
</tr>
<tr>
<td>fill-mode</td>
<td>boolean</td>
<td>false</td>
<td>是否可填写</td>
</tr>
<tr>
<td>fill-placeholder</td>
<td>string</td>
<td></td>
<td>可填写时的提示文字</td>
</tr>
<tr>
<td>fill-label</td>
<td>string</td>
<td></td>
<td>可填写时的label文字</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td></td>
<td>禁用操作    v2.3.8</td>
</tr>
<tr>
<td>selected-label-style</td>
<td>object</td>
<td></td>
<td>设置选中时的 label 样式，比如使用其他颜色更容易区分是否为选中项</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>radio组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>each-item</td>
<td>自定义如何显示每一项</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>radio组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@radio-checked-icon-color</td>
<td>#09BB07</td>
<td>选中状态的图标颜色</td>
</tr>
</tbody></table>
<h4 id="5-20-3-radio组件的注册"><a href="#5-20-3-radio组件的注册" class="headerlink" title="5.20.3 radio组件的注册"></a>5.20.3 radio组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Radio &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Radio</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Radio &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'radio'</span>, Radio)</span><br></pre></td></tr></table></figure>
<h4 id="5-20-4-radio组件的使用"><a href="#5-20-4-radio组件的使用" class="headerlink" title="5.20.4 radio组件的使用"></a>5.20.4 radio组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"title"</span>  设置标题的文字信息</span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">"options"</span>  设置选项的内容，为数组类型数据</span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"value"</span>  使用<span class="attr">v-model</span>绑定表单选中的值</span></span><br><span class="line"><span class="tag">    <span class="attr">disabled</span>  设置禁止操作</span></span><br><span class="line"><span class="tag">    <span class="attr">fill-mode</span>  设置可以填写，默认是<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill-label</span>=<span class="string">"Other"</span>  可填写时的<span class="attr">label</span>文字</span></span><br><span class="line"><span class="tag">    <span class="attr">fill-placeholder</span>=<span class="string">"填写其他的哦"</span>  可填写时的提示文字</span></span><br><span class="line"><span class="tag">    <span class="attr">:selected-label-style</span>=<span class="string">"&#123;color: '#FF9900'&#125;"</span>  设置选中状态的颜色</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"change"</span>  改变值时触发的事件</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span> <span class="attr">slot</span>=<span class="string">"each-item"</span>&gt;</span><span class="comment">&lt;!-- use scope="props" when vue &lt; 2.5.0 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        V&#123;&#123; props.index + 1 &#125;&#125; <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">...</span>" <span class="attr">class</span>=<span class="string">"vux-radio-icon"</span>&gt;</span> &#123;&#123; props.label &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-21-range（滑动进度条切换数值的组件）"><a href="#5-21-range（滑动进度条切换数值的组件）" class="headerlink" title="5.21 range（滑动进度条切换数值的组件）"></a>5.21 range（滑动进度条切换数值的组件）</h3><h4 id="5-21-1-range组件的功能"><a href="#5-21-1-range组件的功能" class="headerlink" title="5.21.1 range组件的功能"></a>5.21.1 range组件的功能</h4><p>滑动一个横向的线的进度条，类始于看电影的滑动进度条的功能组件；</p>
<h4 id="5-21-2-range组件的属性、事件和样式变量"><a href="#5-21-2-range组件的属性、事件和样式变量" class="headerlink" title="5.21.2 range组件的属性、事件和样式变量"></a>5.21.2 range组件的属性、事件和样式变量</h4><table>
<thead>
<tr>
<th>range组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>number</td>
<td>0</td>
<td>表单值，使用v-model绑定    –</td>
</tr>
<tr>
<td>decimal</td>
<td>boolean</td>
<td>false</td>
<td>是否在变化时显示小数    –</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td>0</td>
<td>可选最小值    –</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td>100</td>
<td>可选最大值    –</td>
</tr>
<tr>
<td>step</td>
<td>number</td>
<td>1</td>
<td>步长    –</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否禁用    –</td>
</tr>
<tr>
<td>minHTML</td>
<td>string</td>
<td></td>
<td>最小值显示的html模板    –</td>
</tr>
<tr>
<td>maxHTML</td>
<td>string</td>
<td></td>
<td>最大值显示的html模板    –</td>
</tr>
<tr>
<td>disabled-opacity</td>
<td>number</td>
<td></td>
<td>禁用样式的透明度    –</td>
</tr>
<tr>
<td>rangeBarHeight</td>
<td>number</td>
<td>1</td>
<td>高度    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>range组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>绑定值变化时触发事件    v2.2.2</td>
</tr>
<tr>
<td>@on-touchstart</td>
<td>(event)</td>
<td>手指放到元素上时触发    v2.9.2</td>
</tr>
<tr>
<td>@on-touchend</td>
<td>(event)</td>
<td>手指离开元素时触发    v2.9.2</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>range组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@range-disabled-opacity</td>
<td>0.5</td>
<td>–    @opacity-disabled</td>
</tr>
<tr>
<td>@range-bar-default-color</td>
<td>灰色#a9acb1</td>
<td>–</td>
</tr>
<tr>
<td>@range-bar-active-color</td>
<td>草绿色#04BE02</td>
<td>–    @theme-color</td>
</tr>
</tbody></table>
<h4 id="5-21-3-range组件的注册"><a href="#5-21-3-range组件的注册" class="headerlink" title="5.21.3 range组件的注册"></a>5.21.3 range组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Range &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Range</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Range &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'range'</span>, Range)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-21-4-range组件的使用"><a href="#5-21-4-range组件的使用" class="headerlink" title="5.21.4 range组件的使用"></a>5.21.4 range组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">title</span>=<span class="string">"default range"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span> <span class="attr">title</span>=<span class="string">"Default"</span> <span class="attr">:inline-desc</span>=<span class="string">"'value: '+data1"</span> <span class="attr">primary</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">range</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"data"</span>  使用<span class="attr">v-model</span>绑定表单值</span></span><br><span class="line"><span class="tag">      <span class="attr">decimal</span>  设置在变化时显示小数，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:min</span>=<span class="string">"8"</span>  设置最小值为<span class="attr">8</span>，默认<span class="attr">0</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:max</span>=<span class="string">"80"</span>  设置最大值为<span class="attr">80</span>，默认<span class="attr">100</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:step</span>=<span class="string">"10"</span>  设置步长为<span class="attr">10</span>，默认<span class="attr">1</span></span></span><br><span class="line"><span class="tag">      <span class="attr">disabled</span>  设置不可操作</span></span><br><span class="line"><span class="tag">      <span class="attr">:disabled-opacity</span>=<span class="string">"0.1"</span>  设置禁用样式的透明度</span></span><br><span class="line"><span class="tag">      <span class="attr">:range-bar-height</span>=<span class="string">"4"</span>  设置线的高度，默认<span class="attr">1px</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">on-change</span>=<span class="string">"onChange"</span>  绑定值变化时触发事件</span></span><br><span class="line"><span class="tag">      @<span class="attr">on-touchstart</span>=<span class="string">"onTouchstart"</span>  手指放到元素上时触发</span></span><br><span class="line"><span class="tag">      @<span class="attr">on-touchend</span>=<span class="string">"onTouchend"</span>  手指离开元素时触发</span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-22-selector（弹出选择框）"><a href="#5-22-selector（弹出选择框）" class="headerlink" title="5.22 selector（弹出选择框）"></a>5.22 selector（弹出选择框）</h3><h4 id="5-22-1-selector组件的功能"><a href="#5-22-1-selector组件的功能" class="headerlink" title="5.22.1 selector组件的功能"></a>5.22.1 selector组件的功能</h4><p>注意 <code>selector</code>只能在 <code>Group</code> 中使用，在iOS上，如果没有指定<code>placeholder</code>也没有指定<code>value</code>，会出现弹出选择框时默认选中第一个值，但是确定后依然没有选中的情况。<br>因此对于<code>iOS</code>，组件内部在列表项前面增加了一个<code>空的option</code>，强制用户滑动选择一次以避免上面的问题。</p>
<h4 id="5-22-2-selector组件的属性、事件、方法"><a href="#5-22-2-selector组件的属性、事件、方法" class="headerlink" title="5.22.2 selector组件的属性、事件、方法"></a>5.22.2 selector组件的属性、事件、方法</h4><table>
<thead>
<tr>
<th>selector组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string number object</td>
<td></td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>direction</td>
<td>string</td>
<td></td>
<td>选项对齐方式，同原生 select 属性一致，可选值为 <code>ltr(left-to-right，默认), rtl</code></td>
</tr>
<tr>
<td>options</td>
<td>array</td>
<td></td>
<td>选项列表，可以为简单数组，或者 <code>{ key: KEY, value: VALUE }</code> 结构的键值对数组。当使用键值对时，返回的<code>value为key</code>的值</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td></td>
<td>表单的name名字</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>提示文字</td>
</tr>
<tr>
<td>readonly</td>
<td>boolean</td>
<td>false</td>
<td>是否不可选择</td>
</tr>
<tr>
<td>value-map</td>
<td>array</td>
<td></td>
<td>设置键值对映射用以自动转换接口数据, 如 <code>[&#39;value&#39;, &#39;label&#39;]</code>    v2.7.2</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>selector组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>值变化时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>selector组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFullValue</td>
<td></td>
<td>获取当前完整值，在使用了 <code>valueMap</code> 里可以用该方法来获取当前选中值的原始对象</td>
</tr>
</tbody></table>
<h4 id="5-22-3-selector组件的注册"><a href="#5-22-3-selector组件的注册" class="headerlink" title="5.22.3 selector组件的注册"></a>5.22.3 selector组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Selector &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Selector</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Selector &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'selector'</span>, Selector)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-22-4-selector组件的使用"><a href="#5-22-4-selector组件的使用" class="headerlink" title="5.22.4 selector组件的使用"></a>5.22.4 selector组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selector</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"defaultValueRef"</span>  设置<span class="attr">refs</span>属性，用于获取该元素内容，如：<span class="attr">this.</span>$<span class="attr">refs</span>[<span class="attr">ref</span>]<span class="attr">.getFullValue</span>()</span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"title"</span>  设置标题的文字信息</span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"district"</span>  设置<span class="attr">name</span>属性</span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"gd"</span>  设置表单值，或者使用<span class="attr">v-model</span>绑定，如下所示</span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"value"</span>  使用<span class="attr">v-model</span>绑定表单值</span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">"list"</span>  选项列表，可以为简单数组，或者 `&#123; <span class="attr">key:</span> <span class="attr">KEY</span>, <span class="attr">value:</span> <span class="attr">VALUE</span> &#125;` 结构的键值对数组。当使用键值对时，返回的`<span class="attr">value</span>为<span class="attr">key</span>`的值</span></span><br><span class="line"><span class="tag">    <span class="attr">direction</span>=<span class="string">"rtl"</span>  设置选项对齐方式，同原生 <span class="attr">select</span> 属性一致，可选值为 `<span class="attr">ltr</span>(<span class="attr">left-to-right</span>，默认), <span class="attr">rtl</span>`</span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"请选择省份"</span>  提示文字</span></span><br><span class="line"><span class="tag">    <span class="attr">readonly</span>  设置不可选择，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value-map</span>=<span class="string">"['idValue', 'idLabel']"</span>  设置键值对映射用以自动转换接口数据, 如 `['<span class="attr">value</span>', '<span class="attr">label</span>']`</span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">    @<span class="attr">on-change</span>=<span class="string">"onChange"</span>  值变化时触发事件</span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-23-Swipeout-SwipeoutItem-SwipeoutButton（框滑动出现操作按钮，类似于手机左右滑动出现操作按钮）"><a href="#5-23-Swipeout-SwipeoutItem-SwipeoutButton（框滑动出现操作按钮，类似于手机左右滑动出现操作按钮）" class="headerlink" title="5.23 Swipeout, SwipeoutItem, SwipeoutButton（框滑动出现操作按钮，类似于手机左右滑动出现操作按钮）"></a>5.23 Swipeout, SwipeoutItem, SwipeoutButton（框滑动出现操作按钮，类似于手机左右滑动出现操作按钮）</h3><h4 id="5-23-1-Swipeout-SwipeoutItem-SwipeoutButton组件的功能"><a href="#5-23-1-Swipeout-SwipeoutItem-SwipeoutButton组件的功能" class="headerlink" title="5.23.1 Swipeout, SwipeoutItem, SwipeoutButton组件的功能"></a>5.23.1 Swipeout, SwipeoutItem, SwipeoutButton组件的功能</h4><p>框滑动出现操作按钮，类似于手机左右滑动出现操作按钮</p>
<h4 id="5-23-1-Swipeout的插槽-SwipeoutItem的属性、事件、插槽和方法，SwipeoutButton的属性和样式变量"><a href="#5-23-1-Swipeout的插槽-SwipeoutItem的属性、事件、插槽和方法，SwipeoutButton的属性和样式变量" class="headerlink" title="5.23.1 Swipeout的插槽, SwipeoutItem的属性、事件、插槽和方法，SwipeoutButton的属性和样式变量"></a>5.23.1 Swipeout的插槽, SwipeoutItem的属性、事件、插槽和方法，SwipeoutButton的属性和样式变量</h4><table>
<thead>
<tr>
<th>Swipeout 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>子组件插槽</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>SwipeoutItem组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sensitivity</td>
<td>number</td>
<td>0</td>
<td>滑动多少距离后开始触发菜单显示    –</td>
</tr>
<tr>
<td>auto-close-on-button-click</td>
<td>boolean</td>
<td>true</td>
<td>点击按钮后是否收回菜单    –</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否不可滑动    –</td>
</tr>
<tr>
<td>threshold</td>
<td>number</td>
<td>0.3</td>
<td>滑动多少距离后自动打开菜单，否则收回。可以为小于1的比例或者宽度值    –</td>
</tr>
<tr>
<td>transition-mode</td>
<td>string</td>
<td>reveal</td>
<td>菜单打开方式，reveal表示菜单不动内容滑出，follow表示菜单随内容滑出</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>SwipeoutItem组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-open</td>
<td>–</td>
<td>菜单完全打开时触发    –</td>
</tr>
<tr>
<td>@on-close</td>
<td>–</td>
<td>菜单完全关闭时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>SwipeoutItem组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>left-menu</td>
<td>左菜单</td>
</tr>
<tr>
<td>right-menu</td>
<td>右菜单</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>SwipeoutItem组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>(direction)</td>
<td>打开菜单，参数为方向</td>
</tr>
<tr>
<td>close</td>
<td>关闭菜单</td>
<td></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>Swipeout-button组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>string</td>
<td></td>
<td>按钮文字，同<code>slot=default</code></td>
</tr>
<tr>
<td>background-color</td>
<td>string</td>
<td></td>
<td>背景颜色</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td></td>
<td>内置的颜色类型，可选<code>primary, warn</code></td>
</tr>
<tr>
<td>width</td>
<td>string</td>
<td>80</td>
<td>按钮宽度</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>Swipeout-button组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@swipeout-button-primary-bg-color</td>
<td>草绿色#1AAD19</td>
<td>@button-primary-bg-color</td>
</tr>
<tr>
<td>@swipeout-button-warn-bg-color</td>
<td>深红色#E64340</td>
<td>@button-warn-bg-color</td>
</tr>
<tr>
<td>@swipeout-button-default-bg-color</td>
<td>灰色#c8c7cd</td>
<td>–</td>
</tr>
<tr>
<td>@swipeout-content-bg-color</td>
<td>#FFF</td>
<td>–</td>
</tr>
<tr>
<td>@swipeout-button-font-color</td>
<td>#FFF</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="5-23-3-Swipeout-SwipeoutItem-SwipeoutButton组件的注册"><a href="#5-23-3-Swipeout-SwipeoutItem-SwipeoutButton组件的注册" class="headerlink" title="5.23.3 Swipeout, SwipeoutItem, SwipeoutButton组件的注册"></a>5.23.3 Swipeout, SwipeoutItem, SwipeoutButton组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Swipeout, SwipeoutItem, SwipeoutButton &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Swipeout, SwipeoutItem, SwipeoutButton</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Swipeout, SwipeoutItem, SwipeoutButton &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'swipeout'</span>, Swipeout)</span><br><span class="line">Vue.component(<span class="string">'swipeout-item'</span>, SwipeoutItem)</span><br><span class="line">Vue.component(<span class="string">'swipeout-button'</span>, SwipeoutButton)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-23-4-Swipeout-SwipeoutItem-SwipeoutButton组件的使用"><a href="#5-23-4-Swipeout-SwipeoutItem-SwipeoutButton组件的使用" class="headerlink" title="5.23.4 Swipeout, SwipeoutItem, SwipeoutButton组件的使用"></a>5.23.4 Swipeout, SwipeoutItem, SwipeoutButton组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swipeout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swipeout-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"swipeoutItem"</span>  设置<span class="attr">refs</span>属性，用于获取该元素，进行操作，如：打开左侧菜单$<span class="attr">refs.swipeoutItem.open</span>('<span class="attr">left</span>'); 打开右侧菜单$<span class="attr">refs.swipeoutItem.open</span>('<span class="attr">right</span>');关闭打开的菜单$<span class="attr">refs.swipeoutItem.close</span>()</span></span><br><span class="line"><span class="tag">    <span class="attr">:disabled</span>=<span class="string">"disabled"</span>  设置是否可操作，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:right-menu-width</span>=<span class="string">"210"</span>  设置滑动出来的按钮的总宽度</span></span><br><span class="line"><span class="tag">    <span class="attr">:sensitivity</span>=<span class="string">"15"</span>  设置滑动多少距离后开始触发菜单显示，默认<span class="attr">0</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-close</span>=<span class="string">"handleEvents('on-close')"</span>  菜单完全关闭时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-open</span>=<span class="string">"handleEvents('on-open')"</span>  菜单完全打开时触发</span></span><br><span class="line"><span class="tag">    <span class="attr">transition-mode</span>=<span class="string">"follow"</span>  设置菜单打开方式，<span class="attr">reveal</span>表示菜单不动内容滑出，<span class="attr">follow</span>表示菜单随内容滑出， 默认<span class="attr">reveal</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"right-menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swipeout-button</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">click.native</span>=<span class="string">"onButtonClick('fav')"</span>  点击触发事件</span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"primary"</span>  设置按钮的类型</span></span><br><span class="line"><span class="tag">      &gt;</span>按钮1<span class="tag">&lt;/<span class="name">swipeout-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swipeout-button</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">click.native</span>=<span class="string">"onButtonClick('delete')"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"warn"</span></span></span><br><span class="line"><span class="tag">      &gt;</span>按钮2<span class="tag">&lt;/<span class="name">swipeout-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"demo-content vux-1px-t"</span>&gt;</span></span><br><span class="line">      'JavaScript is the best language'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swipeout-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swipeout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-24-search（搜索框组件）"><a href="#5-24-search（搜索框组件）" class="headerlink" title="5.24 search（搜索框组件）"></a>5.24 search（搜索框组件）</h3><h4 id="5-24-1-search组件的功能"><a href="#5-24-1-search组件的功能" class="headerlink" title="5.24.1 search组件的功能"></a>5.24.1 search组件的功能</h4><p>search搜索框组件；</p>
<h4 id="5-24-2-search组件的属性、事件、插槽、方法和样式变量"><a href="#5-24-2-search组件的属性、事件、插槽、方法和样式变量" class="headerlink" title="5.24.2 search组件的属性、事件、插槽、方法和样式变量"></a>5.24.2 search组件的属性、事件、插槽、方法和样式变量</h4><table>
<thead>
<tr>
<th>search组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>placeholder</td>
<td>string</td>
<td>搜索(search)</td>
<td>提示文字</td>
</tr>
<tr>
<td>cancel-text</td>
<td>string</td>
<td>取消(cancel)</td>
<td>取消文字</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值，v-model绑定</td>
</tr>
<tr>
<td>results</td>
<td>array</td>
<td></td>
<td>指定搜索结果, 为带有 <code>title key</code> 的对象组成的数组，如 <code>[{title: &#39;hello&#39;, otherData: otherValue}]</code>, <code>auto-fixed</code> 为 false 时不会显示结果</td>
</tr>
<tr>
<td>auto-fixed</td>
<td>boolean</td>
<td>true</td>
<td>是否自动固定在顶端</td>
</tr>
<tr>
<td>top</td>
<td>string</td>
<td>0px</td>
<td>自动固定时距离顶部的距离</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td>fixed</td>
<td>自动固定时的定位，一些布局下可能需要使用其他定位，比如<code>absolute</code></td>
</tr>
<tr>
<td>auto-scroll-to-top</td>
<td>boolean</td>
<td>false</td>
<td>Safari下弹出键盘时可能会出现看不到 <code>input</code>，需要手动滚动，启用该属性会在fix时滚动到顶端</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>search组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-submit</td>
<td>(value)</td>
<td>表单提交时触发</td>
</tr>
<tr>
<td>@on-cancel</td>
<td>–</td>
<td>点击取消按钮时触发</td>
</tr>
<tr>
<td>@on-change</td>
<td>(value)</td>
<td>输入文字变化时触发</td>
</tr>
<tr>
<td>@on-result-click</td>
<td>(item)</td>
<td>点击结果条目时触发，原来的result-click事件不符合规范已经废弃</td>
</tr>
<tr>
<td>@on-focus</td>
<td>–</td>
<td>输入框获取到焦点时触发</td>
</tr>
<tr>
<td>@on-blur</td>
<td>–</td>
<td>输入框失去焦点时触发</td>
</tr>
<tr>
<td>@on-clear</td>
<td>–</td>
<td>点击清除按钮时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>search组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>搜索结果列表上面 slot，可以用来自定义搜索结果显示区域(results 设为空)</td>
</tr>
<tr>
<td>right</td>
<td>输入框右侧 slot</td>
</tr>
<tr>
<td>left</td>
<td>输入框左侧 slot</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>search组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setFocus</td>
<td></td>
<td>获取 input 焦点，在 Safari 上你必须在 click 事件回调里使用才能生效</td>
</tr>
<tr>
<td>setBlur</td>
<td></td>
<td>手动设置 input 失去焦点，一般用于在 on-submit 事件中实现隐藏手机键盘</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>search组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@search-cancel-font-color</td>
<td>绿色#09BB07</td>
<td>取消按钮文本颜色</td>
</tr>
<tr>
<td>@search-bg-color</td>
<td>白色#EFEFF4</td>
<td>背景颜色</td>
</tr>
<tr>
<td>@search-placeholder-font-color</td>
<td>灰色 #9B9B9B</td>
<td>placeholder文本颜色</td>
</tr>
</tbody></table>
<h4 id="5-24-3-search组件的注册"><a href="#5-24-3-search组件的注册" class="headerlink" title="5.24.3 search组件的注册"></a>5.24.3 search组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Search &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Search</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Search &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'search'</span>, Search)</span><br></pre></td></tr></table></figure>
<h4 id="5-24-4-search组件的使用"><a href="#5-24-4-search组件的使用" class="headerlink" title="5.24.4 search组件的使用"></a>5.24.4 search组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">search</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:results</span>=<span class="string">"results"</span>  设置指定搜索结果，数组变量结构为如[&#123;<span class="attr">title:</span> '<span class="attr">hello</span>', <span class="attr">otherData:</span> <span class="attr">otherValue</span>&#125;], <span class="attr">auto-fixed</span> 为 <span class="attr">false</span> 时不会显示结果</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"value"</span>  使用<span class="attr">v-model</span>绑定表单值</span></span><br><span class="line"><span class="tag">  <span class="attr">:auto-fixed</span>= <span class="string">"'false'"</span>  设置不自动固定在顶端</span></span><br><span class="line"><span class="tag">  <span class="attr">position</span>=<span class="string">"absolute"</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">auto-scroll-to-top</span>  设置为自动滚动到顶部</span></span><br><span class="line"><span class="tag">  <span class="attr">top</span>=<span class="string">"46px"</span>  自动固定时距离顶部的距离</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-result-click</span>=<span class="string">"resultClick"</span>  点击结果条目时触发，参数是(<span class="attr">item</span>)</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-change</span>=<span class="string">"getResult"</span>  输入文字变化时触发，参数是(<span class="attr">value</span>)</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-focus</span>=<span class="string">"onFocus"</span>  输入框获取到焦点时触发</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-cancel</span>=<span class="string">"onCancel"</span>  点击取消按钮时触发</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-submit</span>=<span class="string">"onSubmit"</span>  表单提交时触发，参数是(<span class="attr">value</span>)</span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"search"</span>  设置<span class="attr">refs</span>属性获取整个<span class="attr">dom</span>元素，用于<span class="attr">setFocus</span>或<span class="attr">setBlur</span>	方法的使用，如：<span class="attr">this.</span>$<span class="attr">refs.search.setFocus</span>(); <span class="attr">this.</span>$<span class="attr">refs.search.setBlur</span>();</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">search</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-25-x-switch（开关组件）"><a href="#5-25-x-switch（开关组件）" class="headerlink" title="5.25 x-switch（开关组件）"></a>5.25 x-switch（开关组件）</h3><h4 id="5-25-1-x-switch组件的功能"><a href="#5-25-1-x-switch组件的功能" class="headerlink" title="5.25.1 x-switch组件的功能"></a>5.25.1 x-switch组件的功能</h4><p>开关组件，<code>x-switch</code>只能在<code>Group</code>中使用；</p>
<h4 id="5-25-2-x-switch组件的属性、事件和样式变量"><a href="#5-25-2-x-switch组件的属性、事件和样式变量" class="headerlink" title="5.25.2 x-switch组件的属性、事件和样式变量"></a>5.25.2 x-switch组件的属性、事件和样式变量</h4><table>
<thead>
<tr>
<th>x-switch组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>label文字</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false    是否不可点击</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>表单值, 使用v-model绑定</td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>标签下文字</td>
</tr>
<tr>
<td>prevent-default</td>
<td>boolean</td>
<td>false</td>
<td>阻止点击时自动设定值</td>
</tr>
<tr>
<td>value-map</td>
<td>array</td>
<td>[false, true]</td>
<td>用于自定义 false 和 true 映射的实际值，用于方便处理比如接口返回了 0 1 这类非 boolean 值的情况</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-switch组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>值变化时触发，参数为 (currentValue)</td>
</tr>
<tr>
<td>@on-click</td>
<td>(newVal, oldVal)</td>
<td>点击组件时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-switch组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@switch-checked-bg-color</td>
<td>草绿色#04BE02</td>
<td>@theme-color</td>
</tr>
<tr>
<td>@switch-checked-border-color</td>
<td>草绿色#04BE02</td>
<td>@theme-color</td>
</tr>
<tr>
<td>@switch-disabled-opacity</td>
<td>0.6</td>
<td></td>
</tr>
<tr>
<td>@switch-height</td>
<td>32px</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-25-3-x-switch组件的注册"><a href="#5-25-3-x-switch组件的注册" class="headerlink" title="5.25.3 x-switch组件的注册"></a>5.25.3 x-switch组件的注册</h4><ul>
<li>a. 局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XSwitch &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XSwitch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XSwitch &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-switch'</span>, XSwitch)</span><br></pre></td></tr></table></figure>
<h4 id="5-25-4-x-switch组件的使用"><a href="#5-25-4-x-switch组件的使用" class="headerlink" title="5.25.4 x-switch组件的使用"></a>5.25.4 x-switch组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;group :title=<span class="string">"$t('value map')"</span>&gt;</span><br><span class="line">      &lt;x-<span class="keyword">switch</span></span><br><span class="line">        :title=<span class="string">"'x-switch标题'"</span>  设置标题文字信息</span><br><span class="line">        :value-map=<span class="string">"['0', '1']"</span>  设置用于自定义 <span class="literal">false</span> 和 <span class="literal">true</span> 映射的实际值，下面的stringValue变量值</span><br><span class="line">        v-model=<span class="string">"stringValue"</span>  使用v-model进行绑定表单值，value默认是<span class="literal">false</span>，例如：stringValue: <span class="string">'0'</span></span><br><span class="line">        :value=<span class="string">"true"</span>  设置表单值为<span class="literal">true</span>，默认为<span class="literal">false</span>，或者使用上面的v-model绑定</span><br><span class="line">        disabled  设置开关不可选择</span><br><span class="line">        :inline-desc=<span class="string">"value"</span>  设置行内的描述信息，位于标题文字下面</span><br><span class="line">        @on-click=<span class="string">"onClick"</span>  设置点击触发的事件，参数为 (currentValue)</span><br><span class="line">        prevent-<span class="keyword">default</span></span><br><span class="line">      &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-switch</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-26-x-input（类似于input的输入框组件）"><a href="#5-26-x-input（类似于input的输入框组件）" class="headerlink" title="5.26 x-input（类似于input的输入框组件）"></a>5.26 x-input（类似于input的输入框组件）</h3><h4 id="5-26-1-x-input组件的功能"><a href="#5-26-1-x-input组件的功能" class="headerlink" title="5.26.1 x-input组件的功能"></a>5.26.1 x-input组件的功能</h4><p>类似于input的输入框组件，<code>x-input</code>只能在<code>Group</code>中使用；</p>
<h4 id="5-26-2-x-input组件的属性、事件、插槽和样式变量"><a href="#5-26-2-x-input组件的属性、事件、插槽和样式变量" class="headerlink" title="5.26.2 x-input组件的属性、事件、插槽和样式变量"></a>5.26.2 x-input组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>x-input组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>text</td>
<td>即input的type属性，目前支持 text,number,email,password,tel</td>
</tr>
<tr>
<td>is-type</td>
<td>string function</td>
<td></td>
<td>内置验证器，支持email,china-name,china-mobile, 同样也支持直接传函数, 需要同步返回一个对象{valid:true}或者{valid:false, msg:错误信息}</td>
</tr>
<tr>
<td>required</td>
<td>boolean</td>
<td>false</td>
<td>是否必值，如果不禁用验证，当没有填写时会在右侧显示错误icon</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>label文字</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>placeholder 提示</td>
</tr>
<tr>
<td>show-clear</td>
<td>boolean</td>
<td>true</td>
<td>是否显示清除icon</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td></td>
<td>最小输入字符限制</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td></td>
<td>最大输入字符限制，等同于maxlength，达到限制到不能再输入</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否禁用填写</td>
</tr>
<tr>
<td>readonly</td>
<td>boolean</td>
<td>false</td>
<td>同input的标准属性readonly</td>
</tr>
<tr>
<td>debounce</td>
<td>number</td>
<td></td>
<td>debounce用以限制on-change事件触发。如果你需要根据用户输入做ajax请求，建议开启以节省无效请求和服务器资源，单位为毫秒</td>
</tr>
<tr>
<td>placeholder-align</td>
<td>string</td>
<td>left</td>
<td>placeholder 文字对齐方式    v2.1.1-rc.8</td>
</tr>
<tr>
<td>text-align</td>
<td>string</td>
<td>left</td>
<td>值对齐方式</td>
</tr>
<tr>
<td>label-width</td>
<td>string</td>
<td></td>
<td>label 宽度，权重比 group 的 labelWidth 高。不设定时将进行自动宽度计算，但超过15个字符时不会进行宽度设定。    v2.2.1-rc.4</td>
</tr>
<tr>
<td>mask</td>
<td>string</td>
<td></td>
<td>(beta) 值格式化，依赖于 <code>vanilla-masker</code>，其中 9 表示数字，A 表示大写字母，S 表示数字或者字母    v2.6.1</td>
</tr>
<tr>
<td>should-toast-error</td>
<td>string</td>
<td>true</td>
<td>是否在点击错误图标时用 toast 的形式显示错误 v2.6.3</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-input组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-blur</td>
<td>(value, $event)</td>
<td>input的blur事件</td>
</tr>
<tr>
<td>@on-focus</td>
<td>(value, $event)</td>
<td>input的focus事件</td>
</tr>
<tr>
<td>@on-enter</td>
<td>(value, $event)</td>
<td>input输入完成后点击enter(确认)事件</td>
</tr>
<tr>
<td>@on-change</td>
<td>(value)</td>
<td>输入值变化时触发。如果你使用了debounce，那么触发将不会是实时的。</td>
</tr>
<tr>
<td>@on-click-error-icon</td>
<td>(error)</td>
<td>点击错误图标时触发，你可以关闭 should-toast-error 然后用这个事件来自定义显示错误的提示内容</td>
</tr>
<tr>
<td>@on-click-clear-icon</td>
<td>–</td>
<td>点击清除按钮时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-input组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>用于自定义label(即 title)部分内容，比如使用icon</td>
</tr>
<tr>
<td>restricted-label</td>
<td>用于自定义label部分，和slot=label不同的是，该slot宽度受到父组件group的限制</td>
</tr>
<tr>
<td>right</td>
<td>用以在输入框右边显示内容，比如单位，切换密码显示方式等</td>
</tr>
<tr>
<td>right-full-height</td>
<td>用于放置和 cell 高度的验证码图片</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-input组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>focus</td>
<td></td>
<td>手动获得焦点</td>
</tr>
<tr>
<td>blur</td>
<td></td>
<td>手动设置 input 失去焦点</td>
</tr>
<tr>
<td>reset</td>
<td>(value = ‘’)</td>
<td>重置输入框值，清除错误信息</td>
</tr>
</tbody></table>
<h4 id="5-26-3-x-input组件的注册"><a href="#5-26-3-x-input组件的注册" class="headerlink" title="5.26.3 x-input组件的注册"></a>5.26.3 x-input组件的注册</h4><ul>
<li>a. 局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XInput &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XInput &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-input'</span>, XInput)</span><br></pre></td></tr></table></figure>
<h4 id="5-26-4-x-input组件的使用"><a href="#5-26-4-x-input组件的使用" class="headerlink" title="5.26.4 x-input组件的使用"></a>5.26.4 x-input组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;group title=<span class="string">"Xinput组件只能在 group中使用"</span>&gt;</span><br><span class="line">  &lt;x-input</span><br><span class="line">    title=<span class="string">"禁用验证"</span>  设置标题提文字信息，还可以使用 slot=<span class="string">"label"</span> 插槽替代标题文字信息</span><br><span class="line">    :is-type=<span class="string">"be2333"</span>  设置内置验证器，支持email,china-name,china-mobile, 同样也支持直接传函数, 需要同步返回一个对象&#123;<span class="attr">valid</span>:<span class="literal">true</span>&#125;或者&#123;<span class="attr">valid</span>:<span class="literal">false</span>, <span class="attr">msg</span>:错误信息&#125;	</span><br><span class="line">    mask=<span class="string">"999 9999 9999"</span>  (beta) 值格式化，依赖于 <span class="string">`vanilla-masker`</span>，其中 <span class="number">9</span> 表示数字，A 表示大写字母，S 表示数字或者字母</span><br><span class="line">    v-model=<span class="string">"maskValue"</span>  使用v-model绑定表单值</span><br><span class="line">    type=<span class="string">"tel"</span>  设置input的type属性，默认text，目前支持 text,number,email,password,tel</span><br><span class="line">    :min=<span class="string">"3"</span>  设置最小输入字符限制</span><br><span class="line">    :max=<span class="string">"13"</span>  设置最大输入字符限制，等同于maxlength，达到限制到不能再输入</span><br><span class="line">    placeholder=<span class="string">"I'm placeholder"</span>  设置提示信息</span><br><span class="line">    placeholder-align=<span class="string">"right"</span>  设置提示信息的位置</span><br><span class="line">    label-width=<span class="string">"4em"</span>  设置 label 宽度，权重比 group 的 labelWidth 高。不设定时将进行自动宽度计算，但超过<span class="number">15</span>个字符时不会进行宽度设定。</span><br><span class="line">    novalidate  </span><br><span class="line">    autocapitalize=<span class="string">"characters"</span>  </span><br><span class="line">    :debounce=<span class="string">"500"</span>  设置debounce用以限制on-change事件触发。如果你需要根据用户输入做ajax请求，建议开启以节省无效请求和服务器资源，单位为毫秒</span><br><span class="line">    text-align=<span class="string">"right"</span>  设置文本排列位置</span><br><span class="line">    disabled  设置不可操作，默认<span class="literal">false</span></span><br><span class="line">    readonly  设置只读，input的标准属性readonly，默认<span class="literal">false</span></span><br><span class="line">    :icon-type=<span class="string">"iconType"</span>  设置图标类型</span><br><span class="line">    :show-clear=<span class="string">"false"</span>  设置是否显示清除消息按钮</span><br><span class="line">    </span><br><span class="line">    @on-blur=<span class="string">"onBlur"</span>  input的blur事件</span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-input</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-27-x-number-数字增加减少和inline-x-number-功能相似"><a href="#5-27-x-number-数字增加减少和inline-x-number-功能相似" class="headerlink" title="5.27 x-number(数字增加减少和inline-x-number 功能相似)"></a>5.27 x-number(数字增加减少和inline-x-number 功能相似)</h3><h4 id="5-27-1-x-number组件的功能"><a href="#5-27-1-x-number组件的功能" class="headerlink" title="5.27.1 x-number组件的功能"></a>5.27.1 x-number组件的功能</h4><p>注意<code>x-number</code>只能在<code>Group</code>中使用；</p>
<h4 id="5-27-2-x-number组件的属性和样式变量"><a href="#5-27-2-x-number组件的属性和样式变量" class="headerlink" title="5.27.2 x-number组件的属性和样式变量"></a>5.27.2 x-number组件的属性和样式变量</h4><table>
<thead>
<tr>
<th>x-number组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>number</td>
<td>0</td>
<td>表单值，使用v-model绑定</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>min</td>
<td>number</td>
<td></td>
<td>最小值</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td></td>
<td>最大值</td>
</tr>
<tr>
<td>step</td>
<td>number</td>
<td>1</td>
<td>步长</td>
</tr>
<tr>
<td>fillable</td>
<td>boolean</td>
<td>false</td>
<td>是否可填写</td>
</tr>
<tr>
<td>width</td>
<td>string</td>
<td>50px</td>
<td>输入框宽度</td>
</tr>
<tr>
<td>button-style</td>
<td>string</td>
<td>square</td>
<td>按钮样式，可选值为<code>square或者round</code></td>
</tr>
<tr>
<td>align</td>
<td>string</td>
<td>right</td>
<td>按钮部分位置，默认在右边(right)，可选值为<code>left和right</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-number组件的样式变量名字</th>
<th>默认值</th>
<th>说明-继承自变量</th>
</tr>
</thead>
<tbody><tr>
<td>@number-button-font-color</td>
<td>草绿色#3cc51f</td>
<td>–</td>
</tr>
<tr>
<td>@number-input-font-color</td>
<td>灰黑色#666</td>
<td>–</td>
</tr>
<tr>
<td>@number-button-enabled-border-color</td>
<td>白灰色#ececec</td>
<td>–</td>
</tr>
<tr>
<td>@number-square-button-enabled-border-color</td>
<td>白灰色#ececec</td>
<td>–    @number-button-enabled-border-color</td>
</tr>
<tr>
<td>@number-round-button-enabled-border-color</td>
<td>草绿色#3cc51f</td>
<td>–    @number-button-font-color</td>
</tr>
<tr>
<td>@number-button-disabled-border-color</td>
<td>白灰色#ececec</td>
<td>–    @number-button-enabled-border-color</td>
</tr>
<tr>
<td>@number-round-button-disabled-border-color</td>
<td>白灰色#ececec</td>
<td>–    @number-button-enabled-border-color</td>
</tr>
</tbody></table>
<h4 id="5-27-3-x-number组件的注册"><a href="#5-27-3-x-number组件的注册" class="headerlink" title="5.27.3 x-number组件的注册"></a>5.27.3 x-number组件的注册</h4><ul>
<li>a. 局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XNumber &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XNumber</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XNumber &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-number'</span>, XNumber)</span><br></pre></td></tr></table></figure>
<h4 id="5-27-4-x-number组件的使用"><a href="#5-27-4-x-number组件的使用" class="headerlink" title="5.27.4 x-number组件的使用"></a>5.27.4 x-number组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;group&gt;</span><br><span class="line">  &lt;x-number </span><br><span class="line">    :name=<span class="string">"'Quantity'"</span>  设置name属性的值</span><br><span class="line">    :title=<span class="string">"'标题文字信息'"</span>  设置标题的文字内容</span><br><span class="line">    :value=<span class="string">"'10'"</span>  设置其value值，默认为<span class="number">0</span>，也可以用下面的v-model进行数据绑定</span><br><span class="line">    v-model=<span class="string">"changeValue"</span>  使用v-model绑定表单值</span><br><span class="line">    :min=<span class="string">"0"</span>  设置最小值</span><br><span class="line">    :max=<span class="string">"5"</span>  设置最大值</span><br><span class="line">    width=<span class="string">"100px"</span>  设置输入框的宽度</span><br><span class="line">    button-style=<span class="string">"round"</span>  设置按钮样式，可选值为<span class="string">`square或者round`</span>，默认为square</span><br><span class="line">    :step=<span class="string">"0.5"</span>  设置每一步的步长为<span class="number">0.5</span>，默认为<span class="number">1</span></span><br><span class="line">    fillable  设置数字可以输入，默认为<span class="literal">false</span></span><br><span class="line">    @on-change=<span class="string">"change"</span>  设置监听数值改变的事件</span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-number</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-28-x-textarea（和textarea标签作用差不多，填写多行信息文字）"><a href="#5-28-x-textarea（和textarea标签作用差不多，填写多行信息文字）" class="headerlink" title="5.28 x-textarea（和textarea标签作用差不多，填写多行信息文字）"></a>5.28 x-textarea（和textarea标签作用差不多，填写多行信息文字）</h3><h4 id="5-28-1-x-textarea组件的功能"><a href="#5-28-1-x-textarea组件的功能" class="headerlink" title="5.28.1 x-textarea组件的功能"></a>5.28.1 x-textarea组件的功能</h4><p>注意<code>x-textarea</code>只能在<code>Group</code>中使用</p>
<h4 id="5-28-2-x-textarea组件的属性、事件、插槽和样式变量"><a href="#5-28-2-x-textarea组件的属性、事件、插槽和样式变量" class="headerlink" title="5.28.2 x-textarea组件的属性、事件、插槽和样式变量"></a>5.28.2 x-textarea组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>x-textarea组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>label文字    v2.1.1-rc.8</td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>位于标题下的描述文字    v2.1.1-rc.8</td>
</tr>
<tr>
<td>show-counter</td>
<td>boolean</td>
<td>true</td>
<td>是否显示计数    –</td>
</tr>
<tr>
<td>max</td>
<td>number</td>
<td>0</td>
<td>最大长度限制    –</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值, 使用v-model绑定    –</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td></td>
<td>表单名字    –</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>没有值时的提示文字    –</td>
</tr>
<tr>
<td>rows</td>
<td>number</td>
<td>3</td>
<td>textarea 标准属性 rows    –</td>
</tr>
<tr>
<td>cols</td>
<td>number</td>
<td>30</td>
<td>textarea 标签属性 cols    –</td>
</tr>
<tr>
<td>height</td>
<td>number</td>
<td>0</td>
<td>高度    –</td>
</tr>
<tr>
<td>readonly</td>
<td>boolean</td>
<td>false</td>
<td>textarea 标签属性 readonly    –</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>textarea 标签属性 disabled    –</td>
</tr>
<tr>
<td>autosize</td>
<td>boolean</td>
<td>false</td>
<td>是否根据内容自动设置高度</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-textarea组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-change</td>
<td>(value)</td>
<td>表单值变化时触发    –</td>
</tr>
<tr>
<td>@on-focus</td>
<td>–</td>
<td>focus 事件    v2.1.1-rc.11</td>
</tr>
<tr>
<td>@on-blur</td>
<td>–</td>
<td>blur 事件 v2.1.1-rc.11</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-textarea组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>用于自定义label(即 title)部分内容，比如使用icon    v2.1.1-rc.8</td>
</tr>
<tr>
<td>restricted-label</td>
<td>用于自定义label部分，和slot=label不同的是，该slot宽度受到父组件group的限制</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-textarea组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>updateAutosize</td>
<td></td>
<td>重置 autosize 高度，如果绑定值不为空，需要调用该函数进行高度重置</td>
</tr>
</tbody></table>
<h4 id="5-28-3-x-textarea组件的注册"><a href="#5-28-3-x-textarea组件的注册" class="headerlink" title="5.28.3 x-textarea组件的注册"></a>5.28.3 x-textarea组件的注册</h4><ul>
<li>a. 局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XTextarea &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XTextarea</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XTextarea &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-textarea'</span>, XTextarea)</span><br></pre></td></tr></table></figure>
<h4 id="5-28-4-x-textarea组件的使用"><a href="#5-28-4-x-textarea组件的使用" class="headerlink" title="5.28.4 x-textarea组件的使用"></a>5.28.4 x-textarea组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;group&gt;</span><br><span class="line">  &lt;x-textarea</span><br><span class="line">    name=<span class="string">"description"</span>  设置name属性</span><br><span class="line">    title=<span class="string">"title"</span>  设置标题的文字信息</span><br><span class="line">    :value=<span class="string">"'填写的文字信息'"</span>  设置填写的文字信息，也可以使用v-model绑定表单值</span><br><span class="line">    v-model=<span class="string">"value"</span>  使用v-model绑定表单值</span><br><span class="line">    :max=<span class="string">"20"</span>  设置最多输入的文字个数</span><br><span class="line">    :placeholder=<span class="string">"'placeholder'"</span>  设置提示信息</span><br><span class="line">    :show-counter=<span class="string">"false"</span>  设置不显示数字的个数信息，默认为<span class="literal">true</span></span><br><span class="line">    :rows=<span class="string">"1"</span>  设置textarea 标准属性 rows为<span class="number">1</span>行，默认为<span class="number">3</span></span><br><span class="line">    :cols=<span class="string">"20"</span>  设置textarea 标签属性 cols为<span class="number">20</span>列，默认为<span class="number">30</span></span><br><span class="line">    autosize  设置根据内容自动填充高度，默认为<span class="literal">false</span></span><br><span class="line">    :height=<span class="string">"200"</span>  设置高度值，默认为<span class="number">0</span></span><br><span class="line">    @on-change=	<span class="string">"onChange"</span>  	表单值变化时触发,参数为(value)</span><br><span class="line">    @on-focus=<span class="string">"onEvent('focus')"</span>  focus 事件</span><br><span class="line">    @on-blur=<span class="string">"onEvent('blur')"</span>  blur 事件</span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-textarea</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-29-x-address（地址选择组件）"><a href="#5-29-x-address（地址选择组件）" class="headerlink" title="5.29 x-address（地址选择组件）"></a>5.29 x-address（地址选择组件）</h3><h4 id="5-29-1-x-address组件的功能"><a href="#5-29-1-x-address组件的功能" class="headerlink" title="5.29.1 x-address组件的功能"></a>5.29.1 x-address组件的功能</h4><p>选择地址信息，注意设计上 <code>x-address</code> 只能在 <code>Group</code> 中使用，但是你依然可以不在 <code>Group</code> 中使用，使用 <code>display:none</code> 隐藏然后用 <code>:show.sync</code> 来控制组件显示状态，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-address</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"display:none;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">"title"</span> <span class="attr">v-model</span>=<span class="string">"value"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:list</span>=<span class="string">"addressData"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"请选择地址"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show.sync</span>=<span class="string">"showAddress"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">x-address</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时在使用改组件的同时还要引入地址信息数据，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XAddress &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你需要引入数据，如果你的版本低于 v2.2.0，请使用 ChinaAddressData</span></span><br><span class="line"><span class="keyword">import</span> &#123; XAddress, ChinaAddressV4Data &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="comment">// 如果需要引入旧版数据</span></span><br><span class="line"><span class="keyword">import</span> &#123; XAddress, ChinaAddressV2Data &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br></pre></td></tr></table></figure>

<h4 id="5-29-2-x-address组件的属性、事件、插槽"><a href="#5-29-2-x-address组件的属性、事件、插槽" class="headerlink" title="5.29.2 x-address组件的属性、事件、插槽"></a>5.29.2 x-address组件的属性、事件、插槽</h4><table>
<thead>
<tr>
<th>x-address组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>raw-value</td>
<td>boolean</td>
<td>false</td>
<td>指定初始化时绑定的数据是否为文本(即省市名，而不是id)类型，即对于非id值组件内部会转换为id。如果是异步设置value，只能使用id赋值。</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>表单标题</td>
</tr>
<tr>
<td>value</td>
<td>array</td>
<td></td>
<td>表单值, 使用v-model绑定</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
<td></td>
<td>地址列表, 可以引入内置地址数据或者用自己的数据，但是需要按照一致的数据结构。</td>
</tr>
<tr>
<td>inline-desc</td>
<td>string</td>
<td></td>
<td>标题下的描述</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>没有值时的提示文字</td>
</tr>
<tr>
<td>hide-district</td>
<td>boolean</td>
<td>false</td>
<td>是否隐藏区，即只显示省份和城市</td>
</tr>
<tr>
<td>value-text-align</td>
<td>string</td>
<td>right</td>
<td>value 对齐方式(text-align), v2.1.0-rc.49开始支持</td>
</tr>
<tr>
<td>popup-style</td>
<td>object</td>
<td></td>
<td>弹窗样式，可以用于强制指定 z-index    v2.5.2</td>
</tr>
<tr>
<td>show</td>
<td>boolean</td>
<td></td>
<td>显示 (支持.sync修饰 next)    v2.5.8</td>
</tr>
<tr>
<td>disabled</td>
<td>boolean</td>
<td></td>
<td>是否禁用选择</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-address组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-hide</td>
<td>–</td>
<td>关闭后触发，当非确定时，参数为false，反之为true</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>显示时触发</td>
</tr>
<tr>
<td>@on-shadow-change</td>
<td>(Array ids, Array names)</td>
<td>picker 值变化时触发，即滑动 picker 时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-address组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>title 插槽，可以使用它来添加 icon 等自定义样式，受控于 group 需要从 scope 里继承 class 和 样式</td>
</tr>
</tbody></table>
<h4 id="5-29-3-x-address组件的注册"><a href="#5-29-3-x-address组件的注册" class="headerlink" title="5.29.3 x-address组件的注册"></a>5.29.3 x-address组件的注册</h4><ul>
<li>a. 局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XAddress &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XAddress</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XAddress &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-address'</span>, XAddress)</span><br></pre></td></tr></table></figure>
<h4 id="5-29-4-x-address组件的使用"><a href="#5-29-4-x-address组件的使用" class="headerlink" title="5.29.4 x-address组件的使用"></a>5.29.4 x-address组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;group&gt;</span><br><span class="line">  &lt;x-address</span><br><span class="line">    :title=<span class="string">"title"</span>  设置标题文字信息</span><br><span class="line">    :value=<span class="string">"'[]'"</span>  选择的地址信息表单值，数组类型，也可以使用下面的v-model绑定</span><br><span class="line">    v-model=<span class="string">"value"</span>  使用v-model绑定表单值</span><br><span class="line">    :list=<span class="string">"addressData"</span>  设置数据信息，如：addressData: ChinaAddressV4Data, 其中ChinaAddressV4Data为引入的数据：<span class="keyword">import</span> &#123; ChinaAddressV4Data &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">    placeholder=<span class="string">"请选择地址"</span>  设置提示信息</span><br><span class="line">    inline-desc=<span class="string">"可以设置placeholder"</span>  设置标题下方的描述信息</span><br><span class="line">    :show.sync=<span class="string">"showAddress"</span>  显示，值为 <span class="literal">true</span>/<span class="literal">false</span>（此处没有明白有何作用？可能是单独使用时，不再Group组件中使用有用）</span><br><span class="line"></span><br><span class="line">    @on-shadow-change=<span class="string">"onShadowChange"</span>  picker 值变化时触发，即滑动 picker 时触发，参数为(ids, names)</span><br><span class="line">    @on-hide=<span class="string">"logHide"</span>  关闭后触发，当非确定时，参数(str)为<span class="literal">false</span>，反之为<span class="literal">true</span></span><br><span class="line">    @on-show=<span class="string">"logShow"</span>  显示时触发,参数(str)</span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">x-address</span>&gt;</span></span></span><br><span class="line">  &lt;cell title=<span class="string">"上面value值"</span> :value=<span class="string">"value"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/group&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-数据展示组件"><a href="#6-数据展示组件" class="headerlink" title="6. 数据展示组件"></a>6. 数据展示组件</h2><h3 id="6-1-badge（新消息提示组件）"><a href="#6-1-badge（新消息提示组件）" class="headerlink" title="6.1 badge（新消息提示组件）"></a>6.1 badge（新消息提示组件）</h3><h4 id="6-1-1-badge组件的功能"><a href="#6-1-1-badge组件的功能" class="headerlink" title="6.1.1 badge组件的功能"></a>6.1.1 badge组件的功能</h4><p>Badge是指通常出现在图标或文字右上角的红色圆点、数字或者文字，表示有新内容或者待处理的信息。中文一般称呼为小红点、角标或徽标；可单独使用，还可以做group中cell组件中使用；</p>
<h4 id="6-1-2-badge组件的属性和样式变量"><a href="#6-1-2-badge组件的属性和样式变量" class="headerlink" title="6.1.2 badge组件的属性和样式变量"></a>6.1.2 badge组件的属性和样式变量</h4><table>
<thead>
<tr>
<th>badge组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>string</td>
<td></td>
<td>显示的文字</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>badge组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@badge-bg-color</td>
<td>红色#f74c31</td>
<td>badge的背景颜色</td>
</tr>
</tbody></table>
<h4 id="6-1-3-badge组件的注册"><a href="#6-1-3-badge组件的注册" class="headerlink" title="6.1.3 badge组件的注册"></a>6.1.3 badge组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Badge &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Badge</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Badge &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'badge'</span>, Badge)</span><br></pre></td></tr></table></figure>
<h4 id="6-1-4-badge组件的使用"><a href="#6-1-4-badge组件的使用" class="headerlink" title="6.1.4 badge组件的使用"></a>6.1.4 badge组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">badge</span> <span class="attr">text</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">badge</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">:title</span>=<span class="string">"$t('Used in a Cell')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span> <span class="attr">:title</span>=<span class="string">"$t('Red dot')"</span> <span class="attr">is-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"badge-value"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"vertical-middle"</span>&gt;</span>&#123;&#123; $t('New Messages') &#125;&#125; <span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">badge</span> <span class="attr">text</span>=<span class="string">"8"</span>&gt;</span><span class="tag">&lt;/<span class="name">badge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-2-card-卡片类型样式的组件"><a href="#6-2-card-卡片类型样式的组件" class="headerlink" title="6.2 card(卡片类型样式的组件)"></a>6.2 card(卡片类型样式的组件)</h3><h4 id="6-2-1-card组件的功能"><a href="#6-2-1-card组件的功能" class="headerlink" title="6.2.1 card组件的功能"></a>6.2.1 card组件的功能</h4><p>卡片类似功能的组件，例如在京东中我的钱包的卡片的展示；</p>
<h4 id="6-2-2-card组件的属性、事件、插槽"><a href="#6-2-2-card组件的属性、事件、插槽" class="headerlink" title="6.2.2 card组件的属性、事件、插槽"></a>6.2.2 card组件的属性、事件、插槽</h4><table>
<thead>
<tr>
<th>card组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header.title</td>
<td>string</td>
<td></td>
<td>头部标题，不指定则不显示    –</td>
</tr>
<tr>
<td>footer.title</td>
<td>string</td>
<td></td>
<td>底部标题，不指定则不显示    –</td>
</tr>
<tr>
<td>footer.link</td>
<td>string</td>
<td></td>
<td>底部链接，普通url或者v-link参数</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>card组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-click-footer</td>
<td>–</td>
<td>点击底部时触发    –</td>
</tr>
<tr>
<td>@on-click-header</td>
<td>–</td>
<td>点击头部时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>card组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>头部位置    –</td>
</tr>
<tr>
<td>content</td>
<td>中间主体位置    –</td>
</tr>
<tr>
<td>footer</td>
<td>底部位置    –</td>
</tr>
</tbody></table>
<h4 id="6-2-3-card组件的注册"><a href="#6-2-3-card组件的注册" class="headerlink" title="6.2.3 card组件的注册"></a>6.2.3 card组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Card &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Card</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Card &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'card'</span>, Card)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-2-4-card组件的使用"><a href="#6-2-4-card组件的使用" class="headerlink" title="6.2.4 card组件的使用"></a>6.2.4 card组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">card</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:header</span>=<span class="string">"&#123;title: $t('Product details') &#125;"</span>  还可以使用内容插槽，如下面</span></span><br><span class="line"><span class="tag">  <span class="attr">:footer</span>=<span class="string">"&#123;title: $t('More'),link:'/component/panel'&#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"header"</span> <span class="attr">src</span>=<span class="string">"http://placeholder.qiniudn.com/640x300"</span> <span class="attr">style</span>=<span class="string">"width:100%;display:block;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"card-padding"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:#999;font-size:12px;"</span>&gt;</span>Posted on January 21, 2015<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size:14px;line-height:1.2;"</span>&gt;</span>Quisque eget vestibulum nulla. Quisque quis dui quis ex ultricies efficitur vitae non felis. Phasellus quis nibh hendrerit..<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">card</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-clocker-行内时间显示组件，距离设定的日期的剩下的时间"><a href="#6-3-clocker-行内时间显示组件，距离设定的日期的剩下的时间" class="headerlink" title="6.3 clocker (行内时间显示组件，距离设定的日期的剩下的时间)"></a>6.3 clocker (行内时间显示组件，距离设定的日期的剩下的时间)</h3><h4 id="6-3-1-clocker组件的功能"><a href="#6-3-1-clocker组件的功能" class="headerlink" title="6.3.1 clocker组件的功能"></a>6.3.1 clocker组件的功能</h4><p>行内时间显示组件，剩下的时间显示的默认格式是<code>%D 天 %H 小时 %M 分 %S 秒</code>；例如在淘宝的商品促销的倒计时显示时间的组件；可以单独使用，也可以在<code>group</code>中的<code>cell</code>组件中使用；也可以之定义显示的时间的格式；</p>
<h4 id="6-3-2-clocker组件的属性、事件、插槽"><a href="#6-3-2-clocker组件的属性、事件、插槽" class="headerlink" title="6.3.2 clocker组件的属性、事件、插槽"></a>6.3.2 clocker组件的属性、事件、插槽</h4><table>
<thead>
<tr>
<th>clocker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>string</td>
<td></td>
<td>结束时间    –</td>
</tr>
<tr>
<td>format</td>
<td>string</td>
<td>%D 天 %H 小时 %M 分 %S 秒</td>
<td>显示格式    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>clocker组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-tick</td>
<td>–</td>
<td>时间计算时触发，但非精确每1s触发</td>
</tr>
<tr>
<td>@on-finish</td>
<td>–</td>
<td>时间结束时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>clocker组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>若存在，则作为最终显示出来的格式模板</td>
</tr>
</tbody></table>
<h4 id="6-3-3-clocker组件的注册"><a href="#6-3-3-clocker组件的注册" class="headerlink" title="6.3.3 clocker组件的注册"></a>6.3.3 clocker组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Clocker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Clocker</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Clocker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'clocker'</span>, Clocker)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-3-4-clocker组件的使用"><a href="#6-3-4-clocker组件的使用" class="headerlink" title="6.3.4 clocker组件的使用"></a>6.3.4 clocker组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"padding:15px;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123;&#123; $t('Basic Usage') &#125;&#125;: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">clocker</span> <span class="attr">:time</span>=<span class="string">"time1"</span>&gt;</span><span class="tag">&lt;/<span class="name">clocker</span>&gt;</span>  设置结束时间，如：'2018-07-13 21:54'</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">:title</span>=<span class="string">" $t('Custom template') "</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span> <span class="attr">:title</span>=<span class="string">" $t('Date: 2018-08-01') "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clocker</span> <span class="attr">time</span>=<span class="string">"2018-08-01"</span>&gt;</span>  自定义显示的样式</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>%D 天<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:green"</span>&gt;</span>%H 小时<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:blue"</span>&gt;</span>%M 分 %S 秒<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clocker</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cell</span> <span class="attr">title</span>=<span class="string">"2018-08-08"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clocker</span> <span class="attr">time</span>=<span class="string">"2018-08-08"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_D1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_D2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_D3<span class="tag">&lt;/<span class="name">span</span>&gt;</span>天</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_H1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_H2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>时</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_M1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_M2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>分</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_S1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"day"</span>&gt;</span>%_S2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>秒</span><br><span class="line">    <span class="tag">&lt;/<span class="name">clocker</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-countup"><a href="#6-4-countup" class="headerlink" title="6.4 countup"></a>6.4 countup</h3><h4 id="6-4-1-countup组件的功能"><a href="#6-4-1-countup组件的功能" class="headerlink" title="6.4.1 countup组件的功能"></a>6.4.1 countup组件的功能</h4><p>类似于计数器功能的组件；设定一个数，从0开始动态的增加到设定的数；</p>
<h4 id="6-4-2-countup组件的属性"><a href="#6-4-2-countup组件的属性" class="headerlink" title="6.4.2 countup组件的属性"></a>6.4.2 countup组件的属性</h4><table>
<thead>
<tr>
<th>countup组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>start-val</td>
<td>number</td>
<td>0</td>
<td>开始数字    –</td>
</tr>
<tr>
<td>end-val</td>
<td>number</td>
<td></td>
<td>结束数字    –</td>
</tr>
<tr>
<td>decimals</td>
<td>number</td>
<td>0</td>
<td>小数点位数    –</td>
</tr>
<tr>
<td>duration</td>
<td>number</td>
<td>2</td>
<td>耗时（秒）    –</td>
</tr>
<tr>
<td>options</td>
<td>object</td>
<td></td>
<td>countup.js的设置项    –</td>
</tr>
<tr>
<td>start</td>
<td>boolean</td>
<td>true</td>
<td>是否自动开始计数    –</td>
</tr>
<tr>
<td>tag</td>
<td>string</td>
<td>span</td>
<td>渲染标签    v2.5.5</td>
</tr>
</tbody></table>
<h4 id="6-4-3-countup组件的注册"><a href="#6-4-3-countup组件的注册" class="headerlink" title="6.4.3 countup组件的注册"></a>6.4.3 countup组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Countup &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Countup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Countup &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'countup'</span>, Countup)</span><br></pre></td></tr></table></figure>
<h4 id="6-4-4-countup组件的使用"><a href="#6-4-4-countup组件的使用" class="headerlink" title="6.4.4 countup组件的使用"></a>6.4.4 countup组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">countup</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:start-val</span>=<span class="string">"1"</span>  设置开始数字</span></span><br><span class="line"><span class="tag">  <span class="attr">:end-val</span>=<span class="string">"1388"</span>  设置结束数组</span></span><br><span class="line"><span class="tag">  <span class="attr">:duration</span>=<span class="string">"2"</span>  设置使用时间</span></span><br><span class="line"><span class="tag">  <span class="attr">:decimals</span>=<span class="string">"2"</span>  设置小数点后位数</span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"demo"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">countup</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-5-Flow-FlowState-FlowLine-类似于当前流程的进度的组件，只有一条直线，可以是竖直方向或水平方向"><a href="#6-5-Flow-FlowState-FlowLine-类似于当前流程的进度的组件，只有一条直线，可以是竖直方向或水平方向" class="headerlink" title="6.5 Flow, FlowState, FlowLine (类似于当前流程的进度的组件，只有一条直线，可以是竖直方向或水平方向)"></a>6.5 Flow, FlowState, FlowLine (类似于当前流程的进度的组件，只有一条直线，可以是竖直方向或水平方向)</h3><h4 id="6-5-1-Flow-FlowState-FlowLine组件的功能"><a href="#6-5-1-Flow-FlowState-FlowLine组件的功能" class="headerlink" title="6.5.1 Flow, FlowState, FlowLine组件的功能"></a>6.5.1 Flow, FlowState, FlowLine组件的功能</h4><p>显示当前流程进度的组件；例如购买的物品的物流进度（注意是一条直线）</p>
<h4 id="6-5-2-Flow的属性-FlowState的属性和插槽-FlowLine的属性"><a href="#6-5-2-Flow的属性-FlowState的属性和插槽-FlowLine的属性" class="headerlink" title="6.5.2 Flow的属性, FlowState的属性和插槽, FlowLine的属性"></a>6.5.2 Flow的属性, FlowState的属性和插槽, FlowLine的属性</h4><table>
<thead>
<tr>
<th>Flow组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>orientation</td>
<td>string</td>
<td>horizontal</td>
<td>flow 方向，可选<code>[&#39;horizontal&#39;, &#39;vertical&#39;]</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>FlowState组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题    –</td>
</tr>
<tr>
<td>state</td>
<td>string number</td>
<td></td>
<td>在节点中显示的内容    –</td>
</tr>
<tr>
<td>is-done</td>
<td>boolean</td>
<td>false</td>
<td>该节点是否完成</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>FlowState组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>标题插槽，默认内容为 <code>prop:title</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>FlowLine组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tip</td>
<td>string</td>
<td></td>
<td>流线的提示文字，当 is-done 为 true 时无效    –</td>
</tr>
<tr>
<td>tip-direction</td>
<td>string    top for horizontal flow, left for vertical flow</td>
<td>提示文字方向，可选<code>[&#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, &#39;left&#39;]</code>. 在横向 flow 中默认为 top，纵向默认则为 left    –</td>
<td></td>
</tr>
<tr>
<td>is-done</td>
<td>boolean</td>
<td>false</td>
<td>该流线是否完成    –</td>
</tr>
<tr>
<td>line-span</td>
<td>number string</td>
<td></td>
<td>流线的整体长度，如果不设置，所有 <code>flow line</code> 将平分    –</td>
</tr>
<tr>
<td>process-span</td>
<td>number string</td>
<td>50</td>
<td>在 <code>flow line</code> 上显示的进度比例    –</td>
</tr>
</tbody></table>
<h4 id="6-5-3-Flow-FlowState-FlowLine的注册"><a href="#6-5-3-Flow-FlowState-FlowLine的注册" class="headerlink" title="6.5.3 Flow, FlowState, FlowLine的注册"></a>6.5.3 Flow, FlowState, FlowLine的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Flow, FlowState, FlowLine &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; Flow, FlowState, FlowLine &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Flow, FlowState, FlowLine &#125; <span class="keyword">from</span> <span class="string">'vux'</span>  </span><br><span class="line">Vue.component(<span class="string">'flow'</span>, Flow)</span><br><span class="line">Vue.component(<span class="string">'flow-state'</span>, FlowState)</span><br><span class="line">Vue.component(<span class="string">'flow-line'</span>, FlowLine)</span><br></pre></td></tr></table></figure>
<h4 id="6-5-4-Flow-FlowState-FlowLine的使用"><a href="#6-5-4-Flow-FlowState-FlowLine的使用" class="headerlink" title="6.5.4 Flow, FlowState, FlowLine的使用"></a>6.5.4 Flow, FlowState, FlowLine的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">flow</span> <span class="attr">orientation</span>=<span class="string">"vertical"</span>&gt;</span>  默认是horizontal，水平方向</span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-state</span> <span class="attr">state</span>=<span class="string">"1"</span> <span class="attr">:title</span>=<span class="string">"'已付款'"</span> <span class="attr">is-done</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-state</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-line</span> <span class="attr">is-done</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-line</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-state</span> <span class="attr">state</span>=<span class="string">"2"</span> <span class="attr">is-done</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>'已发货'<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">flow-state</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-line</span> <span class="attr">:tip</span>=<span class="string">"'进行中'"</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-line</span>&gt;</span>  tip设置流线的提示文字，当 is-done 为 true 时无效</span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-state</span> <span class="attr">state</span>=<span class="string">"3"</span> <span class="attr">:title</span>=<span class="string">"'待收货'"</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-state</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-line</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-line</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flow-state</span> <span class="attr">state</span>=<span class="string">"4"</span> <span class="attr">:title</span>=<span class="string">"'完成'"</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-state</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-6-Marquee-MarqueeItem-小型的滚动轮播文字组件"><a href="#6-6-Marquee-MarqueeItem-小型的滚动轮播文字组件" class="headerlink" title="6.6 Marquee, MarqueeItem(小型的滚动轮播文字组件)"></a>6.6 Marquee, MarqueeItem(小型的滚动轮播文字组件)</h3><h4 id="6-6-1-Marquee-MarqueeItem组件的功能"><a href="#6-6-1-Marquee-MarqueeItem组件的功能" class="headerlink" title="6.6.1 Marquee, MarqueeItem组件的功能"></a>6.6.1 Marquee, MarqueeItem组件的功能</h4><p>用于新闻等信息的文字滚动轮播显示的组件；</p>
<h4 id="6-6-2-Marquee组件的属性、插槽-MarqueeItem组件的插槽"><a href="#6-6-2-Marquee组件的属性、插槽-MarqueeItem组件的插槽" class="headerlink" title="6.6.2 Marquee组件的属性、插槽, MarqueeItem组件的插槽"></a>6.6.2 Marquee组件的属性、插槽, MarqueeItem组件的插槽</h4><table>
<thead>
<tr>
<th>Marquee组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>interval</td>
<td>number</td>
<td>2000</td>
<td>切换时间间隙    –</td>
</tr>
<tr>
<td>duration</td>
<td>number</td>
<td>300</td>
<td>切换动画时间    –</td>
</tr>
<tr>
<td>direction</td>
<td>string    up</td>
<td>切换方向，可选<code>[&#39;up&#39;, &#39;down&#39;]</code>    –</td>
<td></td>
</tr>
<tr>
<td>item-height</td>
<td>number</td>
<td></td>
<td>条目高度，当默认状态为隐藏时你需要设置值，否则组件渲染时会获取不到正确高度    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>Marquee组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>内容插槽</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>MarqueeItem组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>内容插槽</td>
</tr>
</tbody></table>
<h4 id="6-6-3-Marquee-MarqueeItem组件的注册"><a href="#6-6-3-Marquee-MarqueeItem组件的注册" class="headerlink" title="6.6.3 Marquee, MarqueeItem组件的注册"></a>6.6.3 Marquee, MarqueeItem组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Marquee, MarqueeItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; Marquee, MarqueeItem &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Marquee, MarqueeItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'marquee'</span>, Marquee)</span><br><span class="line">Vue.component(<span class="string">'marquee-item'</span>, MarqueeItem)</span><br></pre></td></tr></table></figure>
<h4 id="6-6-4-Marquee-MarqueeItem组件的使用"><a href="#6-6-4-Marquee-MarqueeItem组件的使用" class="headerlink" title="6.6.4 Marquee, MarqueeItem组件的使用"></a>6.6.4 Marquee, MarqueeItem组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">marquee-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"i in 5"</span>  此处还可以是异步数据，不一定是确定的<span class="attr">5</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"i"</span>  设置<span class="attr">key</span>属性</span></span><br><span class="line"><span class="tag">    @<span class="attr">click.native</span>=<span class="string">"onClick(i)"</span>  点击事件</span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"align-middle"</span>  样式</span></span><br><span class="line"><span class="tag">  &gt;</span>hello world &#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">marquee-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-7-panel"><a href="#6-7-panel" class="headerlink" title="6.7 panel"></a>6.7 panel</h3><h4 id="6-7-1-panel组件的功能"><a href="#6-7-1-panel组件的功能" class="headerlink" title="6.7.1 panel组件的功能"></a>6.7.1 panel组件的功能</h4><p>能够切换图文列表的样式的组件，包括了图文信息的头部底部以及中部的详细信息；</p>
<h4 id="6-7-2-panel组件的属性、事件"><a href="#6-7-2-panel组件的属性、事件" class="headerlink" title="6.7.2 panel组件的属性、事件"></a>6.7.2 panel组件的属性、事件</h4><table>
<thead>
<tr>
<th>panel组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>string</td>
<td></td>
<td>头部文字    –</td>
</tr>
<tr>
<td>footer</td>
<td>object</td>
<td></td>
<td>尾部配置，<code>{url: url, title: title}</code>    –</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
<td></td>
<td>内容列表，<code>[{title, desc, src, fallbackSrc, meta:{source,date,other} }]</code>    –</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>1</td>
<td>布局类型，可选值 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]</code>    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>panel组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-click-header</td>
<td>–</td>
<td>点击头部时触发    –</td>
</tr>
<tr>
<td>@on-click-item</td>
<td>(item)</td>
<td>点击内容列表时触发    –</td>
</tr>
<tr>
<td>@on-click-footer</td>
<td>–</td>
<td>点击尾部时触发    –</td>
</tr>
</tbody></table>
<h4 id="6-7-3-panel组件的注册"><a href="#6-7-3-panel组件的注册" class="headerlink" title="6.7.3 panel组件的注册"></a>6.7.3 panel组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Panel &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Panel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Panel &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'panel'</span>, Panel)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-7-4-panel组件的使用"><a href="#6-7-4-panel组件的使用" class="headerlink" title="6.7.4 panel组件的使用"></a>6.7.4 panel组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">:title</span>=<span class="string">"$t('Switch the type')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span></span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"type"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"type"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">"['1', '2', '3', '4', '5']"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">panel</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:header</span>=<span class="string">"$t('List of content with image')"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:footer</span>=<span class="string">"footer"</span>  数据格式见下方</span></span><br><span class="line"><span class="tag">  <span class="attr">:list</span>=<span class="string">"list"</span>  数据格式见下方</span></span><br><span class="line"><span class="tag">  <span class="attr">:type</span>=<span class="string">"type"</span>  数据格式见下方</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-img-error</span>=<span class="string">"onImgError"</span>  注意参数，如：<span class="attr">onImgError</span> (<span class="attr">item</span>, $<span class="attr">event</span>) &#123; <span class="attr">console.log</span>(<span class="attr">item</span>, $<span class="attr">event</span>) &#125;</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">panel</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'1'</span>,</span><br><span class="line">      list: [&#123;</span><br><span class="line">        src: <span class="string">'http://somedomain.somdomain/x.jpg'</span>,</span><br><span class="line">        fallbackSrc: <span class="string">'http://placeholder.qiniudn.com/60x60/3cc51f/ffffff'</span>,</span><br><span class="line">        title: <span class="string">'标题一'</span>,</span><br><span class="line">        desc: <span class="string">'由各种物质组成的巨型球状天体，叫做星球。星球有一定的形状，有自己的运行轨道。'</span>,</span><br><span class="line">        url: <span class="string">'/component/cell'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        src: <span class="string">'http://placeholder.qiniudn.com/60x60/3cc51f/ffffff'</span>,</span><br><span class="line">        title: <span class="string">'标题二'</span>,</span><br><span class="line">        desc: <span class="string">'由各种物质组成的巨型球状天体，叫做星球。星球有一定的形状，有自己的运行轨道。'</span>,</span><br><span class="line">        url: &#123;</span><br><span class="line">          path: <span class="string">'/component/radio'</span>,</span><br><span class="line">          replace: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          source: <span class="string">'来源信息'</span>,</span><br><span class="line">          date: <span class="string">'时间'</span>,</span><br><span class="line">          other: <span class="string">'其他信息'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">      footer: &#123;</span><br><span class="line">        title: <span class="keyword">this</span>.$t(<span class="string">'more'</span>),</span><br><span class="line">        url: <span class="string">'http://vux.li'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-8-previewer（图片预览——放大图片）"><a href="#6-8-previewer（图片预览——放大图片）" class="headerlink" title="6.8 previewer（图片预览——放大图片）"></a>6.8 previewer（图片预览——放大图片）</h3><h4 id="6-8-1-previewer组件的功能"><a href="#6-8-1-previewer组件的功能" class="headerlink" title="6.8.1 previewer组件的功能"></a>6.8.1 previewer组件的功能</h4><p>图片进行预览的组件，放大的图片功能；注意避免使用过大图片，否则可能会出现卡顿黑屏的情况(尤其是在 Android 机子上) #2514。显示特定index的图片，使用ref:<code>this.$refs.previewer.show(index)</code></p>
<p>list的数据示例如图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  src: <span class="string">'https://placekitten.com/800/400'</span>,</span><br><span class="line">  w: <span class="number">600</span>,</span><br><span class="line">  h: <span class="number">400</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  src: <span class="string">'https://placekitten.com/1200/900'</span>,</span><br><span class="line">  msrc: <span class="string">'https://placekitten.com/120/90'</span>, <span class="comment">// 缩略图</span></span><br><span class="line">  w: <span class="number">1200</span>,</span><br><span class="line">  h: <span class="number">900</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="6-8-2-previewer组件的属性、事件、插槽和方法"><a href="#6-8-2-previewer组件的属性、事件、插槽和方法" class="headerlink" title="6.8.2 previewer组件的属性、事件、插槽和方法"></a>6.8.2 previewer组件的属性、事件、插槽和方法</h4><table>
<thead>
<tr>
<th>previewer组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>array</td>
<td></td>
<td>图片列表    –</td>
</tr>
<tr>
<td>options</td>
<td>object</td>
<td></td>
<td>photoswipe的设置    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>previewer组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-close</td>
<td>–</td>
<td>关闭时触发    v2.2.1-rc.4</td>
</tr>
<tr>
<td>@on-index-change</td>
<td>–</td>
<td>切换图片后触发(首次打开不会触发)    v2.8.1</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>previewer组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>button-after</td>
<td>操作按钮之后，可以添加自定义图标    v2.6.3</td>
</tr>
<tr>
<td>button-before</td>
<td>操作按钮之前，可以添加自定义图标    v2.6.3</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>previewer组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>goTo</td>
<td>(index)</td>
<td>跳转到特定图片    v2.5.10</td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td>跳转到上一张    v2.5.10</td>
</tr>
<tr>
<td>此处有问题</td>
<td></td>
<td>跳转到下一张    v2.5.10</td>
</tr>
<tr>
<td>getCurrentIndex</td>
<td></td>
<td>获取当前图片索引    v2.6.3</td>
</tr>
</tbody></table>
<h4 id="6-8-3-previewer组件的注册"><a href="#6-8-3-previewer组件的注册" class="headerlink" title="6.8.3 previewer组件的注册"></a>6.8.3 previewer组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Previewer &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Previewer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Previewer &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'previewer'</span>, Previewer)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-8-4-previewer组件的使用"><a href="#6-8-4-previewer组件的使用" class="headerlink" title="6.8.4 previewer组件的使用"></a>6.8.4 previewer组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"previewer-demo-img"</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span> <span class="attr">:src</span>=<span class="string">"item.src"</span> <span class="attr">width</span>=<span class="string">"100"</span> @<span class="attr">click</span>=<span class="string">"show(index)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">previewer</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:list</span>=<span class="string">"list"</span>  数据格式见下方</span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"previewer"</span>  用于下方进行操作该组件元素</span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">"options"</span>  数据格式见下方</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-index-change</span>=<span class="string">"logIndexChange"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">previewer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  logIndexChange (arg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  &#125;,</span><br><span class="line">  show (index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.previewer.show(index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list: [&#123;</span><br><span class="line">      msrc: <span class="string">'http://ww1.sinaimg.cn/thumbnail/663d3650gy1fplwu9ze86j20m80b40t2.jpg'</span>,</span><br><span class="line">      src: <span class="string">'http://ww1.sinaimg.cn/large/663d3650gy1fplwu9ze86j20m80b40t2.jpg'</span>,</span><br><span class="line">      w: <span class="number">800</span>,</span><br><span class="line">      h: <span class="number">400</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      msrc: <span class="string">'http://ww1.sinaimg.cn/thumbnail/663d3650gy1fplwvqwuoaj20xc0p0t9s.jpg'</span>,</span><br><span class="line">      src: <span class="string">'http://ww1.sinaimg.cn/large/663d3650gy1fplwvqwuoaj20xc0p0t9s.jpg'</span>,</span><br><span class="line">      w: <span class="number">1200</span>,</span><br><span class="line">      h: <span class="number">900</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      msrc: <span class="string">'http://ww1.sinaimg.cn/thumbnail/663d3650gy1fplwwcynw2j20p00b4js9.jpg'</span>,</span><br><span class="line">      src: <span class="string">'http://ww1.sinaimg.cn/large/663d3650gy1fplwwcynw2j20p00b4js9.jpg'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    options: &#123;</span><br><span class="line">      getThumbBoundsFn (index) &#123;</span><br><span class="line">        <span class="comment">// find thumbnail element</span></span><br><span class="line">        <span class="keyword">let</span> thumbnail = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.previewer-demo-img'</span>)[index]</span><br><span class="line">        <span class="comment">// get window scroll Y</span></span><br><span class="line">        <span class="keyword">let</span> pageYScroll = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">        <span class="comment">// optionally get horizontal scroll</span></span><br><span class="line">        <span class="comment">// get position of element relative to viewport</span></span><br><span class="line">        <span class="keyword">let</span> rect = thumbnail.getBoundingClientRect()</span><br><span class="line">        <span class="comment">// w = width</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">x</span>: rect.left, <span class="attr">y</span>: rect.top + pageYScroll, <span class="attr">w</span>: rect.width&#125;</span><br><span class="line">        <span class="comment">// Good guide on how to get element coordinates:</span></span><br><span class="line">        <span class="comment">// http://javascript.info/tutorial/coordinates</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-9-qrcode（二维码图片组件）"><a href="#6-9-qrcode（二维码图片组件）" class="headerlink" title="6.9 qrcode（二维码图片组件）"></a>6.9 qrcode（二维码图片组件）</h3><h4 id="6-9-1-qrcode组件的功能"><a href="#6-9-1-qrcode组件的功能" class="headerlink" title="6.9.1 qrcode组件的功能"></a>6.9.1 qrcode组件的功能</h4><h4 id="6-9-2-qrcode组件的属性"><a href="#6-9-2-qrcode组件的属性" class="headerlink" title="6.9.2 qrcode组件的属性"></a>6.9.2 qrcode组件的属性</h4><table>
<thead>
<tr>
<th>组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>编码内容，如果为链接，请保证有http(s)协议名    –</td>
</tr>
<tr>
<td>size</td>
<td>number</td>
<td>80</td>
<td>尺寸大小    –</td>
</tr>
<tr>
<td>bg-color</td>
<td>string</td>
<td>白色#FFFFFF</td>
<td>背景颜色    –</td>
</tr>
<tr>
<td>fg-color</td>
<td>string</td>
<td>黑色#000000</td>
<td>二维码着色    –</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>img</td>
<td>渲染类型，可以为<code>img</code>(适合需要在微信需要长按识别的场景)和<code>canvas</code> –</td>
</tr>
</tbody></table>
<h4 id="6-9-3-qrcode组件的注册"><a href="#6-9-3-qrcode组件的注册" class="headerlink" title="6.9.3 qrcode组件的注册"></a>6.9.3 qrcode组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Qrcode &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Qrcode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Qrcode &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'qrcode'</span>, Qrcode)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-9-4-qrcode组件的使用"><a href="#6-9-4-qrcode组件的使用" class="headerlink" title="6.9.4 qrcode组件的使用"></a>6.9.4 qrcode组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qrcode</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"https://vux.li?x-page=demo_qrcode"</span>  设置编码内容：图片的地址</span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"img"</span>  设置渲染类型，默认`<span class="attr">img</span>`，还可以是`<span class="attr">canvas</span>`</span></span><br><span class="line"><span class="tag">  <span class="attr">:fg-color</span>=<span class="string">"fgColor"</span>  设置背景颜色，如：<span class="attr">fgColor:</span> '#<span class="attr">000000</span>'</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">qrcode</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态改变fgColor的值</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">`https://vux.li?t=<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span></span><br><span class="line">    <span class="keyword">this</span>.fgColor = <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777215</span>).toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-10-Step-StepItem-分步骤的组件，和之前的flow样式有点儿像，但是间距大些"><a href="#6-10-Step-StepItem-分步骤的组件，和之前的flow样式有点儿像，但是间距大些" class="headerlink" title="6.10 Step, StepItem (分步骤的组件，和之前的flow样式有点儿像，但是间距大些)"></a>6.10 Step, StepItem (分步骤的组件，和之前的flow样式有点儿像，但是间距大些)</h3><h4 id="6-10-1-Step-StepItem组件的功能"><a href="#6-10-1-Step-StepItem组件的功能" class="headerlink" title="6.10.1 Step, StepItem组件的功能"></a>6.10.1 Step, StepItem组件的功能</h4><p>分步骤的组件，能够控制当前的步骤</p>
<h4 id="6-10-2-Step-StepItem组件的属性"><a href="#6-10-2-Step-StepItem组件的属性" class="headerlink" title="6.10.2 Step, StepItem组件的属性"></a>6.10.2 Step, StepItem组件的属性</h4><h4 id="6-10-3-Step-StepItem组件的注册"><a href="#6-10-3-Step-StepItem组件的注册" class="headerlink" title="6.10.3 Step, StepItem组件的注册"></a>6.10.3 Step, StepItem组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Step, StepItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Step,</span><br><span class="line">    StepItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Step, StepItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'step'</span>, Step)</span><br><span class="line">Vue.component(<span class="string">'step-item'</span>, StepItem</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-10-4-Step-StepItem组件的使用"><a href="#6-10-4-Step-StepItem组件的使用" class="headerlink" title="6.10.4 Step, StepItem组件的使用"></a>6.10.4 Step, StepItem组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">step</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"step"</span>  使用<span class="attr">v-model</span>进行值绑定，该值为当前进行的步骤（高亮）</span></span><br><span class="line"><span class="tag">  <span class="attr">background-color</span>=<span class="string">'#fbf9fe'</span>  设置当前的步骤的背景颜色</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">step-item</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:title</span>=<span class="string">"$t('step 1')"</span>  设置标题信息</span></span><br><span class="line"><span class="tag">    <span class="attr">description</span>=<span class="string">"step 1"</span>  设置描述信息</span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">step-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">step-item</span> <span class="attr">:title</span>=<span class="string">"$t('step 2')"</span> <span class="attr">description</span>=<span class="string">"step 2"</span>&gt;</span><span class="tag">&lt;/<span class="name">step-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">step-item</span> <span class="attr">:title</span>=<span class="string">"$t('step 3')"</span> <span class="attr">description</span>=<span class="string">"step 3"</span>&gt;</span><span class="tag">&lt;/<span class="name">step-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click.native</span>=<span class="string">"nextStep"</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击按钮移动步骤的进度</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      step: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    nextStep () &#123;</span><br><span class="line">      <span class="keyword">this</span>.step ++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-11-swiper-轮播图组件"><a href="#6-11-swiper-轮播图组件" class="headerlink" title="6.11 swiper (轮播图组件)"></a>6.11 swiper (轮播图组件)</h3><h4 id="6-11-1-swiper-组件的功能"><a href="#6-11-1-swiper-组件的功能" class="headerlink" title="6.11.1 swiper 组件的功能"></a>6.11.1 swiper 组件的功能</h4><p>轮播图展示的组件；</p>
<p><code>list属性</code>为图片列表快捷设置，如果你需要自定义一些样式，或者内容并不为纯图片，可以引用<code>swiper-item</code>组件来自定义。list 格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  url: <span class="string">'javascript:'</span>,</span><br><span class="line">  img: <span class="string">'https://static.vux.li/demo/1.jpg'</span>,</span><br><span class="line">  title: <span class="string">'送你一朵fua'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  url: <span class="string">'javascript:'</span>,</span><br><span class="line">  img: <span class="string">'https://static.vux.li/demo/5.jpg'</span>,</span><br><span class="line">  title: <span class="string">'送你一次旅行'</span>,</span><br><span class="line">  fallbackImg: <span class="string">'https://static.vux.li/demo/3.jpg'</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>其中的fallbackImg 在 v2.5.13 支持，它将在 img 加载失败时显示，注意的是 fallbackImg 可能会在 img 加载成功时也进行了加载，只是不会显示（取决于浏览器实现）;</p>
<p>注意：不要在swiper里嵌套scroller，在web上过于复杂化而且手势会有冲突，相关Issue将不会处理。 同时该组件场景是固定高度的内容列表，不支持为不同 swiper-item 设置不同高度。如果确实需要设置不同高度，可以通过 ref 获取 swiper, 通过 this.$refs.swiper.xheight = ‘100px’ 设置。 切记，需要放在 $nextTick 中执行。</p>
<h4 id="6-11-2-swiper-组件的属性、事件和样式变量"><a href="#6-11-2-swiper-组件的属性、事件和样式变量" class="headerlink" title="6.11.2 swiper 组件的属性、事件和样式变量"></a>6.11.2 swiper 组件的属性、事件和样式变量</h4><table>
<thead>
<tr>
<th>swiper组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>array</td>
<td></td>
<td>轮播图片列表，如果有自定义样式需求，请使用 <code>swiper-item</code>(使用 swiper-item 时仅有2个的情况下不支持循环)    –</td>
</tr>
<tr>
<td>direction</td>
<td>string</td>
<td>horizontal</td>
<td>方向    –</td>
</tr>
<tr>
<td>show-dots</td>
<td>boolean</td>
<td>true</td>
<td>是否显示提示点    –</td>
</tr>
<tr>
<td>show-desc-mask</td>
<td>boolean</td>
<td>true</td>
<td>是否显示描述半透明遮罩    –</td>
</tr>
<tr>
<td>dots-position</td>
<td>string</td>
<td>right</td>
<td>提示点位置    –</td>
</tr>
<tr>
<td>dots-class</td>
<td>string</td>
<td></td>
<td>提示className    –</td>
</tr>
<tr>
<td>auto</td>
<td>boolean</td>
<td>false</td>
<td>是否自动轮播    –</td>
</tr>
<tr>
<td>loop</td>
<td>boolean</td>
<td>false</td>
<td>是否循环    –</td>
</tr>
<tr>
<td>interval</td>
<td>number</td>
<td>3000</td>
<td>轮播停留时长    –</td>
</tr>
<tr>
<td>threshold</td>
<td>number</td>
<td>50</td>
<td>当滑动超过这个距离时才滑动    –</td>
</tr>
<tr>
<td>duration</td>
<td>number</td>
<td>300</td>
<td>切换动画时间    –</td>
</tr>
<tr>
<td>height</td>
<td>string</td>
<td>180px</td>
<td>高度值。如果为100%宽度并且知道宽高比，可以设置aspect-ratio自动计算高度    –</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>number</td>
<td></td>
<td>用以根据当前可用宽度计算高度值    –</td>
</tr>
<tr>
<td>min-moving-distance</td>
<td>number</td>
<td>0</td>
<td>超过这个距离时才滑动    –</td>
</tr>
<tr>
<td>v-model</td>
<td>number</td>
<td>0</td>
<td>index 绑定，使用v-model，一般不需要绑定    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>swiper组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-index-change</td>
<td>(currentIndex)</td>
<td>轮播 index 变化时触发    –</td>
</tr>
<tr>
<td>@on-get-height</td>
<td>(height)</td>
<td>高度获取后触发    v2.7.0</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>swiper组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@swiper-indicator-active-color</td>
<td>草绿色#04BE02</td>
<td>–    @theme-color</td>
</tr>
</tbody></table>
<h4 id="6-11-3-swiper-组件的注册"><a href="#6-11-3-swiper-组件的注册" class="headerlink" title="6.11.3 swiper 组件的注册"></a>6.11.3 swiper 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Swiper &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Swiper</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Swiper &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'swiper'</span>, Swiper)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-11-4-swiper-组件的使用"><a href="#6-11-4-swiper-组件的使用" class="headerlink" title="6.11.4 swiper 组件的使用"></a>6.11.4 swiper 组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:list</span>=<span class="string">"demo_list"</span>  设置轮播图片列表，如果有自定义样式需求，请使用 `<span class="attr">swiper-item</span>`(使用 <span class="attr">swiper-item</span> 时仅有<span class="attr">2</span>个的情况下不支持循环)</span></span><br><span class="line"><span class="tag">  <span class="attr">auto</span>  设置自动轮播，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loop</span>  设置循环，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">"180px"</span>  设置高度值，默认<span class="attr">180px</span>。如果为<span class="attr">100</span>%宽度并且知道宽高比，可以设置<span class="attr">aspect-ratio</span>自动计算高度</span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"width:85%;margin:0 auto;"</span>  绑定样式</span></span><br><span class="line"><span class="tag">  <span class="attr">:aspect-ratio</span>=<span class="string">"300/800"</span>  用以根据当前可用宽度计算高度值</span></span><br><span class="line"><span class="tag">  <span class="attr">direction</span>=<span class="string">"vertical"</span>  设置方向，默认	<span class="attr">horizontal</span>	</span></span><br><span class="line"><span class="tag">  <span class="attr">:interval</span>=<span class="string">2000</span>  设置轮播停留时长，默认 <span class="attr">3000</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show-dots</span>=<span class="string">"false"</span>  设置是否显示提示点，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">dots-class</span>=<span class="string">"custom-bottom"</span>  设置提示<span class="attr">className</span></span></span><br><span class="line"><span class="tag">  <span class="attr">dots-position</span>=<span class="string">"center"</span>  设置提示点位置</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"demo_index"</span>  使用<span class="attr">v-model</span>进行 <span class="attr">index</span> 绑定，一般不需要绑定</span></span><br><span class="line"><span class="tag">  <span class="attr">:min-moving-distance</span>=<span class="string">"120"</span>  设置超过这个距离时才滑动，默认<span class="attr">0</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-index-change</span>=<span class="string">"demo_onIndexChange"</span>  轮播 <span class="attr">index</span> 变化时触发事件</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:aspect-ratio</span>=<span class="string">"300/800"</span> @<span class="attr">on-index-change</span>=<span class="string">"onSwiperItemIndexChange"</span> <span class="attr">v-model</span>=<span class="string">"swiperItemIndex"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">class</span>=<span class="string">"swiper-demo-img"</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in demo04_list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">auto</span> <span class="attr">height</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">如果有自定义样式需求，请使用 `swiper-item`，使用 swiper-item 时仅有2个的情况下不支持循环</span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">class</span>=<span class="string">"black"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title fadeInUp animated"</span>&gt;</span>它无孔不入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">class</span>=<span class="string">"black"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title fadeInUp animated"</span>&gt;</span>你无处可藏<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">class</span>=<span class="string">"black"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title fadeInUp animated"</span>&gt;</span>不是它可恶<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-12-x-table（类似于h5的table标签）"><a href="#6-12-x-table（类似于h5的table标签）" class="headerlink" title="6.12 x-table（类似于h5的table标签）"></a>6.12 x-table（类似于h5的table标签）</h3><h4 id="6-12-1-x-table组件的功能"><a href="#6-12-1-x-table组件的功能" class="headerlink" title="6.12.1 x-table组件的功能"></a>6.12.1 x-table组件的功能</h4><p>表格内容展示的组件；类似于h5的table标签，子元素可以包含<code>&lt;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt;</code>标签；</p>
<h4 id="6-12-2-x-table组件的属性、插槽"><a href="#6-12-2-x-table组件的属性、插槽" class="headerlink" title="6.12.2 x-table组件的属性、插槽"></a>6.12.2 x-table组件的属性、插槽</h4><table>
<thead>
<tr>
<th>组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>full-bordered</td>
<td>boolean</td>
<td>false</td>
<td>是否显示表格左右边框    v2.2.1-rc.4</td>
</tr>
<tr>
<td>content-bordered</td>
<td>boolean</td>
<td>true</td>
<td>是否显示 body tr 的下边框    v2.2.1-rc.4</td>
</tr>
<tr>
<td>cell-bordered</td>
<td>boolean</td>
<td>true</td>
<td>是否显示表格的右边边框    v2.2.1-rc.4</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>表格内容    v2.2.1-rc.4</td>
</tr>
</tbody></table>
<h4 id="6-12-3-x-table组件的注册"><a href="#6-12-3-x-table组件的注册" class="headerlink" title="6.12.3 x-table组件的注册"></a>6.12.3 x-table组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XTable &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XTable</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XTable &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-table'</span>, XTable)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-12-4-x-table组件的使用"><a href="#6-12-4-x-table组件的使用" class="headerlink" title="6.12.4 x-table组件的使用"></a>6.12.4 x-table组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Product<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$1.25<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$1.20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-13-x-progress（进度条组件）"><a href="#6-13-x-progress（进度条组件）" class="headerlink" title="6.13 x-progress（进度条组件）"></a>6.13 x-progress（进度条组件）</h3><h4 id="6-13-1-x-progress组件的功能"><a href="#6-13-1-x-progress组件的功能" class="headerlink" title="6.13.1 x-progress组件的功能"></a>6.13.1 x-progress组件的功能</h4><p>进度条组件；</p>
<h4 id="6-13-2-x-progress组件的属性、事件"><a href="#6-13-2-x-progress组件的属性、事件" class="headerlink" title="6.13.2 x-progress组件的属性、事件"></a>6.13.2 x-progress组件的属性、事件</h4><table>
<thead>
<tr>
<th>x-progress 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>percent</td>
<td>number</td>
<td>0</td>
<td>进度值，0到100    –</td>
</tr>
<tr>
<td>show-cancel</td>
<td>boolean</td>
<td>true</td>
<td>是否显示取消按钮    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-progress 组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-cancel    –    点击取消按钮时触发</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="6-13-3-x-progress组件的注册"><a href="#6-13-3-x-progress组件的注册" class="headerlink" title="6.13.3 x-progress组件的注册"></a>6.13.3 x-progress组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XProgress &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XProgress</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XProgress &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-progress'</span>, XProgres</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-13-4-x-progress组件的使用"><a href="#6-13-4-x-progress组件的使用" class="headerlink" title="6.13.4 x-progress组件的使用"></a>6.13.4 x-progress组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-progress</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:percent</span>=<span class="string">"percent2"</span>  设置进度条的值<span class="attr">0</span>到<span class="attr">100</span>，默认<span class="attr">0</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show-cancel</span>=<span class="string">"false"</span>  设置是否显示取消按钮，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">x-progress</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-14-x-img-在懒加载中使用"><a href="#6-14-x-img-在懒加载中使用" class="headerlink" title="6.14. x-img (在懒加载中使用)"></a>6.14. x-img (在懒加载中使用)</h3><h4 id="6-14-1-x-img组件的功能"><a href="#6-14-1-x-img组件的功能" class="headerlink" title="6.14.1 x-img组件的功能"></a>6.14.1 x-img组件的功能</h4><h4 id="6-14-2-x-img组件的属性"><a href="#6-14-2-x-img组件的属性" class="headerlink" title="6.14.2 x-img组件的属性"></a>6.14.2 x-img组件的属性</h4><table>
<thead>
<tr>
<th>x-img组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default-src</td>
<td>string</td>
<td></td>
<td>默认显示的图片地址    –</td>
</tr>
<tr>
<td>src</td>
<td>string</td>
<td></td>
<td>最终加载的图片地址    –</td>
</tr>
<tr>
<td>webp-src</td>
<td>string</td>
<td></td>
<td>webp 格式的图片地址，如果当前浏览器支持webp，则加载该地址 –</td>
</tr>
<tr>
<td>error-class</td>
<td>string</td>
<td></td>
<td>加载失败时添加到 img 元素上的类名    –</td>
</tr>
<tr>
<td>success-class</td>
<td>string</td>
<td></td>
<td>加载成功时添加到 img 元素上的类名    –</td>
</tr>
<tr>
<td>offset    number</td>
<td>100</td>
<td></td>
<td>距离多远时开始加载    –</td>
</tr>
<tr>
<td>container</td>
<td>string</td>
<td>window</td>
<td>当图片是在一个容器里滚动时(比如demo站点100%高度的布局)，你需要指定容器的选择器    –</td>
</tr>
<tr>
<td>delay</td>
<td>number</td>
<td>0    延迟执行，在存在路由过渡时立即执行可能会导致进入页面后并不会正确加载图片。该属性在 2.5.4 后已经不推荐使用，推荐使用 BusPlugin 来通知组件页面已经载入完成。    –</td>
<td></td>
</tr>
<tr>
<td>separator</td>
<td>string</td>
<td></td>
<td>支持设置src的分隔符    –</td>
</tr>
</tbody></table>
<h4 id="6-14-3-x-img组件的注册"><a href="#6-14-3-x-img组件的注册" class="headerlink" title="6.14.3 x-img组件的注册"></a>6.14.3 x-img组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XImg &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XImg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XImg &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-img'</span>, XImg)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-14-4-x-img组件的使用"><a href="#6-14-4-x-img组件的使用" class="headerlink" title="6.14.4 x-img组件的使用"></a>6.14.4 x-img组件的使用</h4><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for<span class="built_in">=</span><span class="string">"src in list"</span> style<span class="built_in">=</span><span class="string">"background-color:yellow;text-align:center;"</span>&gt;</span><br><span class="line">      &lt;span style<span class="built_in">=</span><span class="string">"font-size:20px;"</span>&gt;Loading&lt;/span&gt;</span><br><span class="line">      &lt;x-img</span><br><span class="line">        :src<span class="built_in">=</span><span class="string">"src"</span>  设置最终加载的图片地址</span><br><span class="line">        :webp-src<span class="built_in">=</span><span class="string">"`$&#123;src&#125;?type=webp`"</span>  </span><br><span class="line">        @on-success<span class="built_in">=</span><span class="string">"success"</span>  </span><br><span class="line">        @on-error<span class="built_in">=</span><span class="string">"error"</span>  </span><br><span class="line">        class<span class="built_in">=</span><span class="string">"ximg-demo"</span>  </span><br><span class="line">        error-class<span class="built_in">=</span><span class="string">"ximg-error"</span>  </span><br><span class="line">        :offset<span class="built_in">=</span><span class="string">"-100"</span>  </span><br><span class="line">        container<span class="built_in">=</span><span class="string">"#vux_view_box_body"</span>  </span><br><span class="line">      &gt;&lt;/x-img&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; XImg &#125; from <span class="string">'vux'</span></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XImg</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    success (src, ele) &#123;</span><br><span class="line">      console.log(<span class="string">'success load'</span>, src)</span><br><span class="line">      const span <span class="built_in">=</span> ele.parentNode.querySelector(<span class="string">'span'</span>)</span><br><span class="line">      ele.parentNode.removeChild(span)</span><br><span class="line">    &#125;,</span><br><span class="line">    error (src, ele, msg) &#123;</span><br><span class="line">      console.log(<span class="string">'error load'</span>, msg, src)</span><br><span class="line">      const span <span class="built_in">=</span> ele.parentNode.querySelector(<span class="string">'span'</span>)</span><br><span class="line">      span.innerText <span class="built_in">=</span> <span class="string">'load error'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test1.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test2.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test0.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test4.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test5.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test6.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test7.jpg'</span>,</span><br><span class="line">        <span class="string">'https://o5omsejde.qnssl.com/demo/test8.jpg'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.ximg-demo &#123;</span><br><span class="line">  width: <span class="number">100</span><span class="comment">%;</span></span><br><span class="line">  height: auto;</span><br><span class="line">&#125;</span><br><span class="line">.ximg-error &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.ximg-error:after &#123;</span><br><span class="line">  content: <span class="string">'加载失败'</span>;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h2 id="7-弹窗提示组件"><a href="#7-弹窗提示组件" class="headerlink" title="7. 弹窗提示组件"></a>7. 弹窗提示组件</h2><h3 id="7-1-actionsheet-弹出框，类似微信底部弹出框"><a href="#7-1-actionsheet-弹出框，类似微信底部弹出框" class="headerlink" title="7.1 actionsheet(弹出框，类似微信底部弹出框)"></a>7.1 actionsheet(弹出框，类似微信底部弹出框)</h3><h4 id="7-1-1-actionsheet-组件的功能"><a href="#7-1-1-actionsheet-组件的功能" class="headerlink" title="7.1.1 actionsheet 组件的功能"></a>7.1.1 actionsheet 组件的功能</h4><p>actionsheet 组件是一个弹窗组件，是用户操作后触发的一种特定的模态弹出框，一般用在在页面的中部或者底部，效果如微信中的底部弹出分享朋友圈、好友、取消设置；</p>
<h4 id="7-1-2-actionsheet-组件的属性、事件、插槽和样式变量"><a href="#7-1-2-actionsheet-组件的属性、事件、插槽和样式变量" class="headerlink" title="7.1.2 actionsheet 组件的属性、事件、插槽和样式变量"></a>7.1.2 actionsheet 组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>actionsheet 的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>是否显示, 使用 <code>v-model</code> 绑定变量</td>
</tr>
<tr>
<td>show-cancel</td>
<td>boolean</td>
<td>false</td>
<td>是否显示取消菜单，对安卓风格无效</td>
</tr>
<tr>
<td>cancel-text</td>
<td>string</td>
<td>cancel(取消)</td>
<td>取消菜单的显示文字</td>
</tr>
<tr>
<td>theme</td>
<td>string</td>
<td>ios</td>
<td>菜单风格，可选值为<code>[&#39;ios&#39;,&#39;android&#39;]</code></td>
</tr>
<tr>
<td>menus</td>
<td>object array</td>
<td>{}</td>
<td>菜单项列表，举例：<code>{menu1: &#39;删除&#39;}</code>，如果名字上带有<code>.noop</code>表明这是纯文本(HTML)展示，不会触发事件，用于展示描述或者提醒。从v2.1.0开始支持数组类型的菜单，可自定义键值，见下面说明。</td>
</tr>
<tr>
<td>close-on-clicking-mask</td>
<td>boolean</td>
<td>true</td>
<td>点击遮罩时是否关闭菜单，适用于一些进入页面时需要强制选择的场景。</td>
</tr>
<tr>
<td>close-on-clicking-menu</td>
<td>boolean</td>
<td>true</td>
<td>点击菜单时是否自动隐藏</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>actionsheet 的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-click-menu</td>
<td>(menuKey, menuItem)</td>
<td>点击菜单时触发</td>
</tr>
<tr>
<td>@on-click-menu-{menuKey}</td>
<td>(menuKey)</td>
<td>点击事件的快捷方式, <code>menuKey与label</code>的值有关。举例：如果你有一个菜单名字为<code>delete</code>, 那么你可以监听 <code>on-click-menu-delete</code></td>
</tr>
<tr>
<td>@on-click-menu-cancel</td>
<td>–</td>
<td>点击取消菜单时触发</td>
</tr>
<tr>
<td>@on-click-mask</td>
<td>–</td>
<td>点击遮罩时触发</td>
</tr>
<tr>
<td>@on-after-show</td>
<td>–</td>
<td>显示动画结束时触发</td>
</tr>
<tr>
<td>@on-after-hide</td>
<td>–</td>
<td>隐藏动画结束时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>actionsheet 的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>头部位置</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>actionsheet 的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@actionsheet-label-primary-color</td>
<td>草绿色#1AAD19</td>
<td>菜单项<code>primary</code>类型的文本颜色</td>
</tr>
<tr>
<td>@actionsheet-label-warn-color</td>
<td>橙红色#E64340</td>
<td>菜单项<code>warn</code>类型的文本颜色</td>
</tr>
<tr>
<td>@actionsheet-label-default-color</td>
<td>黑色#000</td>
<td>菜单项<code>default</code>类型的文本颜色</td>
</tr>
<tr>
<td>@actionsheet-label-disabled-color</td>
<td>灰色#ccc</td>
<td>菜单项<code>disabled</code>类型的文本颜色</td>
</tr>
</tbody></table>
<h4 id="7-1-3-actionsheet-组件的注册"><a href="#7-1-3-actionsheet-组件的注册" class="headerlink" title="7.1.3 actionsheet 组件的注册"></a>7.1.3 actionsheet 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Actionsheet &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Actionsheet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Actionsheet &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'actionsheet'</span>, Actionsheet)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-1-4-actionsheet-组件的使用"><a href="#7-1-4-actionsheet-组件的使用" class="headerlink" title="7.1.4 actionsheet 组件的使用"></a>7.1.4 actionsheet 组件的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;actionsheet</span><br><span class="line">  v-model=<span class="string">"isShow"</span>  使用v-model双绑定，根据变量是否显示组件</span><br><span class="line">  :menus=<span class="string">"menus"</span>  绑定菜单项列表变量，菜单列表格式menuKey与label的值举例：<span class="string">`&#123;menu1: '删除'&#125;`</span></span><br><span class="line">  theme=<span class="string">"android"</span>  弹出框菜单风格，默认为<span class="string">`ios`</span></span><br><span class="line">  show-cancel  显示取消菜单，默认是<span class="string">`false`</span>，对安卓风格无效</span><br><span class="line">  cancel-text=<span class="string">"点击取消"</span>  取消菜单的显示文字，默认是<span class="string">`取消`</span></span><br><span class="line">  :close-on-clicking-mask=<span class="string">"false"</span>  设置点击遮罩不隐藏弹窗</span><br><span class="line">  :close-on-clicking-menu=<span class="string">"false"</span>  设置点击菜单时不自动隐藏</span><br><span class="line">  @on-click-menu=<span class="string">"click"</span>  点击菜单时触发</span><br><span class="line">  @on-click-menu-<span class="keyword">delete</span>=<span class="string">"onDelete"</span>  点击菜单中的菜单名字为<span class="string">`delete`</span>时触发</span><br><span class="line">  @on-click-menu-cancel=<span class="string">"onCancel"</span>  点击菜单中的取消菜单时触发</span><br><span class="line">  @on-click-mask=<span class="string">"clickMask"</span>   点击遮罩时触发</span><br><span class="line">  @on-after-hide=<span class="string">"log('after hide')"</span>  隐藏动画结束时触发</span><br><span class="line">  @on-after-show=<span class="string">"log('after show')"</span>  显示动画结束时触发</span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">actionsheet</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-alert"><a href="#7-2-alert" class="headerlink" title="7.2 alert"></a>7.2 alert</h3><h4 id="7-2-1-alert-组件的功能"><a href="#7-2-1-alert-组件的功能" class="headerlink" title="7.2.1 alert 组件的功能"></a>7.2.1 alert 组件的功能</h4><p>alert 组件个html中的alert功能相同，属于是弹出一个信息框，之后可以是自动消失，或者是点击消失；</p>
<h4 id="7-2-2-alert-组件的属性和样式变量"><a href="#7-2-2-alert-组件的属性和样式变量" class="headerlink" title="7.2.2 alert 组件的属性和样式变量"></a>7.2.2 alert 组件的属性和样式变量</h4><table>
<thead>
<tr>
<th>alert 的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>是否显示, 使用 <code>v-model</code> 绑定变量</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>弹窗标题</td>
</tr>
<tr>
<td>content</td>
<td>string</td>
<td></td>
<td>提示内容，作为 <code>slot:default</code> 的默认内容，如果使用 <code>slot:default</code>, 将会失效</td>
</tr>
<tr>
<td>button-text</td>
<td>string</td>
<td>ok(确定)</td>
<td>按钮文字</td>
</tr>
<tr>
<td>hide-on-blur</td>
<td>boolean</td>
<td>false</td>
<td>是否在点击遮罩时自动关闭弹窗</td>
</tr>
<tr>
<td>mask-transition</td>
<td>string</td>
<td>vux-fade</td>
<td>遮罩动画</td>
</tr>
<tr>
<td>dialog-transition</td>
<td>string</td>
<td>vux-dialog</td>
<td>弹窗主体动画</td>
</tr>
<tr>
<td>mask-z-index</td>
<td>number string</td>
<td>1000</td>
<td>遮罩层 <code>z-index</code> 值</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>alert 的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗显示时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗关闭时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>alert 的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>提示内容</td>
</tr>
</tbody></table>
<h4 id="7-2-3-alert-组件的注册（包括插件形式）"><a href="#7-2-3-alert-组件的注册（包括插件形式）" class="headerlink" title="7.2.3 alert 组件的注册（包括插件形式）"></a>7.2.3 alert 组件的注册（包括插件形式）</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Alert &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Alert</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件全局引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Alert &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'alert'</span>, Alert)</span><br></pre></td></tr></table></figure></li>
<li>c. 作为插件使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入与注册使用</span></span><br><span class="line"><span class="keyword">import</span>  &#123; AlertPlugin &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.use(AlertPlugin)</span><br><span class="line"><span class="comment">// 或者umd方式,引入构建的js文件</span></span><br><span class="line">Vue.use(vuxAlertPlugin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为插件使用</span></span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="keyword">this</span>.$vux.alert.show(&#123;</span><br><span class="line">  title: <span class="string">'Vux is Cool'</span>,</span><br><span class="line">  content: <span class="string">'Do you agree?'</span>,</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m showing'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m hiding'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 隐藏</span></span><br><span class="line"><span class="keyword">this</span>.$vux.alert.hide()</span><br><span class="line"><span class="comment">// 获取显示状态</span></span><br><span class="line"><span class="keyword">this</span>.$vux.alert.isVisible() <span class="comment">// v2.9.1 支持</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-2-4-alert-组件的使用或alert作为插件方式调用或作为一个module使用"><a href="#7-2-4-alert-组件的使用或alert作为插件方式调用或作为一个module使用" class="headerlink" title="7.2.4 alert 组件的使用或alert作为插件方式调用或作为一个module使用"></a>7.2.4 alert 组件的使用或alert作为插件方式调用或作为一个module使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"show"</span>  使用<span class="attr">v-model</span>数据绑定显示或隐藏<span class="attr">alert</span>弹出框</span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">"'显示在弹出框中的标题'"</span>  设置弹出框的标题信息</span></span><br><span class="line"><span class="tag">  <span class="attr">:content</span>=<span class="string">"'显示在弹出框中的内容'"</span>  设置弹出框的内容信息，也可以使用<span class="attr">slot</span>插槽写内容</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-show</span>=<span class="string">"onShow"</span>  弹窗显示时触发</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-hide</span>=<span class="string">"onHide"</span>  弹窗关闭时触发</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123; $t('Your Message is sent successfully~') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件方式调用</span></span><br><span class="line"><span class="comment">// 弹出alert框</span></span><br><span class="line"><span class="keyword">this</span>.$vux.alert.show(&#123;</span><br><span class="line">  title: <span class="string">'VUX is Cool'</span>,</span><br><span class="line">  content: <span class="keyword">this</span>.$t(<span class="string">'Do you agree?'</span>),</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m showing'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m hiding now'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 隐藏alert框</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$vux.alert.hide()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个module使用</span></span><br><span class="line"><span class="comment">// 弹出alert框</span></span><br><span class="line">AlertModule.show(&#123;</span><br><span class="line">  title: <span class="string">'VUX is Cool'</span>,</span><br><span class="line">  content: <span class="keyword">this</span>.$t(<span class="string">'Do you agree?'</span>),</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Module: I\'m showing'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Module: I\'m hiding now'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 隐藏alert框</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  AlertModule.hide()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听alert作为插件使用的时候的显示隐藏状态</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$vux.alert.isVisible())</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-confirm"><a href="#7-3-confirm" class="headerlink" title="7.3 confirm"></a>7.3 confirm</h3><h4 id="7-3-1-confirm-组件的功能"><a href="#7-3-1-confirm-组件的功能" class="headerlink" title="7.3.1 confirm 组件的功能"></a>7.3.1 confirm 组件的功能</h4><p>confirm 组件个html中的confirm功能相同，属于是弹出一个信息框，可以点击确定或者取消，也可以点击遮罩消失，或者是自动消失；</p>
<h4 id="7-3-2-confirm-组件的属性、事件、插槽和方法"><a href="#7-3-2-confirm-组件的属性、事件、插槽和方法" class="headerlink" title="7.3.2 confirm 组件的属性、事件、插槽和方法"></a>7.3.2 confirm 组件的属性、事件、插槽和方法</h4><table>
<thead>
<tr>
<th>confirm 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>是否显示，使用<code>v-model</code>绑定</td>
</tr>
<tr>
<td>show-input</td>
<td>boolean</td>
<td>false</td>
<td>是否显示输入框，如果为true，slot会失效</td>
</tr>
<tr>
<td>placeholder</td>
<td>string</td>
<td></td>
<td>输入框的提示（仅在<code>showInput为true</code>的情况下有效）</td>
</tr>
<tr>
<td>theme</td>
<td>string</td>
<td>ios</td>
<td>弹窗风格，可以是<code>ios或android</code></td>
</tr>
<tr>
<td>hide-on-blur</td>
<td>boolean</td>
<td>false</td>
<td>是否在点击遮罩时自动关闭弹窗</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>弹窗标题</td>
</tr>
<tr>
<td>content</td>
<td>string</td>
<td></td>
<td>弹窗内容，作为<code>slot默认内容</code>，可以是html片段，如果使用slot该字段会失效</td>
</tr>
<tr>
<td>confirm-text</td>
<td>string</td>
<td>确认(confirm)</td>
<td>确认按钮的显示文字</td>
</tr>
<tr>
<td>cancel-text</td>
<td>string</td>
<td>取消(cancel)</td>
<td>取消按钮的显示文字</td>
</tr>
<tr>
<td>mask-transition</td>
<td>string</td>
<td>vux-fade</td>
<td>遮罩动画</td>
</tr>
<tr>
<td>dialog-transition</td>
<td>string</td>
<td>vux-dialog</td>
<td>弹窗动画</td>
</tr>
<tr>
<td>close-on-confirm</td>
<td>boolean</td>
<td>true</td>
<td>是否在点击确认按钮时自动关闭</td>
</tr>
<tr>
<td>input-attrs</td>
<td>object</td>
<td></td>
<td>input 属性</td>
</tr>
<tr>
<td>mask-z-index</td>
<td>number string</td>
<td>1000</td>
<td>遮罩层 <code>z-index</code>值</td>
</tr>
<tr>
<td>show-cancel-button</td>
<td>boolean</td>
<td>true</td>
<td>是否显示取消按钮</td>
</tr>
<tr>
<td>show-confirm-button</td>
<td>boolean</td>
<td>true</td>
<td>是否显示确定按钮</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>confirm 组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-cancel</td>
<td>–</td>
<td>点击取消按钮时触发</td>
</tr>
<tr>
<td>@on-confirm</td>
<td>(value)</td>
<td>点击确定按钮时触发, 参数为<code>prompt</code>中输入的值</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗出现时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗隐藏时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>confirm 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>弹窗主体内容</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>confirm 组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setInputValue</td>
<td>(value)</td>
<td>设置输入值，当 <code>show-input 为 true</code> 时有效</td>
</tr>
</tbody></table>
<h4 id="7-3-3-confirm-组件的注册（包括插件形式）"><a href="#7-3-3-confirm-组件的注册（包括插件形式）" class="headerlink" title="7.3.3 confirm 组件的注册（包括插件形式）"></a>7.3.3 confirm 组件的注册（包括插件形式）</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Confirm &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Confirm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Confirm &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'confirm'</span>, Confirm)</span><br></pre></td></tr></table></figure></li>
<li>c. 插件形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; ConfirmPlugin &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.use(ConfirmPlugin)</span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="keyword">const</span> _this = <span class="keyword">this</span> <span class="comment">// 需要注意 onCancel 和 onConfirm 的 this 指向</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.show(&#123;</span><br><span class="line">  <span class="comment">// 组件除show外的属性</span></span><br><span class="line">  onCancel () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 非当前 vm</span></span><br><span class="line">    <span class="built_in">console</span>.log(_this) <span class="comment">// 当前 vm</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onConfirm () &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 隐藏</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.hide()</span><br><span class="line"><span class="comment">// prompt形式调用</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.prompt(<span class="string">'placeholder'</span>, &#123;</span><br><span class="line">  onCancel () &#123;&#125;</span><br><span class="line">  onConfirm () &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置输入值</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.setInputValue(<span class="string">'value'</span>) <span class="comment">// 注意需要在 onShow 事件中执行</span></span><br><span class="line"><span class="comment">// 获取显示状态</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.isVisible() <span class="comment">// v2.9.1 支持</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-3-4-confirm-组件的使用或插件形式使用或插件形式使用prompt"><a href="#7-3-4-confirm-组件的使用或插件形式使用或插件形式使用prompt" class="headerlink" title="7.3.4 confirm 组件的使用或插件形式使用或插件形式使用prompt"></a>7.3.4 confirm 组件的使用或插件形式使用或插件形式使用prompt</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;confirm</span><br><span class="line">  v-model=<span class="string">"show"</span>  使用v-model数据绑定，用于弹出框显示和隐藏</span><br><span class="line">  show-input</span><br><span class="line">  ref=<span class="string">"confirm"</span>  设置ref属性</span><br><span class="line">  :title=<span class="string">"'弹出框的标题'"</span></span><br><span class="line">  theme=<span class="string">"android"</span>  设置主题为安卓，默认是ios</span><br><span class="line">  hide-on-blur=<span class="string">"true	"</span> 点击遮罩时自动关闭弹窗,默认为<span class="literal">false</span></span><br><span class="line">  @on-cancel=<span class="string">"onCance"</span>  点击取消按钮时触发</span><br><span class="line">  @on-confirm=<span class="string">"onConfirm"</span>  点击确定按钮时触发, 参数为<span class="string">`prompt`</span>中输入的值</span><br><span class="line">  @on-show=<span class="string">"onShow"</span>  弹窗出现时触发</span><br><span class="line">  @on-hide=<span class="string">"onHide"</span>  弹窗隐藏时触发</span><br><span class="line">&gt;填写你的内容&lt;<span class="regexp">/confirm&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件形式使用</span></span><br><span class="line"><span class="keyword">this</span>.$vux.confirm.show(&#123;</span><br><span class="line">  title: <span class="string">'Title'</span>,</span><br><span class="line">  content: <span class="string">'Content'</span>,</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin show'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin hide'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onCancel () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin cancel'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onConfirm () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin confirm'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showPlugin3 () &#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">this</span>.$vux.confirm.prompt(<span class="string">'123'</span>, &#123;</span><br><span class="line">    title: <span class="string">'Title'</span>,</span><br><span class="line">    onShow () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promt show'</span>)</span><br><span class="line">      _this.$vux.confirm.setInputValue(<span class="string">'set input value'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onHide () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'prompt hide'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onCancel () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'prompt cancel'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onConfirm (msg) &#123;</span><br><span class="line">      alert(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听confirm 作为插件使用的时候的显示隐藏状态</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$vux.confirm.isVisible())</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-inline-loading（行内加载中的动态图标）"><a href="#7-4-inline-loading（行内加载中的动态图标）" class="headerlink" title="7.4 inline-loading（行内加载中的动态图标）"></a>7.4 inline-loading（行内加载中的动态图标）</h3><h4 id="7-4-1-inline-loading组件的功能"><a href="#7-4-1-inline-loading组件的功能" class="headerlink" title="7.4.1 inline-loading组件的功能"></a>7.4.1 inline-loading组件的功能</h4><p>inline-loading组件是一个行列元素，效果是小型的加载中的旋转的动态图标；</p>
<h4 id="7-4-2-inline-loading组件的属性和样式变量"><a href="#7-4-2-inline-loading组件的属性和样式变量" class="headerlink" title="7.4.2 inline-loading组件的属性和样式变量"></a>7.4.2 inline-loading组件的属性和样式变量</h4><p>无</p>
<h4 id="7-4-3-inline-loading组件的注册"><a href="#7-4-3-inline-loading组件的注册" class="headerlink" title="7.4.3 inline-loading组件的注册"></a>7.4.3 inline-loading组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InlineLoading &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    InlineLoading</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; InlineLoading &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'inline-loading'</span>, InlineLoading)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-4-4-inline-loading组件的使用"><a href="#7-4-4-inline-loading组件的使用" class="headerlink" title="7.4.4 inline-loading组件的使用"></a>7.4.4 inline-loading组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">inline-loading</span>&gt;</span><span class="tag">&lt;/<span class="name">inline-loading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"vertical-align:middle;display:inline-block;font-size:14px;"</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span> 加载中</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-load-more（块级加载的图标和文字）"><a href="#7-5-load-more（块级加载的图标和文字）" class="headerlink" title="7.5 load-more（块级加载的图标和文字）"></a>7.5 load-more（块级加载的图标和文字）</h3><h4 id="7-5-1-load-more组件的功能"><a href="#7-5-1-load-more组件的功能" class="headerlink" title="7.5.1 load-more组件的功能"></a>7.5.1 load-more组件的功能</h4><p>load-more 组件是个块级元素，可以设置显示的<code>loading</code>图标以及其中的文字；</p>
<h4 id="7-5-2-load-more组件的属性和样式变量"><a href="#7-5-2-load-more组件的属性和样式变量" class="headerlink" title="7.5.2 load-more组件的属性和样式变量"></a>7.5.2 load-more组件的属性和样式变量</h4><table>
<thead>
<tr>
<th>load-more 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show-loading</td>
<td>boolean</td>
<td>true</td>
<td>是否显示 <code>loading</code> 图标</td>
</tr>
<tr>
<td>tip</td>
<td>string</td>
<td></td>
<td>提示文字，如果没有显示图标也没有显示文字，则显示点</td>
</tr>
</tbody></table>
<h4 id="7-5-3-load-more组件的注册"><a href="#7-5-3-load-more组件的注册" class="headerlink" title="7.5.3 load-more组件的注册"></a>7.5.3 load-more组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; LoadMore &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    LoadMore</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; LoadMore &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'load-more'</span>, LoadMore)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-5-4-load-more组件的使用"><a href="#7-5-4-load-more组件的使用" class="headerlink" title="7.5.4 load-more组件的使用"></a>7.5.4 load-more组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-more</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show-loading</span>=<span class="string">"false"</span>  设置隐藏<span class="attr">loading</span>加载图标，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:tip</span>=<span class="string">"$t('暂无数据')"</span>  设置提示文字，若没有图标也没有显示文字，则显示点</span></span><br><span class="line"><span class="tag">  <span class="attr">background-color</span>=<span class="string">"#fbf9fe"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">load-more</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-6-loading（弹出的遮罩的加载中的大图标）"><a href="#7-6-loading（弹出的遮罩的加载中的大图标）" class="headerlink" title="7.6 loading（弹出的遮罩的加载中的大图标）"></a>7.6 loading（弹出的遮罩的加载中的大图标）</h3><h4 id="7-6-1-loading组件的功能"><a href="#7-6-1-loading组件的功能" class="headerlink" title="7.6.1 loading组件的功能"></a>7.6.1 loading组件的功能</h4><p>loading组件是加载中的大图标，属于弹出的一个遮罩层中的显示；</p>
<h4 id="7-6-2-loading组件的属性、插槽和样式变量"><a href="#7-6-2-loading组件的属性、插槽和样式变量" class="headerlink" title="7.6.2 loading组件的属性、插槽和样式变量"></a>7.6.2 loading组件的属性、插槽和样式变量</h4><table>
<thead>
<tr>
<th>loading 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show</td>
<td>boolean</td>
<td>false</td>
<td>显示状态，在 v2.5.7 前使用<code>v-model</code>绑定，后面直接使用 <code>:show</code> 绑定</td>
</tr>
<tr>
<td>text</td>
<td>string</td>
<td>加载中</td>
<td>提示文字，值为空字符时隐藏提示文字    –</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td>fixed</td>
<td>定位方式，默认为<code>fixed</code>，在<code>100%的布局</code>下用<code>absolute</code>可以避免抖动</td>
</tr>
<tr>
<td>transition</td>
<td>string</td>
<td>vux-mask</td>
<td>显示动画名字</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>loading 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>提示文字区域</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>loading 组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@loading-z-index</td>
<td>5001</td>
<td>z-index</td>
</tr>
</tbody></table>
<h4 id="7-6-3-loading组件的注册-或插件形式"><a href="#7-6-3-loading组件的注册-或插件形式" class="headerlink" title="7.6.3 loading组件的注册(或插件形式)"></a>7.6.3 loading组件的注册(或插件形式)</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Loading</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'loading'</span>, Loading)</span><br></pre></td></tr></table></figure></li>
<li>c.插件形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; LoadingPlugin &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.use(LoadingPlugin)</span><br><span class="line"><span class="comment">// 或者umd方式，引入构建的js文件</span></span><br><span class="line">Vue.use(vuxLoadingPlugin)</span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="keyword">this</span>.$vux.loading.show(&#123;</span><br><span class="line"> text: <span class="string">'Loading'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 隐藏</span></span><br><span class="line"><span class="keyword">this</span>.$vux.loading.hide()</span><br><span class="line"><span class="comment">// 获取显示状态</span></span><br><span class="line"><span class="keyword">this</span>.$vux.loading.isVisible() <span class="comment">// true or false, v2.9.1 版本支持</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-6-4-loading组件的使用"><a href="#7-6-4-loading组件的使用" class="headerlink" title="7.6.4 loading组件的使用"></a>7.6.4 loading组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">loading</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:show</span>=<span class="string">"show"</span>  表示该组件的显示状态，<span class="attr">true</span>则显示</span></span><br><span class="line"><span class="tag">  <span class="attr">:text</span>=<span class="string">"'Loading'"</span>  表示图标中的文字</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以插件的形式调用</span></span><br><span class="line"><span class="keyword">this</span>.$vux.loading.show(&#123;</span><br><span class="line">  text: <span class="string">'Loading'</span>, 表示图标中的文字</span><br><span class="line">  delay: <span class="number">1e3</span>,  表示延时<span class="number">1</span>S显示</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$vux.loading.hide()  表示关闭该图标</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-7-msg（提示操作的信息大图标）"><a href="#7-7-msg（提示操作的信息大图标）" class="headerlink" title="7.7 msg（提示操作的信息大图标）"></a>7.7 msg（提示操作的信息大图标）</h3><h4 id="7-7-1-msg组件的功能"><a href="#7-7-1-msg组件的功能" class="headerlink" title="7.7.1 msg组件的功能"></a>7.7.1 msg组件的功能</h4><h4 id="7-7-2-msg组件的属性和插槽"><a href="#7-7-2-msg组件的属性和插槽" class="headerlink" title="7.7.2 msg组件的属性和插槽"></a>7.7.2 msg组件的属性和插槽</h4><table>
<thead>
<tr>
<th>msg组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td></td>
<td>操作状态提示文字    –</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td></td>
<td>描述文字    –</td>
</tr>
<tr>
<td>icon</td>
<td>string</td>
<td>success</td>
<td>图标类型，可选值有 <code>success, warn, info, waiting</code></td>
</tr>
<tr>
<td>buttons</td>
<td>array</td>
<td></td>
<td>操作按钮列表，一个按钮对象包含<code>text, type</code>(和x-button组件type一致), <code>link, onClick</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>buttons</td>
<td>自定义按钮区域元素</td>
</tr>
<tr>
<td>description</td>
<td>自定义描述文字内容</td>
</tr>
</tbody></table>
<h4 id="7-7-3-msg组件的注册"><a href="#7-7-3-msg组件的注册" class="headerlink" title="7.7.3 msg组件的注册"></a>7.7.3 msg组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Msg &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Msg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Msg &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'msg'</span>, Msg)</span><br></pre></td></tr></table></figure>
<h4 id="7-7-4-msg组件的使用"><a href="#7-7-4-msg组件的使用" class="headerlink" title="7.7.4 msg组件的使用"></a>7.7.4 msg组件的使用</h4><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;msg </span><br><span class="line">  :title<span class="built_in">=</span><span class="string">"'操作成功'"</span>  设置操作msg的标题信息</span><br><span class="line">  :description<span class="built_in">=</span><span class="string">"'操作信息的详细描述...'"</span>  设置操作msg的详细信息</span><br><span class="line">  :buttons<span class="built_in">=</span><span class="string">"buttons"</span>  设置操作按钮列表，一个按钮对象包含`text, <span class="keyword">type</span>`(和x-button组件<span class="keyword">type</span>一致), `link, onClick`</span><br><span class="line">  :icon<span class="built_in">=</span><span class="string">"icon"</span>  设置图标的类型`success, warn, info, waiting`，此处为动态配置</span><br><span class="line">&gt;&lt;/msg&gt;</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeIcon () &#123;</span><br><span class="line">      <span class="built_in">if</span> (!this.icon || this.icon <span class="built_in">=</span><span class="built_in">=</span><span class="built_in">=</span> <span class="string">'success'</span>) &#123;</span><br><span class="line">        this.icon <span class="built_in">=</span> <span class="string">'warn'</span></span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">if</span> (this.icon <span class="built_in">=</span><span class="built_in">=</span><span class="built_in">=</span> <span class="string">'warn'</span>) &#123;</span><br><span class="line">        this.icon <span class="built_in">=</span> <span class="string">'info'</span></span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">if</span> (this.icon <span class="built_in">=</span><span class="built_in">=</span><span class="built_in">=</span> <span class="string">'info'</span>) &#123;</span><br><span class="line">        this.icon <span class="built_in">=</span> <span class="string">'waiting'</span></span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">if</span> (this.icon <span class="built_in">=</span><span class="built_in">=</span><span class="built_in">=</span> <span class="string">'waiting'</span>) &#123;</span><br><span class="line">        this.icon <span class="built_in">=</span> <span class="string">'success'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      description: <span class="string">'msg description'</span>,</span><br><span class="line">      icon: <span class="string">''</span>,</span><br><span class="line">      buttons: [&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'primary'</span>,</span><br><span class="line">        text: <span class="string">'Primary button'</span>,</span><br><span class="line">        onClick: this.changeIcon.bind(this)</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'default'</span>,</span><br><span class="line">        text: <span class="string">'Secondary button'</span>,</span><br><span class="line">        link: <span class="string">'/demo'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-8-popup（弹出框组件，组件内部可以是其他组件，例如group…）"><a href="#7-8-popup（弹出框组件，组件内部可以是其他组件，例如group…）" class="headerlink" title="7.8 popup（弹出框组件，组件内部可以是其他组件，例如group…）"></a>7.8 popup（弹出框组件，组件内部可以是其他组件，例如group…）</h3><h4 id="7-8-1-popup组件的功能"><a href="#7-8-1-popup组件的功能" class="headerlink" title="7.8.1 popup组件的功能"></a>7.8.1 popup组件的功能</h4><p>弹出框组件，组件内部可以是其他组件，例如 group…</p>
<h4 id="7-8-2-popup组件的属性、事件、插槽和样式变量"><a href="#7-8-2-popup组件的属性、事件、插槽和样式变量" class="headerlink" title="7.8.2 popup组件的属性、事件、插槽和样式变量"></a>7.8.2 popup组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>popup组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td></td>
<td>是否关闭，使用v-model绑定    –</td>
</tr>
<tr>
<td>height</td>
<td>string</td>
<td>auto</td>
<td>高度，设置100%为整屏高度。当 position 为 top 或者 bottom 时有效。    –</td>
</tr>
<tr>
<td>hide-on-blur</td>
<td>boolean</td>
<td>true</td>
<td>点击遮罩时是否自动关闭    –</td>
</tr>
<tr>
<td>is-transparent</td>
<td>boolean</td>
<td>false</td>
<td>是否为透明背景    v2.1.1-rc.9</td>
</tr>
<tr>
<td>width</td>
<td>string</td>
<td>auto</td>
<td>设置 100% 宽度必须使用该属性。在 position 为 left 或者 right 时有效。    v2.2.1-rc.6</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td>bottom</td>
<td>位置，可取值 [‘left’, ‘right’, ‘top’, ‘bottom’]    v2.2.1-rc.6</td>
</tr>
<tr>
<td>show-mask</td>
<td>boolean</td>
<td>true</td>
<td>是否显示遮罩    v2.2.1-rc.6</td>
</tr>
<tr>
<td>popup-style</td>
<td>object</td>
<td></td>
<td>弹窗样式，可以用于强制指定 z-index    v2.5.2</td>
</tr>
<tr>
<td>hide-on-deactivated</td>
<td>boolean</td>
<td>true</td>
<td>是否在 deactived 事件触发时自动关闭，避免在路由切换时依然显示弹窗    v2.5.5</td>
</tr>
<tr>
<td>should-rerender-on-show</td>
<td>boolean</td>
<td>false</td>
<td>是否在显示时重新渲染内容区域(以及滚动到顶部)，适用于每次显示弹窗需要重新获取数据初始化的场景    v2.9.0</td>
</tr>
<tr>
<td>should-scroll-top-on-show</td>
<td>boolean</td>
<td>false</td>
<td>是否在显示时自动滚动到顶部，当你自定义滚动容器时需要手动为该容器加上类名 vux-scrollable    v2.9.0</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-hide</td>
<td>–</td>
<td>关闭时触发    –</td>
</tr>
<tr>
<td>@on-show</td>
<td>–</td>
<td>显示时触发    –</td>
</tr>
<tr>
<td>@on-first-show</td>
<td>–</td>
<td>第一次显示时触发，可以在该事件回调里初始化数据或者界面</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>弹窗主体内容</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@popup-picker-header-text-color</td>
<td>#04BE02</td>
<td>–    @theme-color</td>
</tr>
<tr>
<td>@popup-picker-header-bg-color</td>
<td>#fbf9fe</td>
<td>–</td>
</tr>
<tr>
<td>@popup-picker-header-font-size</td>
<td>16px</td>
<td>–</td>
</tr>
<tr>
<td>@popup-picker-header-cancel-text-color</td>
<td>#828282</td>
<td>–</td>
</tr>
<tr>
<td>@popup-background-color</td>
<td>#eee</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-height</td>
<td>44px</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-bg-color</td>
<td>#fbf9</td>
<td>fe    –</td>
</tr>
<tr>
<td>@popup-header-font-size</td>
<td>16px</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-left-text-color</td>
<td>#828282</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-right-text-color</td>
<td>#04BE02</td>
<td>–    @theme-color</td>
</tr>
<tr>
<td>@popup-header-title-text-color</td>
<td>#222</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-left-text-padding</td>
<td>15px</td>
<td>–</td>
</tr>
<tr>
<td>@popup-header-right-text-padding</td>
<td>15px</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="7-8-3-popup组件的注册"><a href="#7-8-3-popup组件的注册" class="headerlink" title="7.8.3 popup组件的注册"></a>7.8.3 popup组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Popup &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Popup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Popup &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'popup'</span>, Popup)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-8-4-popup组件的使用"><a href="#7-8-4-popup组件的使用" class="headerlink" title="7.8.4 popup组件的使用"></a>7.8.4 popup组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">popup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"show"</span>  是否关闭，使用<span class="attr">v-model</span>绑定</span></span><br><span class="line"><span class="tag">    <span class="attr">position</span>=<span class="string">"left"</span>  设置出现位置，默认<span class="attr">bottom</span>， 可取值 ['<span class="attr">left</span>', '<span class="attr">right</span>', '<span class="attr">top</span>', '<span class="attr">bottom</span>']</span></span><br><span class="line"><span class="tag">    <span class="attr">max-height</span>=<span class="string">"50%"</span>  设置最大的高度</span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">"100%"</span>  高度，设置<span class="attr">100</span>%为整屏高度。当 <span class="attr">position</span> 为 <span class="attr">top</span> 或者 <span class="attr">bottom</span> 时有效</span></span><br><span class="line"><span class="tag">    <span class="attr">:hide-on-blur</span>=<span class="string">false</span>  点击遮罩时是否自动关闭，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">    <span class="attr">is-transparent</span>  设置为透明背景，默认<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:show-mask</span>=<span class="string">"false"</span>  设置不显示遮罩，默认<span class="attr">true</span></span></span><br><span class="line"><span class="tag">    <span class="attr">should-scroll-top-on-show</span>  设置在显示时自动滚动到顶部，默认为<span class="attr">false</span>，当你自定义滚动容器时需要手动为该容器加上类名 <span class="attr">vux-scrollable</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">on-hide</span>=<span class="string">"log('hide')"</span>  关闭时触发</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-show</span>=<span class="string">"log('show')"</span>  显示时触发</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"popup"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">title</span>=<span class="string">"Another XSwitcher"</span> <span class="attr">v-model</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-switch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">title</span>=<span class="string">"Show Toast"</span> <span class="attr">v-model</span>=<span class="string">"showToast"</span>&gt;</span><span class="tag">&lt;/<span class="name">x-switch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">popup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-9-popup-header（作为popupd的头部，可以直接使用，也可以在popup组件中作为内容使用）"><a href="#7-9-popup-header（作为popupd的头部，可以直接使用，也可以在popup组件中作为内容使用）" class="headerlink" title="7.9 popup-header（作为popupd的头部，可以直接使用，也可以在popup组件中作为内容使用）"></a>7.9 popup-header（作为popupd的头部，可以直接使用，也可以在popup组件中作为内容使用）</h3><h4 id="7-9-1-popup-header组件的功能"><a href="#7-9-1-popup-header组件的功能" class="headerlink" title="7.9.1 popup-header组件的功能"></a>7.9.1 popup-header组件的功能</h4><p>作为popupd的头部，可以直接使用，也可以在popup组件中作为内容使用</p>
<h4 id="7-9-2-popup-header组件的属性、事件、插槽和样式变量"><a href="#7-9-2-popup-header组件的属性、事件、插槽和样式变量" class="headerlink" title="7.9.2 popup-header组件的属性、事件、插槽和样式变量"></a>7.9.2 popup-header组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>popup-header组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>left-text    string        左侧文字    v2.5.2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>right-text    string        右侧文字    v2.5.2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>title    string        标题    v2.5.2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>show-bottom-border    string        是否显示底部边框    v2.5.2</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popup-header组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-click-left    –    左侧文字点击时触发    v2.5.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@on-click-right    –    右侧文字点击时触发    v2.5.2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="7-9-3-popup-header组件的注册"><a href="#7-9-3-popup-header组件的注册" class="headerlink" title="7.9.3 popup-header组件的注册"></a>7.9.3 popup-header组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PopupHeader &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    PopupHeader</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; PopupHeader &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'popup-header'</span>, PopupHeader)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-9-4-popup-header组件的使用"><a href="#7-9-4-popup-header组件的使用" class="headerlink" title="7.9.4 popup-header组件的使用"></a>7.9.4 popup-header组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">单独使用</span><br><span class="line"><span class="tag">&lt;<span class="name">popup-header</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:left-text</span>=<span class="string">"$t('cancel')"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:right-text</span>=<span class="string">"$t('done')"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">"$t('Please select your card')"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">popup-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">可以在popup组件中作为内容使用</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">popup</span> <span class="attr">v-model</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- group already has a top border, so we need to hide header's bottom border--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">popup-header</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:left-text</span>=<span class="string">"$t('cancel')"</span>  设置左侧文字</span></span><br><span class="line"><span class="tag">          <span class="attr">:right-text</span>=<span class="string">"$t('done')"</span>  设置右侧文字</span></span><br><span class="line"><span class="tag">          <span class="attr">:title</span>=<span class="string">"$t('Please select your card')"</span>  设置标题文字信息</span></span><br><span class="line"><span class="tag">          <span class="attr">:show-bottom-border</span>=<span class="string">"false"</span>  设置隐藏底部边框</span></span><br><span class="line"><span class="tag">          @<span class="attr">on-click-left</span>=<span class="string">"show1 = false"</span>  左侧文字点击时触发</span></span><br><span class="line"><span class="tag">          @<span class="attr">on-click-right</span>=<span class="string">"show1 = false"</span>  右侧文字点击时触发</span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">popup-header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">group</span> <span class="attr">gutter</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">radio</span> <span class="attr">:options</span>=<span class="string">"[$t('Card 1'), $t('Card 2'), $t('Card 3'), $t('Card 4')]"</span>&gt;</span><span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">popup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-10-popover-弹出一个上下左右位置的弹窗"><a href="#7-10-popover-弹出一个上下左右位置的弹窗" class="headerlink" title="7.10 popover (弹出一个上下左右位置的弹窗)"></a>7.10 popover (弹出一个上下左右位置的弹窗)</h3><h4 id="7-10-1-popover组件的功能"><a href="#7-10-1-popover组件的功能" class="headerlink" title="7.10.1 popover组件的功能"></a>7.10.1 popover组件的功能</h4><p>弹出一个上下左右位置的弹窗内容，提示框不会自动消失，再次点击时消失；</p>
<h4 id="7-10-2-popover组件的属性、事件、插槽和样式变量"><a href="#7-10-2-popover组件的属性、事件、插槽和样式变量" class="headerlink" title="7.10.2 popover组件的属性、事件、插槽和样式变量"></a>7.10.2 popover组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>popover组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>content</td>
<td>string</td>
<td></td>
<td>弹出窗口内容    –</td>
</tr>
<tr>
<td>placement</td>
<td>string</td>
<td></td>
<td>弹出窗口位置    –</td>
</tr>
<tr>
<td>gutter</td>
<td>number</td>
<td>5</td>
<td>箭头和触发元素之间的距离    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popover组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗显示时触发    –</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗隐藏时触发    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popover组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>触发元素    –</td>
</tr>
<tr>
<td>content</td>
<td>弹窗内容    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>popover组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@popover-bg-color</td>
<td>#35495e</td>
<td>–</td>
</tr>
<tr>
<td>@popover-font-color</td>
<td>#fff</td>
<td>–</td>
</tr>
<tr>
<td>@popover-border-radius</td>
<td>3px</td>
<td>–</td>
</tr>
<tr>
<td>@popover-border-width</td>
<td>5px</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="7-10-3-popover组件的注册"><a href="#7-10-3-popover组件的注册" class="headerlink" title="7.10.3 popover组件的注册"></a>7.10.3 popover组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Popover &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Popover</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Popover &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'popover'</span>, Popover)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-10-4-popover组件的使用"><a href="#7-10-4-popover组件的使用" class="headerlink" title="7.10.4 popover组件的使用"></a>7.10.4 popover组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">popover</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placement</span>=<span class="string">"top"</span>  弹出窗口位置，可选值 <span class="attr">top</span> <span class="attr">bottom</span> <span class="attr">left</span> <span class="attr">right</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"margin: 20px;"</span>  设置<span class="attr">Style</span>样式</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-show</span>=<span class="string">"onShow"</span>  弹窗显示时触发</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-hide</span>=<span class="string">"onHide"</span>  弹窗隐藏时触发</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"content"</span>  内容插槽，设置弹窗内容</span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"popover-demo-content"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    hello world</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>&#123;&#123; $t('Popover on top') &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">popover</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-11-spinner（安卓的行内的加载图标）"><a href="#7-11-spinner（安卓的行内的加载图标）" class="headerlink" title="7.11 spinner（安卓的行内的加载图标）"></a>7.11 spinner（安卓的行内的加载图标）</h3><h4 id="7-11-1-spinner组件的功能"><a href="#7-11-1-spinner组件的功能" class="headerlink" title="7.11.1 spinner组件的功能"></a>7.11.1 spinner组件的功能</h4><p>spinner组件用于显示安卓的行内的加载图标的使用；</p>
<h4 id="7-11-2-spinner组件的属性和样式变量"><a href="#7-11-2-spinner组件的属性和样式变量" class="headerlink" title="7.11.2 spinner组件的属性和样式变量"></a>7.11.2 spinner组件的属性和样式变量</h4><table>
<thead>
<tr>
<th>组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>string</td>
<td>ios</td>
<td>图标类型，有<code>[&#39;android&#39;, &#39;ios&#39;, &#39;ios-small&#39;, &#39;bubbles&#39;, &#39;circles&#39;, &#39;crescent&#39;, &#39;dots&#39;, &#39;lines&#39;, &#39;ripple&#39;, &#39;spiral&#39;]</code>类型；</td>
</tr>
</tbody></table>
<h4 id="7-11-3-spinner组件的注册"><a href="#7-11-3-spinner组件的注册" class="headerlink" title="7.11.3 spinner组件的注册"></a>7.11.3 spinner组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Spinner &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Spinner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Spinner &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'spinner'</span>, Spinner)</span><br></pre></td></tr></table></figure>
<h4 id="7-11-4-spinner组件的使用"><a href="#7-11-4-spinner组件的使用" class="headerlink" title="7.11.4 spinner组件的使用"></a>7.11.4 spinner组件的使用</h4><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;group&gt;</span><br><span class="line">      &lt;cell v-for<span class="built_in">=</span><span class="string">"(type, index) in types"</span> :title<span class="built_in">=</span><span class="string">"type"</span> :key<span class="built_in">=</span><span class="string">"type"</span> :<span class="meta">inline</span>-desc<span class="built_in">=</span><span class="string">"index === 3 ? 'size=40px' : ''"</span>&gt;</span><br><span class="line">        &lt;spinner :<span class="keyword">type</span><span class="built_in">=</span><span class="string">"type"</span> :size<span class="built_in">=</span><span class="string">"index === 3 ? '40px' : ''"</span>&gt;&lt;/spinner&gt;</span><br><span class="line">      &lt;/cell&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Spinner, Group, Cell &#125; from <span class="string">'vux'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Spinner,</span><br><span class="line">    Cell,</span><br><span class="line">    Group</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      types: [<span class="string">'android'</span>, <span class="string">'ios'</span>, <span class="string">'ios-small'</span>, <span class="string">'bubbles'</span>, <span class="string">'circles'</span>, <span class="string">'crescent'</span>, <span class="string">'dots'</span>, <span class="string">'lines'</span>, <span class="string">'ripple'</span>, <span class="string">'spiral'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-12-toast-弹出一个文字的提示框，用于请求报错信息显示等"><a href="#7-12-toast-弹出一个文字的提示框，用于请求报错信息显示等" class="headerlink" title="7.12 toast(弹出一个文字的提示框，用于请求报错信息显示等)"></a>7.12 toast(弹出一个文字的提示框，用于请求报错信息显示等)</h3><h4 id="7-12-1-toast组件的功能"><a href="#7-12-1-toast组件的功能" class="headerlink" title="7.12.1 toast组件的功能"></a>7.12.1 toast组件的功能</h4><p>toast组件用于弹出提示框信息的文字内容，例如请求出错的错误信息，请求成功的信息等提示；</p>
<h4 id="7-12-2-toast组件的属性、事件、插槽和样式变量"><a href="#7-12-2-toast组件的属性、事件、插槽和样式变量" class="headerlink" title="7.12.2 toast组件的属性、事件、插槽和样式变量"></a>7.12.2 toast组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>toast组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>boolean</td>
<td>false</td>
<td>是否显示, 使用 <code>v-model</code>绑定</td>
</tr>
<tr>
<td>time</td>
<td>number</td>
<td>2000</td>
<td>显示时间</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>success</td>
<td>类型，可选值 <code>success, warn, cancel, text</code></td>
</tr>
<tr>
<td>width</td>
<td>string</td>
<td>7.6em</td>
<td>宽度</td>
</tr>
<tr>
<td>is-show-mask</td>
<td>boolean</td>
<td>false</td>
<td>是否显示遮罩，如果显示，用户将不能点击页面上其他元素</td>
</tr>
<tr>
<td>text</td>
<td>string</td>
<td></td>
<td>提示内容，支持 html，和默认slot同样功能</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td>default</td>
<td>显示位置，可选值 <code>default, top, middle, bottom</code></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>toast组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-show</td>
<td>–</td>
<td>提示弹出时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>提示隐藏时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>toast 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>默认slot, 提示内容</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>toast 组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@toast-content-font-size</td>
<td>16px</td>
<td>内容文本颜色</td>
</tr>
<tr>
<td>@toast-top</td>
<td>180px</td>
<td>默认状态下距离顶部的高度</td>
</tr>
<tr>
<td>@toast-position-top-offset</td>
<td>10px</td>
<td>顶部显示的高度</td>
</tr>
<tr>
<td>@toast-position-bottom-offset</td>
<td>10px</td>
<td>底部显示的高度</td>
</tr>
<tr>
<td>@toast-z-index</td>
<td>5001</td>
<td>z-index</td>
</tr>
</tbody></table>
<h4 id="7-12-3-toast组件的注册（插件形式）"><a href="#7-12-3-toast组件的注册（插件形式）" class="headerlink" title="7.12.3 toast组件的注册（插件形式）"></a>7.12.3 toast组件的注册（插件形式）</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Toast</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'toast'</span>, Toast)</span><br></pre></td></tr></table></figure></li>
<li>c. 插件形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; ToastPlugin &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.use(ToastPlugin)</span><br><span class="line"><span class="comment">// 或者umd方式，引入构建的js文件</span></span><br><span class="line">Vue.use(vuxToastPlugin)</span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line">Vue.use(ToastPlugin, &#123;<span class="attr">position</span>: <span class="string">'top'</span>&#125;)</span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="keyword">this</span>.$vux.toast.show(&#123;</span><br><span class="line"> text: <span class="string">'Loading'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 显示文字</span></span><br><span class="line"><span class="keyword">this</span>.$vux.toast.text(<span class="string">'hello'</span>, <span class="string">'top'</span>)</span><br><span class="line"><span class="comment">// 隐藏</span></span><br><span class="line"><span class="keyword">this</span>.$vux.toast.hide()</span><br><span class="line"><span class="comment">// 获取显示状态</span></span><br><span class="line"><span class="keyword">this</span>.$vux.toast.isVisible() <span class="comment">// v2.9.1 开始支持</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7-12-4-toast组件的使用（插件形式使用）"><a href="#7-12-4-toast组件的使用（插件形式使用）" class="headerlink" title="7.12.4 toast组件的使用（插件形式使用）"></a>7.12.4 toast组件的使用（插件形式使用）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">toast</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"show"</span>  使用<span class="attr">v-model</span>数据绑定显示与隐藏弹出框信息</span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span>  设置弹出框的类型为文本类型，可选值 `<span class="attr">success</span>, <span class="attr">warn</span>, <span class="attr">cancel</span>, <span class="attr">text</span>`</span></span><br><span class="line"><span class="tag">  <span class="attr">:time</span>=<span class="string">"800"</span>  设置弹出框显示的时间长短（毫秒）</span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">"20em"</span>  设置弹出的信息框的长度，默认为<span class="attr">7em</span></span></span><br><span class="line"><span class="tag">  <span class="attr">is-show-mask</span>  设置显示遮罩，显示后无法点击屏幕其他元素，默认值是<span class="attr">false</span>，</span></span><br><span class="line"><span class="tag">  <span class="attr">text</span>=<span class="string">"Hello World"</span>  设置弹出框的文字信息，支持<span class="attr">html</span>，同时可以在插槽中填写</span></span><br><span class="line"><span class="tag">  <span class="attr">:position</span>=<span class="string">"position"</span> 设置显示位置，变量值可选`<span class="attr">default</span>, <span class="attr">top</span>, <span class="attr">middle</span>, <span class="attr">bottom</span>`</span></span><br><span class="line"><span class="tag">&gt;</span>基本使用<span class="tag">&lt;/<span class="name">toast</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$vux.toast.show(&#123;</span><br><span class="line">  text: <span class="string">'Hello World'</span>,</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m showing'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin: I\'m hiding'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$vux.toast.hide()  表示关闭该提示框</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-13-x-dialog-弹出对话框，可以在内部加入其他元素"><a href="#7-13-x-dialog-弹出对话框，可以在内部加入其他元素" class="headerlink" title="7.13 x-dialog(弹出对话框，可以在内部加入其他元素)"></a>7.13 x-dialog(弹出对话框，可以在内部加入其他元素)</h3><h4 id="7-13-1-x-dialog组件的功能"><a href="#7-13-1-x-dialog组件的功能" class="headerlink" title="7.13.1 x-dialog组件的功能"></a>7.13.1 x-dialog组件的功能</h4><p>x-dialog 组件弹出对话框，可以在内部加入其他元素，例如加入图片信息、toast组件…;</p>
<p><strong>注意：</strong> 如果当前组件某一父级使用了 <code>ViewBox</code> 组件或者直接使用了 <code>Safari</code> 的<code>overflowScrolling:touch</code>，请引入指令 <code>transfer-dom</code> 以解决其带来的 <code>z-index</code> 失效问题。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;div v-transfer-dom&gt;</span><br><span class="line">  &lt;x-dialog&gt;&lt;/x-dialog&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">import &#123; TransferDomDirective as TransferDom &#125; from <span class="string">'vux'</span></span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    TransferDom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-13-2-x-dialog组件的属性、事件、插槽和样式变量"><a href="#7-13-2-x-dialog组件的属性、事件、插槽和样式变量" class="headerlink" title="7.13.2 x-dialog组件的属性、事件、插槽和样式变量"></a>7.13.2 x-dialog组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>x-dialog组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show</td>
<td>boolean</td>
<td>false</td>
<td>弹窗是否可见，使用 <code>v-model</code> 绑定，在 v2.5.3 之后版本支持<code>.sync</code>修饰符</td>
</tr>
<tr>
<td>mask-transition</td>
<td>string</td>
<td>vux-mask</td>
<td>遮罩层动画</td>
</tr>
<tr>
<td>dialog-transition</td>
<td>string</td>
<td>vux-dialog</td>
<td>弹窗动画</td>
</tr>
<tr>
<td>hide-on-blur</td>
<td>boolean</td>
<td>false</td>
<td>是否在点击遮罩时自动关闭弹窗</td>
</tr>
<tr>
<td>scroll</td>
<td>boolean</td>
<td>true</td>
<td><code>【废弃】</code>是否在弹窗上滚动时 <code>body</code> 内容也滚动</td>
</tr>
<tr>
<td>dialog-style</td>
<td>object</td>
<td></td>
<td>设置内部弹窗样式，覆盖原有的宽度、背景颜色等样式</td>
</tr>
<tr>
<td>mask-z-index</td>
<td>number string</td>
<td>1000</td>
<td>遮罩层 <code>z-index</code> 值</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-dialog组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-show</td>
<td>–</td>
<td>弹窗可见时触发</td>
</tr>
<tr>
<td>@on-hide</td>
<td>–</td>
<td>弹窗关闭时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-dialog组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>弹窗的主体内容</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-dialog组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@dialog-button-text-primary-color</td>
<td>草绿色#0BB20C</td>
<td>–</td>
</tr>
<tr>
<td>@dialog-button-text-default-color</td>
<td>灰黑色#353535</td>
<td>–</td>
</tr>
<tr>
<td>@dialog-button-text-warn-color</td>
<td>橙红色#E64340</td>
<td>–</td>
</tr>
<tr>
<td>@dialog-width</td>
<td>80%</td>
<td>内容占据屏幕80%宽带度</td>
</tr>
<tr>
<td>@dialog-max-width</td>
<td>300px</td>
<td>内容最宽为300px</td>
</tr>
<tr>
<td>@dialog-gap-width</td>
<td>1.6em</td>
<td>标题及内容区域的 <code>padding-left</code> 和 <code>padding-right</code></td>
</tr>
<tr>
<td>@dialog-mask-background</td>
<td>rgba(0, 0, 0, .6)</td>
<td>遮罩为0.6透明的黑色层</td>
</tr>
</tbody></table>
<h4 id="7-13-3-x-dialog组件的注册"><a href="#7-13-3-x-dialog组件的注册" class="headerlink" title="7.13.3 x-dialog组件的注册"></a>7.13.3 x-dialog组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XDialog &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XDialog</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XDialog &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-dialog'</span>, XDialog)</span><br></pre></td></tr></table></figure>
<h4 id="7-13-4-x-dialog组件的使用"><a href="#7-13-4-x-dialog组件的使用" class="headerlink" title="7.13.4 x-dialog组件的使用"></a>7.13.4 x-dialog组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-transfer-dom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-dialog</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"show"</span>  弹窗是否可见，使用 `<span class="attr">v-model</span>` 绑定，值为<span class="attr">true</span>显示</span></span><br><span class="line"><span class="tag">    <span class="attr">:show.sync</span>=<span class="string">"show2"</span>  弹窗是否可见，支持`<span class="attr">.sync</span>`修饰符，值为<span class="attr">true</span>显示</span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"dialog-demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hide-on-blur</span>  设置点击遮罩时自动关闭弹窗，默认不关闭，值为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:dialog-style</span>=<span class="string">"&#123;'max-width': '100%', width: '100%', height: '50%', 'background-color': 'transparent'&#125;  自定义设置内部弹窗样式，覆盖原有的宽度、背景颜色等样式</span></span></span><br><span class="line"><span class="tag"><span class="string">  &gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">    &lt;div style="</span><span class="attr">padding:15px</span>;"&gt;</span>  对话框内部可以设置其他的元素组件</span><br><span class="line">      <span class="tag">&lt;<span class="name">x-button</span> @<span class="attr">click.native</span>=<span class="string">"doShowToast"</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>show toast<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"show=false"</span>&gt;</span>  弹出对话框中的点击关闭的div</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"vux-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">x-dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-导航组件"><a href="#8-导航组件" class="headerlink" title="8. 导航组件"></a>8. 导航组件</h2><h3 id="8-1-button-tab-button-tab-item-导航菜单，颜色背景形式"><a href="#8-1-button-tab-button-tab-item-导航菜单，颜色背景形式" class="headerlink" title="8.1 button-tab/ button-tab-item (导航菜单，颜色背景形式)"></a>8.1 button-tab/ button-tab-item (导航菜单，颜色背景形式)</h3><h4 id="8-1-1-button-tab-button-tab-item组件的功能"><a href="#8-1-1-button-tab-button-tab-item组件的功能" class="headerlink" title="8.1.1 button-tab/ button-tab-item组件的功能"></a>8.1.1 button-tab/ button-tab-item组件的功能</h4><p>button-tab/ button-tab-item 组件用于构建导航菜单的功能，选项类似于按钮的类型；</p>
<h4 id="8-1-2-button-tab-button-tab-item组件的属性、事件、插槽和样式变量"><a href="#8-1-2-button-tab-button-tab-item组件的属性、事件、插槽和样式变量" class="headerlink" title="8.1.2 button-tab/ button-tab-item组件的属性、事件、插槽和样式变量"></a>8.1.2 button-tab/ button-tab-item组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>button-tab 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>number</td>
<td>0</td>
<td>当前选中索引值，从0开始，使用 <code>v-model</code>绑定</td>
</tr>
<tr>
<td>height</td>
<td>number</td>
<td>30</td>
<td>高度值, 单位为像素</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>button-tab-item 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>selected</td>
<td>boolean</td>
<td>false</td>
<td>是否选中</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>button-tab-item 组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-item-click</td>
<td>(index)</td>
<td>当前按钮点击时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>button-tab-item 组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@button-tab-border-width</td>
<td>1px</td>
<td>未被使用</td>
</tr>
<tr>
<td>@button-tab-border-radius</td>
<td>16px</td>
<td>圆角边框的半径</td>
</tr>
<tr>
<td>@button-tab-border-color</td>
<td>#04BE02</td>
<td>边框的颜色，继承于    @theme-color</td>
</tr>
<tr>
<td>@button-tab-default-border-color</td>
<td>#04BE02</td>
<td>默认状态下圆角边框的颜色，继承于    @button-tab-border-color</td>
</tr>
<tr>
<td>@button-tab-active-border-color</td>
<td>#04BE02</td>
<td>未被使用    ，继承于@button-tab-border-color</td>
</tr>
<tr>
<td>@button-tab-default-background-color</td>
<td>#fdfdfd</td>
<td>默认状态下的背景颜色</td>
</tr>
<tr>
<td>@button-tab-active-background-color</td>
<td>#04BE02</td>
<td>选中状态下的背景颜色    ，继承于@theme-color</td>
</tr>
<tr>
<td>@button-tab-active-font-color</td>
<td>#FFF</td>
<td>未被使用</td>
</tr>
<tr>
<td>@button-tab-active-text-color</td>
<td>#FFF</td>
<td>未被使用    ，继承于@button-tab-active-font-color</td>
</tr>
<tr>
<td>@button-tab-default-text-color</td>
<td>#999</td>
<td>默认状态下的文本颜色</td>
</tr>
<tr>
<td>@button-tab-height</td>
<td>30px</td>
<td>元素高度</td>
</tr>
<tr>
<td>@button-tab-line-height</td>
<td>31px</td>
<td>元素行高</td>
</tr>
</tbody></table>
<h4 id="8-1-3-button-tab-button-tab-item组件的注册"><a href="#8-1-3-button-tab-button-tab-item组件的注册" class="headerlink" title="8.1.3 button-tab/ button-tab-item组件的注册"></a>8.1.3 button-tab/ button-tab-item组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ButtonTab, ButtonTabItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ButtonTab,</span><br><span class="line">    ButtonTabItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ButtonTab, ButtonTabItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'button-tab'</span>, ButtonTab)</span><br><span class="line">Vue.component(<span class="string">'button-tab-item'</span>, ButtonTabItem)</span><br></pre></td></tr></table></figure>
<h4 id="8-1-4-button-tab-button-tab-item组件的使用"><a href="#8-1-4-button-tab-button-tab-item组件的使用" class="headerlink" title="8.1.4 button-tab/ button-tab-item组件的使用"></a>8.1.4 button-tab/ button-tab-item组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-tab-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">selected</span>  设置默认选中状态，不设置则默认是第<span class="attr">0</span>个选中</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-item-click</span>=<span class="string">"consoleIndex()"</span>  点击该按钮时触发事件</span></span><br><span class="line"><span class="tag">  &gt;</span>所有消息<span class="tag">&lt;/<span class="name">button-tab-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-tab-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"vux-reddot-s"</span>&gt;</span>新消息<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  vux-reddot-s 是一个红点的类</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button-tab-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button-tab</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="8-2-未-drawer"><a href="#8-2-未-drawer" class="headerlink" title="8.2 (未)drawer"></a>8.2 (未)drawer</h3><h3 id="8-3-tab-tab-item-tab项的导航栏的设计"><a href="#8-3-tab-tab-item-tab项的导航栏的设计" class="headerlink" title="8.3 tab/ tab-item (tab项的导航栏的设计)"></a>8.3 tab/ tab-item (tab项的导航栏的设计)</h3><h4 id="8-3-1-tab-tab-item-组件的功能"><a href="#8-3-1-tab-tab-item-组件的功能" class="headerlink" title="8.3.1 tab/ tab-item 组件的功能"></a>8.3.1 tab/ tab-item 组件的功能</h4><p>tab/ tab-item 组件用于构建导航菜单的功能，可以设置tab项的上方或下方的线条；</p>
<h4 id="8-3-2-tab-tab-item-组件的属性、事件和样式变量"><a href="#8-3-2-tab-tab-item-组件的属性、事件和样式变量" class="headerlink" title="8.3.2 tab/ tab-item 组件的属性、事件和样式变量"></a>8.3.2 tab/ tab-item 组件的属性、事件和样式变量</h4><table>
<thead>
<tr>
<th>tab 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>line-width</td>
<td>number</td>
<td>3</td>
<td>线条宽度</td>
</tr>
<tr>
<td>active-color</td>
<td>string</td>
<td></td>
<td>选中时文字颜色</td>
</tr>
<tr>
<td>default-color</td>
<td>string</td>
<td></td>
<td>默认文字颜色</td>
</tr>
<tr>
<td>disabled-color</td>
<td>string</td>
<td></td>
<td>不可点击时文字颜色</td>
</tr>
<tr>
<td>bar-active-color</td>
<td>string</td>
<td></td>
<td>设置底部bar颜色，该颜色也可以通过less变量<code>@tab-bar-active-color</code>设置。</td>
</tr>
<tr>
<td>animate</td>
<td>boolean</td>
<td>true</td>
<td>切换时是否需要动画    –</td>
</tr>
<tr>
<td>custom-bar-width</td>
<td>string function</td>
<td></td>
<td>设置底部bar宽度，默认宽度是整体tab宽度平分，比如50px。使用函数时参数为当前索引index，你可以定义不同<code>tab-item</code>对应的bar宽度。</td>
</tr>
<tr>
<td>badge-label</td>
<td>string</td>
<td></td>
<td>徽标文字</td>
</tr>
<tr>
<td>badge-background</td>
<td>string</td>
<td></td>
<td>徽标背景颜色</td>
</tr>
<tr>
<td>badge-color</td>
<td>string</td>
<td></td>
<td>徽标文字颜色</td>
</tr>
<tr>
<td>prevent-default</td>
<td>string</td>
<td>false</td>
<td>是否禁止自动切换 <code>tab-item</code></td>
</tr>
<tr>
<td>scroll-threshold</td>
<td>number</td>
<td>4</td>
<td>滚动阀值，超过可滚动</td>
</tr>
<tr>
<td>bar-position</td>
<td>string</td>
<td>bottom</td>
<td>边框位置，可以为 <code>bottom</code> 或者 <code>top</code>。仅支持 animate 为 true 的情况。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>tab-item组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>disabled</td>
<td>boolean</td>
<td>false</td>
<td>是否不可选</td>
</tr>
<tr>
<td>active-class</td>
<td>string</td>
<td></td>
<td>当前项选中时的class</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>tab-item组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-item-click</td>
<td>(index)</td>
<td>当前 <code>tabItem</code> 被点击时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>tab-item组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
<th>继承自变量</th>
</tr>
</thead>
<tbody><tr>
<td>@tab-text-disabled-color</td>
<td>浅灰色#ddd</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>@tab-text-default-color</td>
<td>深灰色#666</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>@tab-text-active-color</td>
<td>草绿色#04BE02</td>
<td>–</td>
<td>@theme-color</td>
</tr>
<tr>
<td>@tab-bar-active-color</td>
<td>草绿色#04BE02</td>
<td>–</td>
<td>@theme-color</td>
</tr>
</tbody></table>
<h4 id="8-3-3-tab-tab-item-组件的注册"><a href="#8-3-3-tab-tab-item-组件的注册" class="headerlink" title="8.3.3 tab/ tab-item 组件的注册"></a>8.3.3 tab/ tab-item 组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Tab, TabItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Tab,</span><br><span class="line">    TabItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Tab, TabItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'tab'</span>, Tab)</span><br><span class="line">Vue.component(<span class="string">'tab-item'</span>, TabItem)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="8-3-4-tab-tab-item-组件的使用"><a href="#8-3-4-tab-tab-item-组件的使用" class="headerlink" title="8.3.4 tab/ tab-item 组件的使用"></a>8.3.4 tab/ tab-item 组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tab</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:line-width</span>=<span class="string">"1"</span>  设置边框的宽度为<span class="attr">1px</span>，默认为<span class="attr">3px</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bar-active-color</span>=<span class="string">"#668599"</span>  设置边框线条的颜色，默认草绿色#<span class="attr">04BE02</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bar-position</span>=<span class="string">"top"</span>  设置边框位置为顶部，默认是`<span class="attr">bottom</span>`</span></span><br><span class="line"><span class="tag">  <span class="attr">prevent-default</span>  设置禁止自动切换 `<span class="attr">tab-item</span>	`</span></span><br><span class="line"><span class="tag">  <span class="attr">:scroll-threshold</span>=<span class="string">"5"</span>  设置滚动阀值为<span class="attr">5</span>个，超过可滚动，默认是<span class="attr">4</span>个</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-before-index-change</span>=<span class="string">"switchTabItem"</span>  设置切换<span class="attr">tab</span>项前触发的事件，可以载入<span class="attr">loading</span>组件</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tab-item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">selected</span>   设置默认选中，或者是使用<span class="attr">v-bind</span>动态绑定选中的<span class="attr">tab</span>项，例如：`<span class="attr">:selected</span>=<span class="string">"index == 2"</span>`</span></span><br><span class="line"><span class="tag">    @<span class="attr">on-item-click</span>=<span class="string">"onItemClick"</span>  当前 `<span class="attr">tabItem</span>` 被点击时触发</span></span><br><span class="line"><span class="tag">    <span class="attr">badge-label</span>=<span class="string">"1"</span>  设置徽标文字</span></span><br><span class="line"><span class="tag">    <span class="attr">badge-background</span>==<span class="string">"#38C972"</span>  设置徽标背景颜色</span></span><br><span class="line"><span class="tag">    <span class="attr">badge-color</span>=<span class="string">"#fff"</span>  设置徽标文字颜色</span></span><br><span class="line"><span class="tag">    <span class="attr">:animate</span>=<span class="string">"false"</span>  设置无切换动画，默认有</span></span><br><span class="line"><span class="tag">    <span class="attr">active-class</span>=<span class="string">"active"</span>  设置当前选中<span class="attr">tab</span>项的<span class="attr">class</span>类</span></span><br><span class="line"><span class="tag">    <span class="attr">disabled</span>  设置该<span class="attr">tab</span>项不可选</span></span><br><span class="line"><span class="tag">  &gt;</span>已发货<span class="tag">&lt;/<span class="name">tab-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tab-item</span> @<span class="attr">on-item-click</span>=<span class="string">"onItemClick"</span>&gt;</span>未发货<span class="tag">&lt;/<span class="name">tab-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tab-item</span> @<span class="attr">on-item-click</span>=<span class="string">"onItemClick"</span>&gt;</span>全部订单<span class="tag">&lt;/<span class="name">tab-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tab</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-Tabbar-TabbarItem（底部导航栏）"><a href="#8-4-Tabbar-TabbarItem（底部导航栏）" class="headerlink" title="8.4 Tabbar/TabbarItem（底部导航栏）"></a>8.4 Tabbar/TabbarItem（底部导航栏）</h3><h4 id="8-4-1-Tabbar-TabbarItem-组件的功能"><a href="#8-4-1-Tabbar-TabbarItem-组件的功能" class="headerlink" title="8.4.1 Tabbar/TabbarItem 组件的功能"></a>8.4.1 Tabbar/TabbarItem 组件的功能</h4><p>位于页面底部的导航栏区域；该组件支持简单模式，即不指定icon，label将垂直居中显示；默认定位为 absolute，适用于 100%页面布局，如果你并非 100% 布局(可以配合使用 view-box 组件)，请手动重置样式为 <code>position: fixed</code>；</p>
<h4 id="8-4-2-tabbar组件的属性、事件、插槽，TabbarItem-组件的属性、事件、插槽和样式变量"><a href="#8-4-2-tabbar组件的属性、事件、插槽，TabbarItem-组件的属性、事件、插槽和样式变量" class="headerlink" title="8.4.2 tabbar组件的属性、事件、插槽，TabbarItem 组件的属性、事件、插槽和样式变量"></a>8.4.2 tabbar组件的属性、事件、插槽，TabbarItem 组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>tabbar组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>icon-class</td>
<td>string</td>
<td></td>
<td>图标的class名    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>tabbar组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-index-change</td>
<td>–</td>
<td>value 值变化时触发    v2.5.4</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>tabbar组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>tabbar主体内容，只允许tabbar-item    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>TabbarItem组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>selected</td>
<td>boolean</td>
<td>false</td>
<td>是否选中当前项，你也可以使用v-model来指定选中的tabbar-item的index    –</td>
</tr>
<tr>
<td>badge</td>
<td>string</td>
<td></td>
<td>徽标文字，不指定则不显示    –</td>
</tr>
<tr>
<td>show-dot</td>
<td>boolean</td>
<td>false</td>
<td>是否显示红点    –</td>
</tr>
<tr>
<td>link</td>
<td>string</td>
<td></td>
<td>链接，可以为普通url或者用vue-link的路径写法，使用 object 写法指定 replace 为 true 可实现 replace 跳转    –</td>
</tr>
<tr>
<td>icon-class</td>
<td>string</td>
<td></td>
<td>图标类名，如果tabbar也同时定义了icon-class, 会使用tabbar-item的    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>TabbarItem组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-item-click</td>
<td>–</td>
<td>点击菜单项时触发    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>TabbarItem组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>icon</td>
<td>图标区域    –</td>
</tr>
<tr>
<td>icon-active</td>
<td>如果存在，当前 tabbar-item 点击时会显示，用于切换图标    v2.1.1-rc.8</td>
</tr>
<tr>
<td>label</td>
<td>图标下方文字    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>TabbarItem组件的样式变量名字</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@tabbar-text-active-color</td>
<td>#09BB07</td>
<td>–</td>
</tr>
<tr>
<td>@tabbar-index</td>
<td>100</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="8-4-3-Tabbar-TabbarItem组件的注册"><a href="#8-4-3-Tabbar-TabbarItem组件的注册" class="headerlink" title="8.4.3 Tabbar/TabbarItem组件的注册"></a>8.4.3 Tabbar/TabbarItem组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport &#123; Tabbar, TabbarItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Tabbar,</span><br><span class="line">    TabbarItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Tabbar, TabbarItem &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'tabbar'</span>, Tabbar)</span><br><span class="line">Vue.component(<span class="string">'tabbar-item'</span>, TabbarItem)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="8-4-4-Tabbar-TabbarItem组件的使用"><a href="#8-4-4-Tabbar-TabbarItem组件的使用" class="headerlink" title="8.4.4 Tabbar/TabbarItem组件的使用"></a>8.4.4 Tabbar/TabbarItem组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tabbar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tabbar-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"../assets/demo/icon_nav_button.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"label"</span>&gt;</span>Wechat<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tabbar-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tabbar-item</span> <span class="attr">show-dot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"../assets/demo/icon_nav_msg.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"label"</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tabbar-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tabbar-item</span> <span class="attr">selected</span> <span class="attr">link</span>=<span class="string">"/component/demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"../assets/demo/icon_nav_article.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"label"</span>&gt;</span>Explore<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tabbar-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tabbar-item</span> <span class="attr">badge</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"../assets/demo/icon_nav_cell.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"label"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tabbar-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tabbar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-x-header-顶部固定栏的组件"><a href="#8-5-x-header-顶部固定栏的组件" class="headerlink" title="8.5 x-header(顶部固定栏的组件)"></a>8.5 x-header(顶部固定栏的组件)</h3><h4 id="8-5-1-x-header组件的功能"><a href="#8-5-1-x-header组件的功能" class="headerlink" title="8.5.1 x-header组件的功能"></a>8.5.1 x-header组件的功能</h4><p>x-header组件用于顶部固定栏的设置，包括了设置回退按钮，标题信息，样式….等；</p>
<h4 id="8-5-2-x-header组件的属性、事件、插槽和样式变量"><a href="#8-5-2-x-header组件的属性、事件、插槽和样式变量" class="headerlink" title="8.5.2 x-header组件的属性、事件、插槽和样式变量"></a>8.5.2 x-header组件的属性、事件、插槽和样式变量</h4><table>
<thead>
<tr>
<th>x-header 组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>left-options.showBack</td>
<td>boolean</td>
<td>true</td>
<td>是否显示返回文字</td>
</tr>
<tr>
<td>left-options.backText</td>
<td>string</td>
<td>Back</td>
<td>返回文字</td>
</tr>
<tr>
<td>left-options.preventGoBack</td>
<td>boolean</td>
<td>false</td>
<td>是否阻止返回</td>
</tr>
<tr>
<td>title</td>
<td>string</td>
<td></td>
<td>标题</td>
</tr>
<tr>
<td>transition</td>
<td>string</td>
<td></td>
<td>标题出现的动画</td>
</tr>
<tr>
<td>right-options.showMore</td>
<td>boolean</td>
<td>false</td>
<td>是否显示右侧的更多图标</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-header 组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-click-more</td>
<td>–</td>
<td>点击右侧更多时触发</td>
</tr>
<tr>
<td>@on-click-back</td>
<td>–</td>
<td>当<code>left-options.preventGoBack为true</code>,点击左边返回时触发</td>
</tr>
<tr>
<td>@on-click-title</td>
<td>–</td>
<td>点击标题时触发</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>x-header 组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>标题</td>
</tr>
<tr>
<td>left</td>
<td>左侧部分插槽，在返回文字后，不会影响到原有的图标</td>
</tr>
<tr>
<td>overwrite-left</td>
<td>重写左侧部分的返回文字及图标</td>
</tr>
<tr>
<td>right</td>
<td>右侧部分插槽</td>
</tr>
<tr>
<td>overwrite-title</td>
<td>标题插槽，用于自定义标题位置内容</td>
</tr>
</tbody></table>
<br>

<p>x-header 组件的样式变量名字 | 默认值<br>— | — | —<br>@header-background-color | 深灰色#35495e<br>@header-title-color | #fff<br>@header-text-color | #ccc<br>@header-arrow-color | #ccc</p>
<h4 id="8-5-3-x-header组件的注册"><a href="#8-5-3-x-header组件的注册" class="headerlink" title="8.5.3 x-header组件的注册"></a>8.5.3 x-header组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; XHeader &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    XHeader</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XHeader &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'x-header'</span>, XHeader)</span><br></pre></td></tr></table></figure>
<h4 id="8-5-4-x-header组件的使用"><a href="#8-5-4-x-header组件的使用" class="headerlink" title="8.5.4 x-header组件的使用"></a>8.5.4 x-header组件的使用</h4></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-header</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">"use prop:title"</span>  设置标题文字信息</span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"background-color:#000;"</span>  设置背景颜色，默认深灰色#<span class="attr">35495e</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:left-options</span>=<span class="string">"&#123;showBack: false, backText: ''&#125;"</span>  设置阻止返回按钮/文字显示（默认<span class="attr">true</span>）和返回文字（默认<span class="attr">BACK</span>）</span></span><br><span class="line"><span class="tag">  <span class="attr">:right-options</span>=<span class="string">"&#123;showMore: true&#125;"</span>  设置，显示右侧的更多图默认<span class="attr">false</span>标</span></span><br><span class="line"><span class="tag">  @<span class="attr">on-click-more</span>=<span class="string">"showMenus = true"</span>  点击右侧更多时触发</span></span><br><span class="line"><span class="tag">  <span class="attr">on-click-back</span>	=<span class="string">"goback = true"</span>  当 `<span class="attr">left-options.preventGoBack</span>为<span class="attr">true</span>`,点击左边返回时触发</span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">"right"</span>&gt;</span>Feedback<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  右侧部分插槽</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">"left"</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  左侧部分插槽，在返回文字后，不会影响到原有的图标</span><br><span class="line"><span class="tag">&lt;/<span class="name">x-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>overwrite-left<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-icon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"overwrite-left"</span>  重写左侧部分的返回文字及图标</span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"navicon"</span>  设置图标样式</span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"35"</span>   设置图标大小</span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"fill:#fff;position:relative;top:-8px;left:-3px;"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">x-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-header</span> <span class="attr">title</span>=<span class="string">"slot:overwrite-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"overwrite-title-demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"overwrite-title"</span>  标题插槽，用于自定义标题位置内容，不仅是文字</span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-tab</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button-tab-item</span> <span class="attr">selected</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button-tab-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button-tab-item</span>&gt;</span>B<span class="tag">&lt;/<span class="name">button-tab-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-数据展示组件"><a href="#9-数据展示组件" class="headerlink" title="9. 数据展示组件"></a>9. 数据展示组件</h2><h3 id="9-1-（未）timeline"><a href="#9-1-（未）timeline" class="headerlink" title="9.1 （未）timeline"></a>9.1 （未）timeline</h3><h2 id="10-图表组件"><a href="#10-图表组件" class="headerlink" title="10. 图表组件"></a>10. 图表组件</h2><h3 id="10-1-（未）v-chart"><a href="#10-1-（未）v-chart" class="headerlink" title="10.1 （未）v-chart"></a>10.1 （未）v-chart</h3><h3 id="10-2-（未）x-circle"><a href="#10-2-（未）x-circle" class="headerlink" title="10.2 （未）x-circle"></a>10.2 （未）x-circle</h3><h2 id="11-不再维护组件"><a href="#11-不再维护组件" class="headerlink" title="11. 不再维护组件"></a>11. 不再维护组件</h2><h3 id="11-1-（未）blur"><a href="#11-1-（未）blur" class="headerlink" title="11.1 （未）blur"></a>11.1 （未）blur</h3><h3 id="11-2-（未）countdown"><a href="#11-2-（未）countdown" class="headerlink" title="11.2 （未）countdown"></a>11.2 （未）countdown</h3><h3 id="11-3-color-picker-颜色切换工具组件"><a href="#11-3-color-picker-颜色切换工具组件" class="headerlink" title="11.3 color-picker(颜色切换工具组件)"></a>11.3 color-picker(颜色切换工具组件)</h3><h4 id="11-3-1-color-picker组件的功能"><a href="#11-3-1-color-picker组件的功能" class="headerlink" title="11.3.1 color-picker组件的功能"></a>11.3.1 color-picker组件的功能</h4><p>颜色切换工具组件，可以直接使用，也可以在<code>cell</code>组件中使用；</p>
<h4 id="11-3-2-color-picker组件的属性"><a href="#11-3-2-color-picker组件的属性" class="headerlink" title="11.3.2 color-picker组件的属性"></a>11.3.2 color-picker组件的属性</h4><table>
<thead>
<tr>
<th>color-picker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>string</td>
<td></td>
<td>表单值    –</td>
</tr>
<tr>
<td>colors</td>
<td>array</td>
<td>[]</td>
<td>可选颜色列表    –</td>
</tr>
<tr>
<td>size</td>
<td>string</td>
<td>large</td>
<td>按钮大小，可选值 <code>large, middle, small</code>    –</td>
</tr>
</tbody></table>
<h4 id="11-3-3-color-picker组件的注册"><a href="#11-3-3-color-picker组件的注册" class="headerlink" title="11.3.3 color-picker组件的注册"></a>11.3.3 color-picker组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ColorPicker &#125; <span class="keyword">from</span> <span class="string">'vux'</span>  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ColorPicker</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ColorPicker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'color-picker'</span>, ColorPicker)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="11-3-4-color-picker组件的使用"><a href="#11-3-4-color-picker组件的使用" class="headerlink" title="11.3.4 color-picker组件的使用"></a>11.3.4 color-picker组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">color-picker</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:colors</span>=<span class="string">"colors"</span>  设置可选颜色列表，如：['#<span class="attr">FF3B3B</span>', '#<span class="attr">FFEF7D</span>', '#<span class="attr">8AEEB1</span>', '#<span class="attr">8B8AEE</span>', '#<span class="attr">CC68F8</span>', '#<span class="attr">fff</span>']</span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"color"</span>  使用<span class="attr">v-model</span>绑定颜色表单值，如： '#<span class="attr">FF3B3B</span>'</span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"middle"</span>  设置按钮大小，可选值 `<span class="attr">large</span>, <span class="attr">middle</span>, <span class="attr">small</span>`</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">color-picker</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4-masker（遮罩）"><a href="#11-4-masker（遮罩）" class="headerlink" title="11.4 masker（遮罩）"></a>11.4 masker（遮罩）</h3><h4 id="11-4-1-masker组件的功能"><a href="#11-4-1-masker组件的功能" class="headerlink" title="11.4.1 masker组件的功能"></a>11.4.1 masker组件的功能</h4><h4 id="11-4-2-masker组件的属性、插槽"><a href="#11-4-2-masker组件的属性、插槽" class="headerlink" title="11.4.2 masker组件的属性、插槽"></a>11.4.2 masker组件的属性、插槽</h4><table>
<thead>
<tr>
<th>masker组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>string</td>
<td>0, 0, 0</td>
<td>遮罩颜色，rgb值，’0, 0, 0’    –</td>
</tr>
<tr>
<td>opacity</td>
<td>number</td>
<td>0.5</td>
<td>遮罩透明度    –</td>
</tr>
<tr>
<td>fullscreen</td>
<td>boolean</td>
<td>false</td>
<td>遮罩是否全屏    v2.1.1-rc.14</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>masker组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽</td>
<td>背景内容，位于遮罩下方，一般为图片    –</td>
</tr>
<tr>
<td>content</td>
<td>遮罩上方内容，一般显示标题消息-</td>
</tr>
</tbody></table>
<h4 id="11-4-3-masker组件的注册"><a href="#11-4-3-masker组件的注册" class="headerlink" title="11.4.3 masker组件的注册"></a>11.4.3 masker组件的注册</h4><ul>
<li><p>a. 局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Masker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Masker</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>b. 全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Masker &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'masker'</span>, Masker)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="11-4-4-masker组件的使用"><a href="#11-4-4-masker组件的使用" class="headerlink" title="11.4.4 masker组件的使用"></a>11.4.4 masker组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">masker</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"border-radius: 2px;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">color</span>=<span class="string">"F9C90C"</span>  设置遮罩颜色，<span class="attr">rgb</span>值，默认 '<span class="attr">0</span>, <span class="attr">0</span>, <span class="attr">0</span>'</span></span><br><span class="line"><span class="tag">  <span class="attr">:opacity</span>=<span class="string">"0.8"</span>  设置遮罩透明度，默认<span class="attr">0.5</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-img"</span> <span class="attr">:style</span>=<span class="string">"&#123;backgroundImage: 'url(' + item.img + ')'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"m-title"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"m-time"</span>&gt;</span>2016-03-18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">masker</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-5-scroller（设置滚动区域的组件）"><a href="#11-5-scroller（设置滚动区域的组件）" class="headerlink" title="11.5 scroller（设置滚动区域的组件）"></a>11.5 scroller（设置滚动区域的组件）</h3><h4 id="11-5-1-scroller组件的功能"><a href="#11-5-1-scroller组件的功能" class="headerlink" title="11.5.1 scroller组件的功能"></a>11.5.1 scroller组件的功能</h4><h4 id="11-5-2-scroller组件的属性、事件、插槽和方法"><a href="#11-5-2-scroller组件的属性、事件、插槽和方法" class="headerlink" title="11.5.2 scroller组件的属性、事件、插槽和方法"></a>11.5.2 scroller组件的属性、事件、插槽和方法</h4><table>
<thead>
<tr>
<th>scroller组件的属性名字</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>object</td>
<td></td>
<td>对象，上拉或者下拉的状态双向绑定，使用 v-model 绑定，pulldownStatus 及 pullupStatus    –</td>
</tr>
<tr>
<td>height</td>
<td>string</td>
<td>viewport height</td>
<td>容器高度，默认为整个viewport高度，注意，该属性接受的是 String 类型，比如 200px，如果你希望scroller自动计算除去头部尾部的高度，请这样设置让组件自动计算，如height=”-40”    –</td>
</tr>
<tr>
<td>lock-x</td>
<td>boolean</td>
<td>false</td>
<td>锁定X方向    –</td>
</tr>
<tr>
<td>lock-y</td>
<td>boolean</td>
<td>false</td>
<td>锁定Y方向    –</td>
</tr>
<tr>
<td>scrollbar-x</td>
<td>boolean</td>
<td>false</td>
<td>是否显示横向滚动条    –</td>
</tr>
<tr>
<td>scrollbarY</td>
<td>boolean</td>
<td>false</td>
<td>是否显示垂直方向滚动条    –</td>
</tr>
<tr>
<td>bounce</td>
<td>boolean</td>
<td>true</td>
<td>是否显示边缘回弹效果    –</td>
</tr>
<tr>
<td>use-pulldown</td>
<td>boolean</td>
<td>false</td>
<td>是否使用下拉组件    –</td>
</tr>
<tr>
<td>use-pullup</td>
<td>boolean</td>
<td>false</td>
<td>是否使用上拉组件    –</td>
</tr>
<tr>
<td>pulldown-config</td>
<td>object</td>
<td>see below</td>
<td>下拉组件配置    –</td>
</tr>
<tr>
<td>pullup-config</td>
<td>object</td>
<td>see below</td>
<td>上拉组件配置    –</td>
</tr>
<tr>
<td>scroll-bottom-offset</td>
<td>number</td>
<td>0    在距离底部多长距离时触发事件 <code>on-scroll-bottom</code>    v2.2.1-rc.6</td>
<td></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>scroller组件的事件名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@on-scroll</td>
<td>(position)</td>
<td>容器滚动时触发，参数为top和left位置    –</td>
</tr>
<tr>
<td>@on-scroll-bottom</td>
<td>–</td>
<td>滚动到底部时触发，注意事件会触发多次，如果你需要进行数据获取，记得设置一个状态值    v2.2.1-rc.6</td>
</tr>
<tr>
<td>@on-pulldown-loading</td>
<td>–</td>
<td>用户触发下拉刷新状态，监听该事件以获取加载新数据    –</td>
</tr>
<tr>
<td>@on-pullup-loading</td>
<td>–</td>
<td>用户触发上拉加载状态，监听该事件以加载新数据    –</td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>scroller组件的插槽名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认插槽    scroller 内容，必须是一个 div 元素</td>
<td></td>
</tr>
</tbody></table>
<br>

<table>
<thead>
<tr>
<th>scroller组件的方法名字</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reset</td>
<td>(position, duration, easing)</td>
<td>在内容变化(v-for渲染，异步数据加载)后需要调用，用以重新渲染，避免新加的内容无法上拉看到，一般在 $nextTick 回调里调用。easing 可以为 ease-in, ease-in-out, ease, bezier(n, n, n, n)</td>
</tr>
<tr>
<td>donePullup</td>
<td></td>
<td>设置上拉刷新操作完成，在数据加载后执行</td>
</tr>
<tr>
<td>disablePullup</td>
<td></td>
<td>禁用上拉刷新，在没有更多数据时执行</td>
</tr>
<tr>
<td>enablePullup</td>
<td></td>
<td>启用上拉刷新插件</td>
</tr>
<tr>
<td>donePulldown</td>
<td></td>
<td>设置下拉刷新操作完成，在数据加载后执行</td>
</tr>
</tbody></table>
<h4 id="11-5-3-scroller组件的注册"><a href="#11-5-3-scroller组件的注册" class="headerlink" title="11.5.3 scroller组件的注册"></a>11.5.3 scroller组件的注册</h4><ul>
<li>a. 局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Scroller &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Scroller</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Scroller &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'scroller'</span>, Scroller)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（未）11-5-4-scroller组件的使用"><a href="#（未）11-5-4-scroller组件的使用" class="headerlink" title="（未）11.5.4 scroller组件的使用"></a>（未）11.5.4 scroller组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 11.6 wechat-emotion (微信的表情图标)</span><br><span class="line">#### 11.6.1 wechat-emotion组件的功能</span><br><span class="line"></span><br><span class="line">wechat-emotion组件是微信的表情图标组，根据插槽的中文来加载不同的图标，设置 `isGif`属性是否显示为动图；</span><br><span class="line"></span><br><span class="line">#### 11.6.2 wechat-emotion组件的属性、插槽</span><br><span class="line">wechat-emotion组件的属性名字 | 类型	 | 默认值 | 说明</span><br><span class="line">--- | --- | --- | ---</span><br><span class="line">isGif | boolean | 	false | 	是否为动图</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">组件的插槽名字 | 说明</span><br><span class="line">--- | ---</span><br><span class="line">默认插槽 | 	表情名字, 可选值: '微笑', '撇嘴', '色', '发呆', '得意', '流泪', '害羞', '闭嘴', '睡', '大哭', '尴尬', '发怒', '调皮', '呲牙', '惊讶', '难过', '酷', '冷汗', '抓狂', '吐', '偷笑', '可爱', '白眼', '傲慢', '饥饿', '困', '惊恐', '流汗', '憨笑', '大兵', '奋斗', '咒骂', '疑问', '嘘', '晕', '折磨', '衰', '骷髅', '敲打', '再见', '擦汗', '抠鼻', '鼓掌', '糗大了', '坏笑', '左哼哼', '右哼哼', '哈欠', '鄙视', '委屈', '快哭了', '阴险', '亲亲', '吓', '可怜', '菜刀', '西瓜', '啤酒', '篮球', '乒乓', '咖啡', '饭', '猪头', '玫瑰', '凋谢', '示爱', '爱心', '心碎', '蛋糕', '闪电', '炸弹', '刀', '足球', '瓢虫', '便便', '月亮', '太阳', '礼物', '拥抱', '强', '弱', '握手', '胜利', '抱拳', '勾引', '拳头', '差劲', '爱你', 'NO', 'OK', '爱情', '飞吻', '跳跳', '发抖', '怄火', '转圈', '磕头', '回头', '跳绳', '挥手', '激动', '街舞', '献吻', '左太极', '右太极'</span><br><span class="line"></span><br><span class="line">#### 11.6.3 wechat-emotion组件的注册</span><br><span class="line">- a. 局部注册</span><br><span class="line">```js</span><br><span class="line">import &#123; WechatEmotion &#125; from 'vux'</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    WechatEmotion</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b. 全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; WechatEmotion &#125; <span class="keyword">from</span> <span class="string">'vux'</span></span><br><span class="line">Vue.component(<span class="string">'wechat-emotion'</span>, WechatEmotion)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="11-6-4-wechat-emotion组件的使用"><a href="#11-6-4-wechat-emotion组件的使用" class="headerlink" title="11.6.4 wechat-emotion组件的使用"></a>11.6.4 wechat-emotion组件的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">class</span>=<span class="string">"vux-center-h"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emotion</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">emotion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emotion</span> <span class="attr">is-gif</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">emotion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">list 数据</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">      list: ['微笑', '撇嘴', '色', '发呆', '得意', '流泪', '害羞', '闭嘴', '睡', '大哭', '尴尬', '发怒', '调皮', '呲牙', '惊讶', '难过', '酷', '冷汗', '抓狂', '吐', '偷笑', '可爱', '白眼', '傲慢', '饥饿', '困', '惊恐', '流汗', '憨笑', '大兵', '奋斗', '咒骂', '疑问', '嘘', '晕', '折磨', '衰', '骷髅', '敲打', '再见', '擦汗', '抠鼻', '鼓掌', '糗大了', '坏笑', '左哼哼', '右哼哼', '哈欠', '鄙视', '委屈', '快哭了', '阴险', '亲亲', '吓', '可怜', '菜刀', '西瓜', '啤酒', '篮球', '乒乓', '咖啡', '饭', '猪头', '玫瑰', '凋谢', '示爱', '爱心', '心碎', '蛋糕', '闪电', '炸弹', '刀', '足球', '瓢虫', '便便', '月亮', '太阳', '礼物', '拥抱', '强', '弱', '握手', '胜利', '抱拳', '勾引', '拳头', '差劲', '爱你', 'NO', 'OK', '爱情', '飞吻', '跳跳', '发抖', '怄火', '转圈', '磕头', '回头', '跳绳', '挥手', '激动', '街舞', '献吻', '左太极', '右太极']</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UI组件</category>
        <category>VuxUI</category>
      </categories>
      <tags>
        <tag>VueUI组件库</tag>
        <tag>Vux</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO搭建个人博客进阶——NEXT主题优化</title>
    <url>/2018/12/29/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NEXT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>HEXO搭建个人博客进阶——NEXT主题优化</p>
<a id="more"></a>

<h1 id="HEXO搭建个人博客进阶——NEXT主题优化"><a href="#HEXO搭建个人博客进阶——NEXT主题优化" class="headerlink" title="HEXO搭建个人博客进阶——NEXT主题优化"></a>HEXO搭建个人博客进阶——NEXT主题优化</h1><blockquote>
<p>该博文内容还在编辑过程中，谢谢</p>
</blockquote>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NEXT</tag>
        <tag>Blog个性化</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO搭建个人博客基础——建站发布</title>
    <url>/2018/12/28/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%99%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>HEXO搭建属于你的个性化博客网站</p>
<a id="more"></a>

<h2 id="HEXO搭建个人博客基础——建站发布"><a href="#HEXO搭建个人博客基础——建站发布" class="headerlink" title="HEXO搭建个人博客基础——建站发布"></a>HEXO搭建个人博客基础——建站发布</h2><h2 id="一、-HEXO-使用环境基础"><a href="#一、-HEXO-使用环境基础" class="headerlink" title="一、 HEXO 使用环境基础"></a>一、 HEXO 使用环境基础</h2><p>HEXO博客搭建环境必须包括 <code>nodejs</code>-<a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a> 与 <code>git</code> -<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>，从对应的官网进行对应的安装；</p>
<h2 id="二、-本地建立HEXO项目（测试生成静态文件并本地运行）"><a href="#二、-本地建立HEXO项目（测试生成静态文件并本地运行）" class="headerlink" title="二、 本地建立HEXO项目（测试生成静态文件并本地运行）"></a>二、 本地建立HEXO项目（测试生成静态文件并本地运行）</h2><blockquote>
<p>执行下面的代码：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:hexo/    <span class="comment">#换成你的目录</span></span><br><span class="line">$ npm install -g hexo-cli  <span class="comment">#安装hexo脚手架</span></span><br><span class="line">$ hexo init     <span class="comment">#Hexo自动在当前文件夹下下载搭建网站所需的所有文件</span></span><br><span class="line">$ npm install   <span class="comment">#安装依赖包</span></span><br><span class="line"></span><br><span class="line">$ hexo g        <span class="comment">#完整命令为hexo generate，生成静态文件</span></span><br><span class="line">$ hexo s        <span class="comment">#完整命令为hexo server，启动服务器，用来本地预览</span></span><br><span class="line">$ hexo d        <span class="comment">#完整命令为hexo deploy，部署网站到GitHub或者gitee上（配置见下方）</span></span><br></pre></td></tr></table></figure>

<h2 id="三、页面部署到-Github-Page-或者-Gitee-page"><a href="#三、页面部署到-Github-Page-或者-Gitee-page" class="headerlink" title="三、页面部署到 Github Page 或者 Gitee page"></a>三、页面部署到 Github Page 或者 Gitee page</h2><h3 id="3-1-Github-Page"><a href="#3-1-Github-Page" class="headerlink" title="3.1. Github Page"></a>3.1. Github Page</h3><ol>
<li>在github上面创建仓库， 仓库名为：<code>&lt;Github账号名称&gt;.github.io</code>；</li>
<li>添加SSH key，本地Hexo博客推送到GithubPages：<ul>
<li>配置下<code>SSH</code>，具体方法如下：</li>
<li>先创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：<code>$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;</code>；</li>
<li>复制密钥文件内容（路径形如 <code>C:\Users\Administrator\.ssh\id_rsa.pub</code>），粘贴到<code>Github：setting–&gt;SSH and GPG keys–&gt;New SSH key</code> 即可；</li>
</ul>
</li>
<li>修改HEXO 网站配置文件 <code>_config.yml</code> 的 <code>deploy</code> 字段，改为：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li>修改HEXO 网站配置文件 <code>_config.yml</code> 的 <code>deploy</code> 字段，改为：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://&lt;Github账号名称&gt;.gitee.io</span> <span class="comment">#填写自己的账号名称</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure></li>
<li>执行命令进行网站静态文件上传：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g --d</span><br></pre></td></tr></table></figure></li>
<li>在浏览器访问网址查看您的HEXO博客： <code>https://&lt;Github账号名称&gt;.github.io</code></li>
</ol>
<h3 id="3-2-Gitee-page"><a href="#3-2-Gitee-page" class="headerlink" title="3.2. Gitee page"></a>3.2. Gitee page</h3><ol>
<li>在gitee上面创建一个空的仓库用于博客网站的发布；</li>
<li>在hexo建立的本地博客目录下进入<code>git bash</code>，输入下面的命令后，打开生成的 <code>id_rsa.pub</code> 文件，复制公钥到gitee的 <code>ssh key</code>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"username"</span>  <span class="comment">#(注：username为你gitee上的用户名)</span></span><br></pre></td></tr></table></figure></li>
<li>修改hexo的完整根目录下的 <code>_config.yml</code>文件，增加 <code>gitee</code> 部署的相关信息：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@gitee.com:&lt;Gitee账号名称&gt;/&lt;仓库名称&gt;.git</span>     <span class="comment">#发布到gitee</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>修改hexo的完整根目录下的 <code>_config.yml</code>文件，增加生成的文件的资源路径地址的相关信息（防止css等资源出错）：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://&lt;Gitee账号名称&gt;.gitee.io/&lt;仓库名称&gt;</span>  <span class="comment">#这个是gitee 上的博客仓库地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/&lt;仓库名称&gt;</span>  <span class="comment">#这个是博客项目的名字</span></span><br></pre></td></tr></table></figure></li>
<li>将博客内容提交到gitee后，开启 <code>gitee pages</code> 服务，可以看到部署的网站的页面，打开浏览器访问网址查看您的HEXO博客： <code>https://&lt;Gitee账号名称&gt;.gitee.io/&lt;仓库名称&gt;/</code>；</li>
</ol>
<h2 id="四、在GithubPages的基础上，添加自定义域名（您购买的域名）"><a href="#四、在GithubPages的基础上，添加自定义域名（您购买的域名）" class="headerlink" title="四、在GithubPages的基础上，添加自定义域名（您购买的域名）"></a>四、在GithubPages的基础上，添加自定义域名（您购买的域名）</h2><h3 id="4-1-域名配置"><a href="#4-1-域名配置" class="headerlink" title="4.1 域名配置"></a>4.1 域名配置</h3><h4 id="4-1-1-域名购买"><a href="#4-1-1-域名购买" class="headerlink" title="4.1.1 域名购买"></a>4.1.1 域名购买</h4><p>这里我选择的是<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>购买的域名，购买成功后可以在控制台查看自己购买的域名，查看购买的域名的 <code>服务状态显示为正常</code> ；</p>
<h4 id="4-1-2-域名解析"><a href="#4-1-2-域名解析" class="headerlink" title="4.1.2 域名解析"></a>4.1.2 域名解析</h4><p>方式1:（<code>测试成功</code>）</p>
<ol>
<li>点击域名的操作中的解析，进入域名的解析页面；</li>
<li>点击 <code>快速添加网站/ 邮箱解析</code>，选择 <code>网站解析</code>，</li>
<li>在网站解析中设置 <code>ip</code> 地址为 <code>github</code> 的IP地址，Github 的IP地址为 <code>192.30.252.153</code>；</li>
<li>检验你的网站是否能够正确解析到 <code>Github</code> 的ip地址：<a href="https://myssl.com/dns_check.html#dns_check" target="_blank" rel="noopener">DNS查询</a><ul>
<li>输入您购买的域名地址，选择为 <code>A</code> 类（默认的），进行检测，正确进行DNS解析表示域名ok了；</li>
</ul>
</li>
</ol>
<p>方式2:</p>
<ol>
<li>点击域名的操作中的解析，进入域名的解析页面；</li>
<li>手动添加解析的相关类容：<ul>
<li>类型选择为 CNAME；</li>
<li>主机记录即域名前缀，填写为www；</li>
<li>记录值填写为自定义域名；（<strong>此处在配置中需要注意，容易出问题</strong>）</li>
<li>解析线路，TTL 默认即可。</li>
</ul>
</li>
<li>检验你的网站是否能够正确解析:<a href="https://myssl.com/dns_check.html#dns_check" target="_blank" rel="noopener">DNS查询</a><ul>
<li>输入您购买的域名地址，选择为 <code>CNAME</code> 类（默认的），进行检测，正确进行DNS解析表示域名ok了；</li>
</ul>
</li>
</ol>
<h3 id="4-2-域名绑定-Github-的-Page-服务"><a href="#4-2-域名绑定-Github-的-Page-服务" class="headerlink" title="4.2 域名绑定 Github 的 Page 服务"></a>4.2 域名绑定 Github 的 Page 服务</h3><ol>
<li>打开博客仓库设置：<code>https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings</code>；</li>
<li>其中的 <code>Custom domain</code> 允许您从<code>&lt;Github账号名称&gt;.github.io</code>以外的域服务您的站点，在输入框中填写您购买的域名，点击save；</li>
<li>在HEXO站点目录的 <code>source</code> 文件夹下，新建文件 <code>CNAME</code>，写入你的域名（如<code>www.geekleng.xyz</code>）并保存；</li>
<li>在HEXO的站点配置文件 <code>_config.yml</code> 文件中修改 <code>skip_render</code>字段，如下所示：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="comment">#跳过指定文件的渲染，可使用 glob 表达式来匹配路径，这里可以写README文件和保存你的域名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">README.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure></li>
<li>在浏览器中访问自定义的域名查看，同时 <code>https://&lt;Github账号名称&gt;.github.io</code> 也可用；</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPage</tag>
        <tag>GiteePages</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题官方文档笔记</title>
    <url>/2018/12/26/Next%E4%B8%BB%E9%A2%98%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Next主题官方文档笔记</p>
<a id="more"></a>
<h2 id="Next主题官方文档笔记"><a href="#Next主题官方文档笔记" class="headerlink" title="Next主题官方文档笔记"></a>Next主题官方文档笔记</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题官方文档</a></p>
<h2 id="一、开始使用"><a href="#一、开始使用" class="headerlink" title="一、开始使用"></a>一、开始使用</h2><h3 id="1-1-安装-NexT"><a href="#1-1-安装-NexT" class="headerlink" title="1.1 安装 NexT"></a>1.1 安装 NexT</h3><p>HEXO中将主题文件拷贝至站点目录的 themes 目录下， 然后修改下 <strong>网站配置文件</strong> <code>_config.yml</code> 中的 <code>theme: next</code> 即可；</p>
<p>NEXT主题下载方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：下载最新的NEXT主题</span></span><br><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：进入next版本发布页面，下载稳定版：https://github.com/iissnan/hexo-theme-next/releases；</span></span><br><span class="line"><span class="comment"># 下载好了压缩包后到站点的themes下解压，再修改修改下网站配置文件 `_config.yml` 中的 `theme: next`</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令查看主题是否安装成功：<code>hexo server -i 127.0.0.1 -p 5000</code></p>
<h3 id="1-2-主题设定"><a href="#1-2-主题设定" class="headerlink" title="1.2 主题设定"></a>1.2 主题设定</h3><h4 id="1-2-1-选择「Scheme」"><a href="#1-2-1-选择「Scheme」" class="headerlink" title="1.2.1 选择「Scheme」"></a>1.2.1 选择「Scheme」</h4><p>NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>Next主题设置其具体主题是修改 <strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>scheme</code> 关键字；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line">scheme: Mist <span class="comment"># 使用NEXT的Mist主题</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-设置「界面语言」"><a href="#1-2-2-设置「界面语言」" class="headerlink" title="1.2.2 设置「界面语言」"></a>1.2.2 设置「界面语言」</h4><p>HEXO 的 <strong>网站配置文件</strong> <code>_config.yml</code> 中的 <code>language</code> 关键字;</p>
<ul>
<li><code>zh-Hans</code> ：表示简体中文</li>
<li><code>zh-hk 或者 zh-tw</code>：表示繁体中文</li>
<li><code>en</code>：表示英文</li>
</ul>
<h4 id="1-2-3-设置「菜单」"><a href="#1-2-3-设置「菜单」" class="headerlink" title="1.2.3 设置「菜单」"></a>1.2.3 设置「菜单」</h4><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>menu</code>、<code>menu_icons</code>字段设定菜单内容及图标;</p>
<ul>
<li>设定菜单内容，对应的字段是 menu。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home <span class="comment">#主页</span></span><br><span class="line">  archives: /archives/ || archive <span class="comment">#归档页</span></span><br><span class="line">  tags: /tags/ || tags <span class="comment">#标签页</span></span><br><span class="line">  categories: /categories/ || th <span class="comment">#分类页</span></span><br><span class="line">  about: /about/ || user <span class="comment">#	关于页面</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat #公益 404</span></span><br></pre></td></tr></table></figure></li>
<li>设置菜单项的显示文本: NexT 主题目录下的 <code>languages/{language}.yml</code>（{language} 为你所使用的语言），修改里面的 <code>menu</code> 字段；<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># languages/zh-Hans.yml 修改简体中文文件</span></span><br><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">  something: 有料</span><br></pre></td></tr></table></figure></li>
<li>设定菜单项的图标，对应的字段是 <code>menu_icons</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mapping.</span></span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-2-4-设置「侧栏」"><a href="#1-2-4-设置「侧栏」" class="headerlink" title="1.2.4 设置「侧栏」"></a>1.2.4 设置「侧栏」</h4><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>sidebar</code> 字段，侧栏的设置一是侧栏的位置， 二是侧栏显示的时机。</p>
<ul>
<li>设置侧栏的位置：<code>sidebar 字段下的 position 选项</code> ，设置值为 <code>left/right</code>；【注意仅仅是NEXT的 <code>Pisces Scheme</code> 主题支持该设置 】</li>
<li>设置侧栏显示的时机： <code>sidebar 字段下的 display 选项</code>，设置值为：<ul>
<li><code>post</code> - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li><code>always</code> - 在所有页面中都显示</li>
<li><code>hide</code> - 在所有页面中都隐藏（可以手动展开）</li>
<li><code>remove</code> - 完全移除</li>
</ul>
</li>
</ul>
<h4 id="1-2-5-设置「头像」"><a href="#1-2-5-设置「头像」" class="headerlink" title="1.2.5 设置「头像」"></a>1.2.5 设置「头像」</h4><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>avatar</code> 字段，值设置成头像的链接地址；例如：<code>avatar: http://example.com/avatar.png</code></p>
<h4 id="1-2-6-设置「作者昵称」"><a href="#1-2-6-设置「作者昵称」" class="headerlink" title="1.2.6 设置「作者昵称」"></a>1.2.6 设置「作者昵称」</h4><p>HEXO 的 <strong>网站配置文件</strong> <code>_config.yml</code> 中的 <code>author</code> 关键字;</p>
<h4 id="1-2-7-设置「站点描述」"><a href="#1-2-7-设置「站点描述」" class="headerlink" title="1.2.7 设置「站点描述」"></a>1.2.7 设置「站点描述」</h4><p>HEXO 的 <strong>网站配置文件</strong> <code>_config.yml</code> 中的 <code>description</code> 关键字;</p>
<h3 id="1-3-集成第三方服务"><a href="#1-3-集成第三方服务" class="headerlink" title="1.3 集成第三方服务"></a>1.3 集成第三方服务</h3><h4 id="1-3-1-百度统计"><a href="#1-3-1-百度统计" class="headerlink" title="1.3.1 百度统计"></a>1.3.1 百度统计</h4><ul>
<li>登录到 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>，查看网站代码；</li>
<li>在源码中搜索下面代码 <code>hm.src = &quot;//hm.baidu.com/hm.js?****&quot;; //****为你的脚本的id</code><br><img src="/2018/12/26/Next%E4%B8%BB%E9%A2%98%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/1.png" alt="百度统计id"></li>
<li>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>baidu_analytics</code> 字段，值设置成你的脚本的id；</li>
</ul>
<h4 id="未1-3-2-阅读次数统计（LeanCloud）"><a href="#未1-3-2-阅读次数统计（LeanCloud）" class="headerlink" title="未1.3.2 阅读次数统计（LeanCloud）"></a>未1.3.2 阅读次数统计（LeanCloud）</h4><h4 id="未1-3-3-Algolia-搜索"><a href="#未1-3-3-Algolia-搜索" class="headerlink" title="未1.3.3 Algolia 搜索"></a>未1.3.3 Algolia 搜索</h4><h2 id="二、主题配置"><a href="#二、主题配置" class="headerlink" title="二、主题配置"></a>二、主题配置</h2><h3 id="2-1-设置「RSS」"><a href="#2-1-设置「RSS」" class="headerlink" title="2.1 设置「RSS」"></a>2.1 设置「RSS」</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>rss</code> 字段，设置值：</p>
<ul>
<li>false：禁用 RSS，不在页面上显示 RSS 连接。</li>
<li>留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 <code>hexo-generator-feed</code> 插件。</li>
<li>具体的链接地址：适用于已经烧制过 Feed 的情形。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先下载该插件，再改对应 rss 字段的值</span></span><br><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>

<h3 id="2-2-添加「标签-tags」页面"><a href="#2-2-添加「标签-tags」页面" class="headerlink" title="2.2 添加「标签-tags」页面"></a>2.2 添加「标签-tags」页面</h3><h3 id="2-3-添加「分类-categories」页面"><a href="#2-3-添加「分类-categories」页面" class="headerlink" title="2.3 添加「分类-categories」页面"></a>2.3 添加「分类-categories」页面</h3><p>为文章添加标签或者分类的步骤如下：</p>
<ul>
<li>使用 <code>hexo new page</code> 新建一个页面，命名为 <code>tags/ categories</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ hexo new page tags <span class="comment"># categories</span></span><br></pre></td></tr></table></figure></li>
<li>编辑刚新建的页面，将页面的类型设置为 <code>tags/ categories</code> ，主题将自动为这个页面显示标签/ 分类云。<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2014</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">12</span>:<span class="number">39</span>:<span class="number">04</span></span><br><span class="line"><span class="keyword">type</span>: <span class="string">"tags"</span> </span><br><span class="line">comments: <span class="string">"false"</span> </span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2014</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">12</span>:<span class="number">39</span>:<span class="number">04</span></span><br><span class="line"><span class="keyword">type</span>: <span class="string">"categories"</span> </span><br><span class="line">comments: <span class="string">"false"</span> </span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>在菜单中添加链接。编辑NEXT 的<strong>主题配置文件</strong>， 添加 <code>tags/ categories</code> 到 <code>menu</code> 中；</li>
</ul>
<h3 id="2-4-设置「字体」"><a href="#2-4-设置「字体」" class="headerlink" title="2.4 设置「字体」"></a>2.4 设置「字体」</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>font</code> 字段，设置以下范围字体的值：</p>
<ul>
<li>全局字体：定义的字体将在全站范围使用</li>
<li>标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6）</li>
<li>文章字体：文章所使用的字体</li>
<li>Logo字体：Logo 所使用的字体</li>
<li>代码字体： 代码块所使用的字体</li>
</ul>
<h3 id="2-5-设置「代码高亮主题」"><a href="#2-5-设置「代码高亮主题」" class="headerlink" title="2.5 设置「代码高亮主题」"></a>2.5 设置「代码高亮主题」</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>highlight_theme</code> 字段，NexT 默认使用的是 白色的 <code>normal</code> 主题，可选的值有 normal，night（黑色）， night blue（蓝黑）， night bright（深黑）， night eighties（灰黑）</p>
<h3 id="2-6-侧边栏社交链接"><a href="#2-6-侧边栏社交链接" class="headerlink" title="2.6 侧边栏社交链接"></a>2.6 侧边栏社交链接</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>social / social_icons</code> 字段，一是链接，二是链接图标；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social links</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/your-user-name</span><br><span class="line">  Twitter: https://twitter.com/your-user-name</span><br><span class="line">  微博: http://weibo.com/your-user-name</span><br><span class="line">  豆瓣: http://douban.com/people/your-user-name</span><br><span class="line">  知乎: http://www.zhihu.com/people/your-user-name</span><br><span class="line"><span class="comment"># Social Icons</span></span><br><span class="line">social_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mappings</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br><span class="line">  微博: weibo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以将 Social Icons 放在 Social links 中，写法如下：</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/your-user-name || github</span><br></pre></td></tr></table></figure>

<h3 id="2-7-开启打赏功能"><a href="#2-7-开启打赏功能" class="headerlink" title="2.7 开启打赏功能"></a>2.7 开启打赏功能</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>reward_comment / wechatpay / alipay</code> 字段，分别加入图片地址即可（最好是网络资源，本地资源测试加载出错）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /path/to/wechat-reward-image</span><br><span class="line">alipay: /path/to/alipay-reward-image</span><br></pre></td></tr></table></figure>

<h3 id="2-8-设置友情链接"><a href="#2-8-设置友情链接" class="headerlink" title="2.8 设置友情链接"></a>2.8 设置友情链接</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>links</code> 字段:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">links_title: Links</span><br><span class="line"><span class="comment"># links_layout: block # 表示链接为块标签显示</span></span><br><span class="line">links_layout: inline <span class="comment"># 表示链接为行内标签显示</span></span><br><span class="line">links:</span><br><span class="line">  Vue: https://cn.vuejs.org/</span><br><span class="line">  Vux: https://doc.vux.li/zh-CN/</span><br><span class="line">  HEXO: https://hexo.io/zh-cn</span><br></pre></td></tr></table></figure>

<h3 id="2-9-腾讯公益404页面"><a href="#2-9-腾讯公益404页面" class="headerlink" title="2.9 腾讯公益404页面"></a>2.9 腾讯公益404页面</h3><p>新建 <code>404.html</code> 页面，使用 <code>hexo new page</code> 生成，放到NEXT主题的 <code>source</code> 目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://qzone.qq.com/gy/404/style/404style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/plain"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">homePageName</span>=<span class="string">"回到我的主页"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-10-站点建立时间"><a href="#2-10-站点建立时间" class="headerlink" title="2.10 站点建立时间"></a>2.10 站点建立时间</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>since</code> 字段 : <code>since: 2013</code></p>
<h3 id="2-11-订阅微信公众号"><a href="#2-11-订阅微信公众号" class="headerlink" title="2.11 订阅微信公众号"></a>2.11 订阅微信公众号</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>wechat_subscriber</code> 字段下的属性:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Wechat Subscriber</span></span><br><span class="line">wechat_subscriber:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  qcode: /uploads/wechat-qcode.jpg</span><br><span class="line">  description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！</span><br></pre></td></tr></table></figure>

<h3 id="2-12-设置「动画效果」"><a href="#2-12-设置「动画效果」" class="headerlink" title="2.12 设置「动画效果」"></a>2.12 设置「动画效果」</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>motion</code> 字段下的各个属性的动画；</p>
<h3 id="2-13-设置「背景动画」"><a href="#2-13-设置「背景动画」" class="headerlink" title="2.13 设置「背景动画」"></a>2.13 设置「背景动画」</h3><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>canvas_nest / three_waves / canvas_lines / canvas_sphere</code> 字段设置为 <code>true</code>则开启该动画；</p>
<h2 id="三、第三方服务"><a href="#三、第三方服务" class="headerlink" title="三、第三方服务"></a>三、第三方服务</h2><h3 id="3-1-评论系统"><a href="#3-1-评论系统" class="headerlink" title="3.1 评论系统"></a>3.1 评论系统</h3><h4 id="3-1-1-Disqus"><a href="#3-1-1-Disqus" class="headerlink" title="3.1.1 Disqus"></a>3.1.1 Disqus</h4><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>disqus</code> 字段下的各个属性值修改如下；</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># 用于指定是否显示评论数量。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-Facebook-Comments"><a href="#3-1-2-Facebook-Comments" class="headerlink" title="3.1.2 Facebook Comments"></a>3.1.2 Facebook Comments</h4><h4 id="3-1-3-HyperComments"><a href="#3-1-3-HyperComments" class="headerlink" title="3.1.3 HyperComments"></a>3.1.3 HyperComments</h4><h4 id="3-1-4-网易云跟帖"><a href="#3-1-4-网易云跟帖" class="headerlink" title="3.1.4 网易云跟帖"></a>3.1.4 网易云跟帖</h4><h4 id="3-1-5-来必力"><a href="#3-1-5-来必力" class="headerlink" title="3.1.5 来必力"></a>3.1.5 来必力</h4><ul>
<li>先到<a href="https://www.livere.com/" target="_blank" rel="noopener">来必力</a>网站进行注册，再登陆；</li>
<li>选择<code>免费的city版本</code>，在显示的代码中查找 <code>data-uid= &#39;xxxx&#39;</code>，复制该值；</li>
<li>将NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>livere_uid</code> 字段值设置为刚刚复制的值；<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="string">&#123;你的来必力id&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-数据统计与分析"><a href="#3-2-数据统计与分析" class="headerlink" title="3.2 数据统计与分析"></a>3.2 数据统计与分析</h3><h4 id="3-2-1-百度统计"><a href="#3-2-1-百度统计" class="headerlink" title="3.2.1 百度统计"></a>3.2.1 百度统计</h4><ul>
<li><p>登录到 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>，查看网站代码；</p>
</li>
<li><p>在源码中搜索下面代码 <code>hm.src = &quot;//hm.baidu.com/hm.js?****&quot;; //****为你的脚本的id</code><br><img src="/2018/12/26/Next%E4%B8%BB%E9%A2%98%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/1.png" alt="百度统计id"></p>
</li>
<li><p>NEXT 的<strong>主题配置文件</strong> <code>_config.yml</code> 中的 <code>baidu_analytics</code> 字段，值设置成你的脚本的id；</p>
</li>
</ul>
<h4 id="3-2-2-Google-分析"><a href="#3-2-2-Google-分析" class="headerlink" title="3.2.2 Google 分析"></a>3.2.2 Google 分析</h4><h4 id="3-2-3-腾讯分析"><a href="#3-2-3-腾讯分析" class="headerlink" title="3.2.3 腾讯分析"></a>3.2.3 腾讯分析</h4><h4 id="3-2-4-CNZZ-统计"><a href="#3-2-4-CNZZ-统计" class="headerlink" title="3.2.4 CNZZ 统计"></a>3.2.4 CNZZ 统计</h4><h4 id="3-2-5-不蒜子统计"><a href="#3-2-5-不蒜子统计" class="headerlink" title="3.2.5 不蒜子统计"></a>3.2.5 不蒜子统计</h4><p>编辑HEXO主题配置文件 <code>_config.yml</code> 中的 <code>busuanzi_count</code> 字段的的配置项即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 代表开启全局开关</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="comment"># 效果：本站访客数12345人次</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span> <span class="comment"># 代表在页面底部显示站点的UV值</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">本站访客数</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span> <span class="string">人数</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="comment"># 效果：本站总访问量12345次（一般不开启这个）</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">false</span> <span class="comment"># 代表在页面底部显示站点的PV值。</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">本站总访问量</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span> <span class="string">次</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="comment"># 效果：本文总阅读量12345次</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span> <span class="comment"># 代表在文章页面的标题下显示该页面的PV值（阅读数）。</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">本文总阅读量</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span> <span class="string">次</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：由于不蒜子统计网站的原有域名不能使用，还需要按照下面解决方法修改域名:</strong></p>
<ul>
<li>找到主题调用不蒜子的swig文件，路径是<code>”\themes*\layout\_third-party\analytics\busuanzi-counter.swig”</code></li>
<li>更改域名：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">把原有的：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">域名改一下即可：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span>&lt;/script</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-6-腾讯移动分析"><a href="#3-2-6-腾讯移动分析" class="headerlink" title="3.2.6 腾讯移动分析"></a>3.2.6 腾讯移动分析</h4><h3 id="3-3-内容分享服务"><a href="#3-3-内容分享服务" class="headerlink" title="3.3 内容分享服务"></a>3.3 内容分享服务</h3><h4 id="3-3-1-JiaThis"><a href="#3-3-1-JiaThis" class="headerlink" title="3.3.1 JiaThis"></a>3.3.1 JiaThis</h4><h4 id="3-3-2-百度分享"><a href="#3-3-2-百度分享" class="headerlink" title="3.3.2 百度分享"></a>3.3.2 百度分享</h4><h4 id="3-3-3-AddThis"><a href="#3-3-3-AddThis" class="headerlink" title="3.3.3 AddThis"></a>3.3.3 AddThis</h4><h3 id="3-4-搜索服务"><a href="#3-4-搜索服务" class="headerlink" title="3.4 搜索服务"></a>3.4 搜索服务</h3><h4 id="3-4-1-Swiftype"><a href="#3-4-1-Swiftype" class="headerlink" title="3.4.1 Swiftype"></a>3.4.1 Swiftype</h4><h4 id="3-4-2-微搜索"><a href="#3-4-2-微搜索" class="headerlink" title="3.4.2 微搜索"></a>3.4.2 微搜索</h4><h4 id="3-4-3-Local-Search"><a href="#3-4-3-Local-Search" class="headerlink" title="3.4.3 Local Search"></a>3.4.3 Local Search</h4><p>添加百度/谷歌/本地 自定义站点内容搜索</p>
<ul>
<li>安装 <code>hexo-generator-searchdb</code> 包，在HEXO站点的根目录下执行以下命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>编辑HEXO主题配置文件 <code>_config.yml</code> ，新增以下内容到任意位置：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编辑 NEXT主题配置文件 <code>_config.yml</code> 中的<code>Local search</code> 字段，启用本地搜索功能：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-4-4-Algolia"><a href="#3-4-4-Algolia" class="headerlink" title="3.4.4 Algolia"></a>3.4.4 Algolia</h4><h3 id="3-5-其他服务"><a href="#3-5-其他服务" class="headerlink" title="3.5 其他服务"></a>3.5 其他服务</h3><h4 id="3-5-1-MathJax"><a href="#3-5-1-MathJax" class="headerlink" title="3.5.1 MathJax"></a>3.5.1 MathJax</h4><h4 id="3-5-2-Facebook-SDK"><a href="#3-5-2-Facebook-SDK" class="headerlink" title="3.5.2 Facebook SDK"></a>3.5.2 Facebook SDK</h4><h4 id="3-5-3-Google-Webmaster-tools"><a href="#3-5-3-Google-Webmaster-tools" class="headerlink" title="3.5.3 Google Webmaster tools"></a>3.5.3 Google Webmaster tools</h4><h2 id="四、内建标签"><a href="#四、内建标签" class="headerlink" title="四、内建标签"></a>四、内建标签</h2><h3 id="4-1-文本居中的引用"><a href="#4-1-文本居中的引用" class="headerlink" title="4.1 文本居中的引用"></a>4.1 文本居中的引用</h3><p>该标签会生成一个带上下分割线的引用，同时引用内文本将自动居中，适用于单行文本展示，如文章开篇引用 或者 结束语之前的总结引用；</p>
<p>使用方式：</p>
<ul>
<li>HTML方式：使用这种方式时，给 img 添加属性 <code>class=&quot;blockquote-center&quot;</code> 即可；</li>
<li>标签方式：使用 <code>centerquote</code> 或者 简写 <code>cq</code>;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span>blah blah blah<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span></span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 标签别名 --&gt;</span></span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-突破容器宽度限制的图片"><a href="#4-2-突破容器宽度限制的图片" class="headerlink" title="4.2 突破容器宽度限制的图片"></a>4.2 突破容器宽度限制的图片</h3><p>当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力；</p>
<p>使用方式：</p>
<ul>
<li>HTML方式：使用这种方式时，为 img 添加属性 <code>class=&quot;full-image&quot;</code> 即可;</li>
<li>标签方式：使用 <code>fullimage</code> 或者 简写 <code>fi</code>， 并传递<code>图片地址、 alt 和 title</code> 属性即可。 属性之间以逗号分隔;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 class="full-image" 是必须的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/image-url"</span> <span class="attr">class</span>=<span class="string">"full-image"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span></span><br><span class="line">&#123;% fullimage /image-url, alt, title %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 别名 --&gt;</span></span><br><span class="line">&#123;% fi /image-url, alt, title %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Bootstrap-Callout"><a href="#4-3-Bootstrap-Callout" class="headerlink" title="4.3 Bootstrap Callout"></a>4.3 Bootstrap Callout</h3><blockquote>
<p><a href="https://getbootstrap.com/" target="_blank" rel="noopener"> Bootstrap 的官方文档</a></p>
</blockquote>
<p>使用方式：<code><div class="note class_name">
            <p>Content (md partial supported) </p>
          </div></code>；其中的 <code>class_name</code> 可以是以下列表中的一个值：<code>default、primary、success、info、warning、danger</code>；</p>
<h2 id="五、进阶设定"><a href="#五、进阶设定" class="headerlink" title="五、进阶设定"></a>五、进阶设定</h2><h3 id="5-1-设置-「JavaScript-第三方库」"><a href="#5-1-设置-「JavaScript-第三方库」" class="headerlink" title="5.1 设置 「JavaScript 第三方库」"></a>5.1 设置 「JavaScript 第三方库」</h3><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="6-1-如何设置「阅读全文」？"><a href="#6-1-如何设置「阅读全文」？" class="headerlink" title="6.1 如何设置「阅读全文」？"></a>6.1 如何设置「阅读全文」？</h3><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式：</p>
<ul>
<li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式；<strong>强烈推荐使用</strong></li>
<li>在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录；</li>
<li>自动形成摘要，修改NEXT的 主题配置文件 <code>_config.yml</code> 中的<code>auto_excerpt</code> 字段：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span> <span class="comment"># 默认截取的长度为 150 字符，可以根据需要自行设定</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-2-Favicon-设置后没有生效？"><a href="#6-2-Favicon-设置后没有生效？" class="headerlink" title="6.2 Favicon 设置后没有生效？"></a>6.2 Favicon 设置后没有生效？</h3><p>注意设置的文件使用的路径的问题；修改NEXT的 主题配置文件 <code>_config.yml</code> 中的<code>url</code> 字段：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://geek-lhj.gitee.io</span> <span class="comment">#填写你自己的站点链接,geek-lhj为我的github的用户名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span> <span class="comment">#设置根目录的位置</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-如何更改字体？"><a href="#6-3-如何更改字体？" class="headerlink" title="6.3 如何更改字体？"></a>6.3 如何更改字体？</h3><p> 编辑主题下的 <code>source/css/_variables/custom.styl</code> 文件；</p>
<h3 id="6-4-如何更改内容区域的宽度？"><a href="#6-4-如何更改内容区域的宽度？" class="headerlink" title="6.4 如何更改内容区域的宽度？"></a>6.4 如何更改内容区域的宽度？</h3><p>编辑主题的 <code>source/css/_variables/custom.styl</code> 文件;</p>
<h3 id="6-5-为何新增的菜单项显示-Menu-xxx？"><a href="#6-5-为何新增的菜单项显示-Menu-xxx？" class="headerlink" title="6.5 为何新增的菜单项显示 Menu.xxx？"></a>6.5 为何新增的菜单项显示 Menu.xxx？</h3><p>修改NEXT的 主题配置文件 <code>_config.yml</code> 中的<code>menu</code> 字段，若是自定义的菜单需要修改对于的语言文件中的内容，例如中文的语言文件在<code>...languages/zh-Hans.yml</code>目录下；</p>
<h3 id="6-6-标签-分类数量统计不准确？"><a href="#6-6-标签-分类数量统计不准确？" class="headerlink" title="6.6 标签/分类数量统计不准确？"></a>6.6 标签/分类数量统计不准确？</h3><p>是由于缓存的问题，重新进行打包发布即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除生成的本地public目录的代码</span></span><br><span class="line">hexo g  <span class="comment"># 生成目标文件</span></span><br><span class="line">hexo s  <span class="comment"># 本地进行预览，查看效果</span></span><br><span class="line">hexo d  <span class="comment"># 发布到自己的GitHub、Gitee或者其他的仓库中，进行网站页面的部署</span></span><br></pre></td></tr></table></figure>

<h3 id="6-7-为何语言显示不正确？"><a href="#6-7-为何语言显示不正确？" class="headerlink" title="6.7 为何语言显示不正确？"></a>6.7 为何语言显示不正确？</h3><p>修改HEXO的网站配置文件 <code>_config.yml</code> 中的<code>language</code> 字段</p>
<h3 id="6-8-如何关闭新建页面的评论功能？"><a href="#6-8-如何关闭新建页面的评论功能？" class="headerlink" title="6.8 如何关闭新建页面的评论功能？"></a>6.8 如何关闭新建页面的评论功能？</h3><p>当集成了评论系统，如 Disqus，所有新建的页面都将自动开启评论。若不需要评论，在页面的 <code>Front-matter</code> 里添加 <code>comments</code> 字段，并将值设置为 <code>false</code>。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">title: All tags</span><br><span class="line">date: <span class="number">2015</span>-<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">24</span></span><br><span class="line"><span class="keyword">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="built_in">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="6-9-如何设置页面文章的篇数？"><a href="#6-9-如何设置页面文章的篇数？" class="headerlink" title="6.9 如何设置页面文章的篇数？"></a>6.9 如何设置页面文章的篇数？</h3><h3 id="6-10-如何优化-NexT-主题？"><a href="#6-10-如何优化-NexT-主题？" class="headerlink" title="6.10 如何优化 NexT 主题？"></a>6.10 如何优化 NexT 主题？</h3><h3 id="6-11-Cannot-find-module"><a href="#6-11-Cannot-find-module" class="headerlink" title="6.11 Cannot find module"></a>6.11 Cannot find module</h3><h2 id="七、其他平台"><a href="#七、其他平台" class="headerlink" title="七、其他平台"></a>七、其他平台</h2><h3 id="7-1-Farbox"><a href="#7-1-Farbox" class="headerlink" title="7.1 Farbox"></a>7.1 Farbox</h3><p><a href="https://github.com/Sunnyyoung/Farbox-NexT" target="_blank" rel="noopener">Farbox-NexT</a></p>
<h3 id="7-1-Jekyll"><a href="#7-1-Jekyll" class="headerlink" title="7.1 Jekyll"></a>7.1 Jekyll</h3><p><a href="https://github.com/Simpleyyt/jekyll-theme-next" target="_blank" rel="noopener">jekyll-theme-next</a></p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Next主题</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO官方文档学习笔记</title>
    <url>/2018/12/24/HEXO%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>HEXO官方文档学习笔记</p>
<a id="more"></a>

<h2 id="HEXO官方文档学习笔记"><a href="#HEXO官方文档学习笔记" class="headerlink" title="HEXO官方文档学习笔记"></a>HEXO官方文档学习笔记</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p>
<h2 id="一-hexo-开始使用"><a href="#一-hexo-开始使用" class="headerlink" title="一. hexo 开始使用"></a>一. hexo 开始使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote>
<p>环境必须包括 <code>nodejs</code> 与 <code>git</code> ，从对应的官网进行对应的安装；</p>
</blockquote>
<h3 id="1-2-建站（测试生成静态文件并本地运行）"><a href="#1-2-建站（测试生成静态文件并本地运行）" class="headerlink" title="1.2 建站（测试生成静态文件并本地运行）"></a>1.2 建站（测试生成静态文件并本地运行）</h3><blockquote>
<p>执行下面的代码：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:hexo/    <span class="comment">#换成你的目录</span></span><br><span class="line">$ npm install -g hexo-cli  <span class="comment">#安装hexo脚手架</span></span><br><span class="line">$ hexo init     <span class="comment">#Hexo自动在当前文件夹下下载搭建网站所需的所有文件</span></span><br><span class="line">$ npm install   <span class="comment">#安装依赖包</span></span><br><span class="line"></span><br><span class="line">$ hexo g        <span class="comment">#完整命令为hexo generate，生成静态文件</span></span><br><span class="line">$ hexo s        <span class="comment">#完整命令为hexo server，启动服务器，用来本地预览</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成的项目的目录如下，下面对各个目录功能介绍：</p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<ul>
<li>_config.yml：网站的 配置 信息，您可以在此配置大部分的参数；</li>
<li>scaffolds：模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件：<code>hexo new title.md</code></li>
<li>source：资源文件夹是存放用户资源的地方； _posts 文件夹指的是发布文章的文件夹；_drafts为文章的草稿文件夹，除 _posts 文件夹之，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。</li>
<li>themes：主题 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul>
<h3 id="1-3-配置（-config-yml-中修改网站配置）"><a href="#1-3-配置（-config-yml-中修改网站配置）" class="headerlink" title="1.3 配置（_config.yml 中修改网站配置）"></a>1.3 配置（_config.yml 中修改网站配置）</h3><blockquote>
<p>_config.yml 文件中的 <code># Home page setting</code> 在后面介绍;</p>
</blockquote>
<h4 id="1-3-1-网站（-Site）"><a href="#1-3-1-网站（-Site）" class="headerlink" title="1.3.1 网站（# Site）"></a>1.3.1 网站（# Site）</h4><p>参数    | 描述<br>————- | ——————————————- |——————<br>title    | 网站标题<br>subtitle    | 网站副标题<br>description    | 网站描述<br>author    | 您的名字<br>language    | 网站使用的语言<br>timezone    | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p>
<blockquote>
<p>description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p>
</blockquote>
<h4 id="1-3-2-网址（-URL）"><a href="#1-3-2-网址（-URL）" class="headerlink" title="1.3.2 网址（# URL）"></a>1.3.2 网址（# URL）</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>网址</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>网站根目录</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>文章的 永久链接 格式</td>
<td>:year/:month/:day/:title/</td>
</tr>
<tr>
<td>permalink_defaults</td>
<td>永久链接中各部分的默认值</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<h4 id="1-3-3-目录（-Directory）——建议刚学hexo时不改动"><a href="#1-3-3-目录（-Directory）——建议刚学hexo时不改动" class="headerlink" title="1.3.3 目录（# Directory）——建议刚学hexo时不改动"></a>1.3.3 目录（# Directory）——建议刚学hexo时不改动</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>source_dir</td>
<td>资源文件夹，这个文件夹用来存放内容。</td>
<td>source</td>
</tr>
<tr>
<td>public_dir</td>
<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td>public</td>
</tr>
<tr>
<td>tag_dir</td>
<td>标签文件夹</td>
<td>tags</td>
</tr>
<tr>
<td>archive_dir</td>
<td>归档文件夹</td>
<td>archives</td>
</tr>
<tr>
<td>category_dir</td>
<td>分类文件夹</td>
<td>categories</td>
</tr>
<tr>
<td>code_dir</td>
<td>Include code 文件夹</td>
<td>downloads/code</td>
</tr>
<tr>
<td>i18n_dir</td>
<td>国际化（i18n）文件夹</td>
<td>:lang</td>
</tr>
<tr>
<td>skip_render</td>
<td>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-3-4-文章（-Writing）"><a href="#1-3-4-文章（-Writing）" class="headerlink" title="1.3.4 文章（# Writing）"></a>1.3.4 文章（# Writing）</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>new_post_name</td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr>
<td>default_layout</td>
<td>预设布局</td>
<td>post</td>
</tr>
<tr>
<td>auto_spacing</td>
<td>在中文和英文之间加入空格</td>
<td>false</td>
</tr>
<tr>
<td>titlecase</td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr>
<td>external_link</td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td>filename_case</td>
<td>把文件名称转换为 (1) 小写或 (2) 大写</td>
<td>0</td>
</tr>
<tr>
<td>render_drafts</td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr>
<td>post_asset_folder</td>
<td>启动 Asset 文件夹</td>
<td>false</td>
</tr>
<tr>
<td>relative_link</td>
<td>把链接改为与根目录的相对位址</td>
<td>false</td>
</tr>
<tr>
<td>future</td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr>
<td>highlight</td>
<td>代码块的设置</td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-3-5-分类-amp-标签（-Category-amp-Tag）"><a href="#1-3-5-分类-amp-标签（-Category-amp-Tag）" class="headerlink" title="1.3.5 分类 &amp; 标签（# Category &amp; Tag）"></a>1.3.5 分类 &amp; 标签（# Category &amp; Tag）</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>default_category</td>
<td>默认分类</td>
<td>uncategorized</td>
</tr>
<tr>
<td>category_map</td>
<td>分类别名</td>
<td></td>
</tr>
<tr>
<td>tag_map</td>
<td>标签别名</td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-3-6-日期-时间格式（-Date-Time-format）"><a href="#1-3-6-日期-时间格式（-Date-Time-format）" class="headerlink" title="1.3.6 日期 / 时间格式（# Date / Time format）"></a>1.3.6 日期 / 时间格式（# Date / Time format）</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>date_format</td>
<td>日期格式</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td>time_format</td>
<td>时间格式</td>
<td>H:mm:ss</td>
</tr>
</tbody></table>
<blockquote>
<p>Hexo 使用 Moment.js 来解析和显示时间。</p>
</blockquote>
<h4 id="1-3-6-分页（-Pagination）"><a href="#1-3-6-分页（-Pagination）" class="headerlink" title="1.3.6 分页（# Pagination）"></a>1.3.6 分页（# Pagination）</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>per_page</td>
<td>每页显示的文章量 (0 = 关闭分页功能)</td>
<td>10</td>
</tr>
<tr>
<td>pagination_dir</td>
<td>分页目录</td>
<td>page</td>
</tr>
</tbody></table>
<h4 id="1-3-6-扩展（-Extensions）"><a href="#1-3-6-扩展（-Extensions）" class="headerlink" title="1.3.6 扩展（# Extensions）"></a>1.3.6 扩展（# Extensions）</h4><p>参数    | 描述<br>————- | ——————————————- |——————<br>theme |     当前主题名称。值为false时禁用主题<br>deploy    | 部署部分的设置</p>
<h3 id="1-4-命令"><a href="#1-4-命令" class="headerlink" title="1.4 命令"></a>1.4 命令</h3><h4 id="1-4-1-指令"><a href="#1-4-1-指令" class="headerlink" title="1.4.1 指令"></a>1.4.1 指令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init : hexo初始化新建一个网站，没有folder默认当前文件夹建立网站项目，一般是在网站建立文件夹下使用gitBash直接输入 hexo init 进行初始化；</span></span><br><span class="line">$ hexo init [folder]</span><br><span class="line"></span><br><span class="line"><span class="comment"># new : 新建一篇文章，若没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数post代替，如果标题包含空格的话，请使用引号括起来；</span></span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate : 生成静态文件；可选参数：-d, --deploy	文件生成后立即部署网站 ；-w, --watch	监视文件变动</span></span><br><span class="line">$ hexo generate </span><br><span class="line">$ hexo g  <span class="comment">#简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># publish : 发表草稿</span></span><br><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server : 启动服务器，默认网址： http://localhost:4000/。可选参数：-i  重设IP地址;  -p, --port	重设端口；-s, --static	只使用静态文件；-l, --log	启动日记记录，使用覆盖记录格式</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># deploy : 部署网站。可选参数：-g, --generate	部署之前预先生成静态文件</span></span><br><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d  <span class="comment"># 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># render : 渲染文件。可选参数：-o, --output	设置输出路径</span></span><br><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># migrate : 从其他博客系统 迁移内容。</span></span><br><span class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean : 清除缓存文件 (db.json) 和已生成的静态文件 (public)，发布新的网站前应执行该命令。</span></span><br><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># list : 列出网站资料。</span></span><br><span class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># version : 显示 Hexo 版本。</span></span><br><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-选项"><a href="#1-4-2-选项" class="headerlink" title="1.4.2 选项"></a>1.4.2 选项</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安全模式 : 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</span></span><br><span class="line">$ hexo --safe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式 : 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</span></span><br><span class="line">$ hexo --debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简洁模式 : 隐藏终端信息。</span></span><br><span class="line">$ hexo --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义配置文件的路径 : 自定义配置文件的路径，执行后将不再使用 _config.yml。</span></span><br><span class="line">$ hexo --config custom.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示草稿 : 显示 source/_drafts 文件夹中的草稿文章。</span></span><br><span class="line">$ hexo --draft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 CWD : 自定义当前工作目录（Current working directory）的路径。</span></span><br><span class="line">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>

<h2 id="二-基本操作"><a href="#二-基本操作" class="headerlink" title="二. 基本操作"></a>二. 基本操作</h2><h3 id="2-1-写作"><a href="#2-1-写作" class="headerlink" title="2.1 写作"></a>2.1 写作</h3><p>创建一篇新文章的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># layout 表示文章的布局，默认是post，可修改 _config.yml 中的 default_layout 参数来指定默认布局</span></span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-布局（Layout）"><a href="#2-1-1-布局（Layout）" class="headerlink" title="2.1.1 布局（Layout）"></a>2.1.1 布局（Layout）</h4><p>Hexo 有三种默认布局：post、page 和 draft，也可以自定义其他布局，都将储存到 source/_posts 文件夹；</p>
<p>【若不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。】</p>
<h4 id="2-1-2-文件名称"><a href="#2-1-2-文件名称" class="headerlink" title="2.1.2 文件名称"></a>2.1.2 文件名称</h4><p>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td>:year</td>
<td>建立的年份，比如， 2015</td>
</tr>
<tr>
<td>:month</td>
<td>建立的月份（有前导零），比如， 04</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立的月份（无前导零），比如， 4</td>
</tr>
<tr>
<td>:day</td>
<td>建立的日期（有前导零），比如， 07</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立的日期（无前导零），比如， 7</td>
</tr>
</tbody></table>
<h4 id="2-1-3-草稿"><a href="#2-1-3-草稿" class="headerlink" title="2.1.3 草稿"></a>2.1.3 草稿</h4><p>草稿存放在 <code>source/_drafts</code> 目录下，通过 <code>hexo new draft :title</code> 建立，再通过 <code>hexo publish [layout] &lt;title&gt;</code> 来指定布局并发布文章；</p>
<p>【草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。】</p>
<h4 id="2-1-4-模版（Scaffold）"><a href="#2-1-4-模版（Scaffold）" class="headerlink" title="2.1.4 模版（Scaffold）"></a>2.1.4 模版（Scaffold）</h4><p>新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件；<br>例如 ： <code>$ hexo new photo &quot;My Gallery&quot;</code>，表示Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>文件建立日期</td>
</tr>
</tbody></table>
<h3 id="2-2-Front-matter"><a href="#2-2-Front-matter" class="headerlink" title="2.2 Front-matter"></a>2.2 Front-matter</h3><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量；</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2013</span>/<span class="number">7</span>/<span class="number">13</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">25</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-2-1-分类和标签"><a href="#2-2-1-分类和标签" class="headerlink" title="2.2.1 分类和标签"></a>2.2.1 分类和标签</h4><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。Hexo 中的分类具有顺序性和层次性，而标签没有顺序和层次，区别于其他系统；</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-JSON-Front-matter"><a href="#2-2-2-JSON-Front-matter" class="headerlink" title="2.2.2 JSON Front-matter"></a>2.2.2 JSON Front-matter</h4><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line"><span class="string">"title"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line"><span class="string">"date"</span>: <span class="string">"2013/7/13 20:46:25"</span></span><br><span class="line">;;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-标签插件（Tag-Plugins）"><a href="#2-3-标签插件（Tag-Plugins）" class="headerlink" title="2.3 标签插件（Tag Plugins）"></a>2.3 标签插件（Tag Plugins）</h3><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p>
<h4 id="2-3-1-引用块"><a href="#2-3-1-引用块" class="headerlink" title="2.3.1 引用块"></a>2.3.1 引用块</h4><p>在文章中插入引言，可包含作者、来源和标题。</p>
<p><strong>别号： quote</strong></p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：提供参数， 这些参数将会被显示出来</span><br><span class="line">&#123;<span class="comment">% blockquote [author[, source]] [link] [source_link_title] %&#125;</span></span><br><span class="line">content</span><br><span class="line">&#123;<span class="comment">% endblockquote %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：没有提供参数，则只输出普通的 blockquote</span><br><span class="line"></span><br><span class="line">方式<span class="number">3</span>：引用书上的句子</span><br><span class="line">&#123;<span class="comment">% blockquote David Levithan, Wide Awake %&#125;</span></span><br><span class="line">Do <span class="built_in">not</span> just seek happiness for yourself. Seek happiness for <span class="built_in">all</span>. Through kindness. Through mercy.</span><br><span class="line">&#123;<span class="comment">% endblockquote %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">4</span>：引用 Twitter</span><br><span class="line">&#123;<span class="comment">% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</span></span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</span><br><span class="line">&#123;<span class="comment">% endblockquote %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">5</span>：引用网络上的文章</span><br><span class="line">&#123;<span class="comment">% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span></span><br><span class="line">Every interaction <span class="keyword">is</span> both precious and an opportunity to delight.</span><br><span class="line">&#123;<span class="comment">% endblockquote %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-代码块"><a href="#2-3-2-代码块" class="headerlink" title="2.3.2 代码块"></a>2.3.2 代码块</h4><p>在文章中插入代码。</p>
<p><strong>别名： code</strong></p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：提供参数， 这些参数将会被显示出来</span><br><span class="line">&#123;<span class="comment">% codeblock [title] [lang:language] [url] [link text] %&#125;</span></span><br><span class="line">code snippet</span><br><span class="line">&#123;<span class="comment">% endcodeblock %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：普通的代码块</span><br><span class="line">&#123;<span class="comment">% codeblock %&#125;</span></span><br><span class="line">alert(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#123;<span class="comment">% endcodeblock %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">3</span>：指定语言</span><br><span class="line">&#123;<span class="comment">% codeblock lang:objc %&#125;</span></span><br><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br><span class="line">&#123;<span class="comment">% endcodeblock %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">4</span>：附加说明</span><br><span class="line">&#123;<span class="comment">% codeblock Array.map %&#125;</span></span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;<span class="comment">% endcodeblock %&#125;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">5</span>：附加说明和网址</span><br><span class="line">&#123;<span class="comment">% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;</span></span><br><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">=&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;<span class="comment">% endcodeblock %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-反引号代码块-类似md中的代码块格式"><a href="#2-3-3-反引号代码块-类似md中的代码块格式" class="headerlink" title="2.3.3 反引号代码块(类似md中的代码块格式)"></a>2.3.3 反引号代码块(类似md中的代码块格式)</h4><p>它使用三个反引号来包裹;</p>
<figure class="highlight plain"><figcaption><span>[title] [url] [link text] code snippet ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.3.4 Pull Quote</span><br><span class="line">在文章中插入 Pull quote。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;m</span><br><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-jsFiddle"><a href="#2-3-5-jsFiddle" class="headerlink" title="2.3.5 jsFiddle"></a>2.3.5 jsFiddle</h4><p>在文章中嵌入 jsFiddle。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-Gist"><a href="#2-3-6-Gist" class="headerlink" title="2.3.6 Gist"></a>2.3.6 Gist</h4><p>在文章中嵌入 Gist。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% gist gist_id [filename] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-7-iframe"><a href="#2-3-7-iframe" class="headerlink" title="2.3.7 iframe"></a>2.3.7 iframe</h4><p>在文章中插入 iframe。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% iframe url [width] [height] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-8-Image"><a href="#2-3-8-Image" class="headerlink" title="2.3.8 Image"></a>2.3.8 Image</h4><p>在文章中插入指定大小的图片。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-9-Link"><a href="#2-3-9-Link" class="headerlink" title="2.3.9 Link"></a>2.3.9 Link</h4><p>在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% link text url [external] [title] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-10-Include-Code"><a href="#2-3-10-Include-Code" class="headerlink" title="2.3.10 Include Code"></a>2.3.10 Include Code</h4><p>插入 source 文件夹内的代码文件。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% include_code [title] [lang:language] path/to/file %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-11-Youtube"><a href="#2-3-11-Youtube" class="headerlink" title="2.3.11 Youtube"></a>2.3.11 Youtube</h4><p>在文章中插入 Youtube 视频。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% youtube video_id %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-12-Vimeo"><a href="#2-3-12-Vimeo" class="headerlink" title="2.3.12 Vimeo"></a>2.3.12 Vimeo</h4><p>在文章中插入 Vimeo 视频。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% vimeo video_id %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-13-引用文章"><a href="#2-3-13-引用文章" class="headerlink" title="2.3.13 引用文章"></a>2.3.13 引用文章</h4><p>引用其他文章的链接。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% post_path slug %&#125;</span></span><br><span class="line">&#123;<span class="comment">% post_link slug [title] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-14-引用资源"><a href="#2-3-14-引用资源" class="headerlink" title="2.3.14 引用资源"></a>2.3.14 引用资源</h4><p>引用文章的资源。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% asset_path slug %&#125;</span></span><br><span class="line">&#123;<span class="comment">% asset_img slug [title] %&#125;</span></span><br><span class="line">&#123;<span class="comment">% asset_link slug [title] %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-15-Raw"><a href="#2-3-15-Raw" class="headerlink" title="2.3.15 Raw"></a>2.3.15 Raw</h4><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% raw %&#125;</span></span><br><span class="line">content</span><br><span class="line">&#123;<span class="comment">% endraw %&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-4-资源文件夹"><a href="#2-4-资源文件夹" class="headerlink" title="2.4 资源文件夹"></a>2.4 资源文件夹</h3><p>资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。</p>
<h4 id="2-4-1-文章资源文件夹"><a href="#2-4-1-文章资源文件夹" class="headerlink" title="2.4.1 文章资源文件夹"></a>2.4.1 文章资源文件夹</h4><p>将 config.yml 文件中的 <code>post_asset_folder</code> 选项设为 true 来打开，有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上；当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 <code>markdown 文件一样的名字</code>。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<h4 id="2-4-2-相对路径引用的标签插件"><a href="#2-4-2-相对路径引用的标签插件" class="headerlink" title="2.4.2 相对路径引用的标签插件"></a>2.4.2 相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。<br>Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。<br>正确的引用图片方式是使用下列的标签插件而不是 markdown 语法 <code>![](/example.jpg)</code>：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% asset_path slug %&#125;</span></span><br><span class="line">&#123;<span class="comment">% asset_img slug [title] %&#125;</span></span><br><span class="line">&#123;<span class="comment">% asset_link slug [title] %&#125;</span></span><br><span class="line"></span><br><span class="line">通过下面这种方式，图片将会同时出现在文章和主页以及归档页中。</span><br><span class="line">&#123;<span class="comment">% asset_img example.jpg This is an example image %&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-数据文件夹"><a href="#2-5-数据文件夹" class="headerlink" title="2.5 数据文件夹"></a>2.5 数据文件夹</h3><p>有时候可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 <code>source/_data</code> 内的 <code>YAML 或 JSON</code> 文件，如此一来您便能在网站中复用这些文件；<br>例子：在 source/_data 文件夹中新建 menu.yml 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Home: &#x2F;</span><br><span class="line">Gallery: &#x2F;gallery&#x2F;</span><br><span class="line">Archives: &#x2F;archives&#x2F;</span><br></pre></td></tr></table></figure>

<p>就能在模板中使用这些资料：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (<span class="keyword">var</span> link <span class="keyword">in</span> site.data.menu) &#123; %&gt;</span><br><span class="line">  &lt;a href=<span class="string">"&lt;%= site.data.menu[link] %&gt;"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">link</span> %&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"/"</span>&gt; Home &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;a href="/g</span>allery/<span class="string">"&gt; Gallery &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;a href="</span>/archives/<span class="string">"&gt; Archives &lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-服务器（本地预览效果）"><a href="#2-6-服务器（本地预览效果）" class="headerlink" title="2.6 服务器（本地预览效果）"></a>2.6 服务器（本地预览效果）</h3><p>Hexo 3.0 把服务器独立成了个别模块，安装 hexo-server 才能使用：<code>npm install hexo-server --save</code>；安装完后执行 <code>hexo server</code>启动服务器，也可以改变一些参数，参考<code>命令-&gt;指令</code>的知识；</p>
<h4 id="2-6-1-静态模式-amp-amp-自定义-IP"><a href="#2-6-1-静态模式-amp-amp-自定义-IP" class="headerlink" title="2.6.1 静态模式 &amp;&amp; 自定义 IP"></a>2.6.1 静态模式 &amp;&amp; 自定义 IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate;</span></span><br><span class="line">$ hexo server -s</span><br><span class="line"><span class="comment"># 自定义 IP地址，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP； hexo server -i 127.0.0.1 -p 5000</span></span><br><span class="line">$ hexo server -i 192.168.1.1</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-Pow（略）"><a href="#2-6-2-Pow（略）" class="headerlink" title="2.6.2 Pow（略）"></a>2.6.2 Pow（略）</h4><p>Pow 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。</p>
<h3 id="2-7-生成器"><a href="#2-7-生成器" class="headerlink" title="2.7 生成器"></a>2.7 生成器</h3><p>Hexo 生成静态文件指令：<code>$ hexo generate</code>，参考<code>命令-&gt;指令</code>的知识；</p>
<h4 id="监视文件变动-amp-amp-完成后部署"><a href="#监视文件变动-amp-amp-完成后部署" class="headerlink" title="监视文件变动 &amp;&amp; 完成后部署"></a>监视文件变动 &amp;&amp; 完成后部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入；</span></span><br><span class="line">$ hexo generate --watch</span><br><span class="line"><span class="comment"># 在生成完毕后自动部署网站，下面两个命令的作用是相同的。</span></span><br><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br><span class="line"><span class="comment"># 上面命令的简介形式</span></span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>


<h3 id="2-8-部署"><a href="#2-8-部署" class="headerlink" title="2.8 部署"></a>2.8 部署</h3><p>Hexo 通过指令 <code>$ hexo deploy</code> 实现网站部署到指定的服务器中，在执行此命令前要对网站根目录下的 <code>_config.yml</code> 中修改参数（<strong>注意yml文件格式</strong>），见下方实现 <code>gitee pages</code> 部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@gitee.com:geekleng/hexoblog.git     <span class="comment">#发布到gitee,还可以加上github Page 页面</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>部署多个 deployer，Hexo 会依照顺序执行每个 deployer:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">- <span class="built_in">type</span>: heroku</span><br><span class="line">  repo:</span><br></pre></td></tr></table></figure>
<p>【YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。】</p>
<h4 id="2-8-1-Git"><a href="#2-8-1-Git" class="headerlink" title="2.8.1 Git"></a>2.8.1 Git</h4><ul>
<li>先安装 <code>hexo-deployer-git</code> 包：<code>$ npm install hexo-deployer-git --save</code></li>
<li>修改<code>_config.yml</code> 中参数；<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>repo</td>
<td>库（Repository）地址</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息 (默认为 Site updated 当前时间: YYYY-MM-DD HH:mm:ss)</td>
</tr>
</tbody></table>
<h2 id="三-自定义"><a href="#三-自定义" class="headerlink" title="三. 自定义"></a>三. 自定义</h2><h3 id="3-1-永久链接"><a href="#3-1-永久链接" class="headerlink" title="3.1 永久链接"></a>3.1 永久链接</h3><p>可以在HEXO网站配置文件 <code>_config.yml</code> 配置中调整网站的永久链接或者在每篇文章的 <code>Front-matter</code> 中指定。</p>
<h4 id="3-1-1-变量"><a href="#3-1-1-变量" class="headerlink" title="3.1.1 变量"></a>3.1.1 变量</h4><p>使用下面的变量或是使用 <code>Front-matter</code> 中的所有属性；</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:year</td>
<td>文章的发表年份（4 位数）</td>
</tr>
<tr>
<td>:month</td>
<td>文章的发表月份（2 位数）</td>
</tr>
<tr>
<td>:i_month</td>
<td>文章的发表月份（去掉开头的零）</td>
</tr>
<tr>
<td>:day</td>
<td>文章的发表日期 (2 位数)</td>
</tr>
<tr>
<td>:i_day</td>
<td>文章的发表日期（去掉开头的零）</td>
</tr>
<tr>
<td>:title</td>
<td>文件名称</td>
</tr>
<tr>
<td>:post_title</td>
<td>文章标题</td>
</tr>
<tr>
<td>:id</td>
<td>文章 ID</td>
</tr>
<tr>
<td>:category</td>
<td>分类。如果文章没有分类，则是 default_category 配置信息。</td>
</tr>
</tbody></table>
<p>或在 <code>permalink_defaults</code> 参数下调整永久链接中各变量的默认值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">permalink_defaults:</span><br><span class="line">  lang: en</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-多语种支持"><a href="#3-1-2-多语种支持" class="headerlink" title="3.1.2 多语种支持"></a>3.1.2 多语种支持</h4><p>若要建立一个多语种的网站，您可修改 new_post_name 和 permalink 参数，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new_post_name: :lang/:title.md  <span class="comment"># 新的博文的文件名</span></span><br><span class="line">permalink: :lang/:title/  <span class="comment"># 生成的链接的格式。带井号的是默认的格式；规则也比较简单，标签前面要加英文冒号。</span></span><br></pre></td></tr></table></figure>
<p>当您建立新文章时，文章会被储存到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"Hello World"</span> --lang tw</span><br><span class="line"><span class="comment"># =&gt; source/_posts/tw/Hello-World.md</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-主题"><a href="#3-2-主题" class="headerlink" title="3.2 主题"></a>3.2 主题</h3><p>在HEXO的官网上找到合适的主题，下载压缩包解压到 <code>themes</code> 文件夹中或者是由git直接下载对应主题的包，再修改HEXO网站配置文件 <code>_config.yml</code> 配置中 <code>theme</code> 字段即可；主题的文件架构如下：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-config-yml"><a href="#3-2-1-config-yml" class="headerlink" title="3.2.1 _config.yml"></a>3.2.1 _config.yml</h4><p>主题的配置文件。修改时会自动更新，无需重启服务器。</p>
<h4 id="3-2-2-languages"><a href="#3-2-2-languages" class="headerlink" title="3.2.2 languages"></a>3.2.2 languages</h4><p>语言文件夹；<a href="https://hexo.io/zh-cn/docs/internationalization" target="_blank" rel="noopener">HEXO国际化-i18n</a></p>
<h4 id="3-2-3-layout"><a href="#3-2-3-layout" class="headerlink" title="3.2.3 layout"></a>3.2.3 layout</h4><p>布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，可以另外安装插件来获得 EJS、Haml 或 Jade 支持；<a href="https://hexo.io/zh-cn/docs/templates" target="_blank" rel="noopener">HEXO模板</a></p>
<h4 id="3-2-4-scripts"><a href="#3-2-4-scripts" class="headerlink" title="3.2.4 scripts"></a>3.2.4 scripts</h4><p>脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件；<a href="https://hexo.io/zh-cn/docs/plugins" target="_blank" rel="noopener">HEXO插件</a></p>
<h4 id="3-2-5-source"><a href="#3-2-5-source" class="headerlink" title="3.2.5 source"></a>3.2.5 source</h4><p>资源文件夹，除了模板以外的 <code>Asset</code>，例如 <code>CSS、JavaScript</code> 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 <code>_（下划线线）</code> 或隐藏的文件会被忽略。</p>
<h3 id="3-3-模版"><a href="#3-3-模版" class="headerlink" title="3.3 模版"></a>3.3 模版</h3><p>模板决定了网站内容的呈现方式，以下是各页面相对应的模板名称：<br>模板    | 用途    | 回退<br>—– | —– | —–<br>index    | 首页<br>post    | 文章    | index<br>page    | 分页    | index<br>archive    | 归档    | index<br>category    | 分类归档    | archive<br>tag    标签归档    archive</p>
<h4 id="3-3-1-布局（Layout）"><a href="#3-3-1-布局（Layout）" class="headerlink" title="3.3.1 布局（Layout）"></a>3.3.1 布局（Layout）</h4><p>若页面结构类似，可以通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&gt;index.ejs 文件&lt;--&gt;</span></span><br><span class="line">index</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;layout.ejs 文件&lt;--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;生成文件&lt;--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>index<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个模板都默认使用 layout 布局，您可在 <code>front-matter</code> 指定其他布局，或是设为 <code>false</code> 来关闭布局功能，甚至可在布局中再使用其他布局来建立嵌套布局。</p>
<h4 id="3-3-2-局部模版（Partial）"><a href="#3-3-2-局部模版（Partial）" class="headerlink" title="3.3.2 局部模版（Partial）"></a>3.3.2 局部模版（Partial）</h4><p>局部模板让您在不同模板之间共享相同的组件,可利用局部模板功能分割为个别文件，让维护更加便利。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&gt;partial/header.ejs文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;index.ejs文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">partial</span>/<span class="attr">header</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>Home page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;生成文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"logo"</span>&gt;</span>My Site<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>Home page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量</strong>：局部模板中指定局部变量并使用；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&gt;partial/header.ejs文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;index.ejs文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">partial</span>/<span class="attr">header</span>', &#123;<span class="attr">title:</span> '<span class="attr">Hello</span> <span class="attr">World</span>'&#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>Home page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&gt;生成文件&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"logo"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>Home page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-优化"><a href="#3-3-3-优化" class="headerlink" title="3.3.3 优化"></a>3.3.3 优化</h4><p>考虑使用 Hexo 2.7 新增的局部缓存（Fragment Caching） 功能，功能借鉴于 Ruby on Rails，它储存局部内容，下次便能直接使用缓存内容，可以减少文件夹查询并使生成速度更快。可用于页首、页脚、侧边栏等文件不常变动的位置；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">fragment_cache</span>('<span class="attr">header</span>', <span class="attr">function</span>()&#123;</span></span><br><span class="line">  return '&lt;header&gt;&lt;/header&gt;';</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果您使用局部模板的话，可以更简单：</p>
<p><code>&lt;%- partial(&#39;header&#39;, {}, {cache: true});</code></p>
<p>【注意：若开启了 <code>relative_link</code> 参数(把链接改为与根目录的相对位址)，请勿使用局部缓存功能，因为相对链接在每个页面可能不同】</p>
<h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><h4 id="3-4-1-全局变量"><a href="#3-4-1-全局变量" class="headerlink" title="3.4.1 全局变量"></a>3.4.1 全局变量</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>site</td>
<td>网站变量</td>
</tr>
<tr>
<td>page</td>
<td>针对该页面的内容以及 front-matter 所设定的变量。</td>
</tr>
<tr>
<td>config</td>
<td>网站配置</td>
</tr>
<tr>
<td>theme</td>
<td>主题配置。继承自网站配置。</td>
</tr>
<tr>
<td>_ (单下划线)</td>
<td>Lodash 函数库</td>
</tr>
<tr>
<td>path</td>
<td>当前页面的路径（不含根路径）</td>
</tr>
<tr>
<td>url</td>
<td>当前页面的完整网址</td>
</tr>
<tr>
<td>env</td>
<td>环境变量</td>
</tr>
</tbody></table>
<h4 id="3-4-2-网站变量"><a href="#3-4-2-网站变量" class="headerlink" title="3.4.2 网站变量"></a>3.4.2 网站变量</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>site.posts</td>
<td>所有文章</td>
</tr>
<tr>
<td>site.pages</td>
<td>所有分页</td>
</tr>
<tr>
<td>site.categories</td>
<td>所有分类</td>
</tr>
<tr>
<td>site.tags</td>
<td>所有标签</td>
</tr>
</tbody></table>
<h4 id="3-4-3-页面变量"><a href="#3-4-3-页面变量" class="headerlink" title="3.4.3 页面变量"></a>3.4.3 页面变量</h4><p><strong>页面（page）</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.title</td>
<td>页面标题</td>
</tr>
<tr>
<td>page.date</td>
<td>页面建立日期（Moment.js 对象）</td>
</tr>
<tr>
<td>page.updated</td>
<td>页面更新日期（Moment.js 对象）</td>
</tr>
<tr>
<td>page.comments</td>
<td>留言是否开启</td>
</tr>
<tr>
<td>page.layout</td>
<td>布局名称</td>
</tr>
<tr>
<td>page.content</td>
<td>页面的完整内容</td>
</tr>
<tr>
<td>page.excerpt</td>
<td>页面摘要</td>
</tr>
<tr>
<td>page.more</td>
<td>除了页面摘要的其余内容</td>
</tr>
<tr>
<td>page.source</td>
<td>页面原始路径</td>
</tr>
<tr>
<td>page.full_source</td>
<td>页面的完整原始路径</td>
</tr>
<tr>
<td>page.path</td>
<td>页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。</td>
</tr>
<tr>
<td>page.permalink</td>
<td>页面的完整网址</td>
</tr>
<tr>
<td>page.prev</td>
<td>上一个页面。如果此为第一个页面则为 null。</td>
</tr>
<tr>
<td>page.next</td>
<td>下一个页面。如果此为最后一个页面则为 null。</td>
</tr>
<tr>
<td>page.raw</td>
<td>文章的原始内容</td>
</tr>
<tr>
<td>page.photos</td>
<td>文章的照片（用于相簿）</td>
</tr>
<tr>
<td>page.link</td>
<td>文章的外部链接（用于链接文章）</td>
</tr>
</tbody></table>
<p><strong>文章 (post)</strong>: 和 page 布局类似，但是添加了下列变量。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.published</td>
<td>如果该文章已发布则为True</td>
</tr>
<tr>
<td>page.categories</td>
<td>该文章的所有分类</td>
</tr>
<tr>
<td>page.tags</td>
<td>该文章的所有标签</td>
</tr>
</tbody></table>
<p><strong>首页（index）</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.per_page</td>
<td>每页显示的文章数量</td>
</tr>
<tr>
<td>page.total</td>
<td>总文章数</td>
</tr>
<tr>
<td>page.current</td>
<td>目前页数</td>
</tr>
<tr>
<td>page.current_url</td>
<td>目前分页的网址</td>
</tr>
<tr>
<td>page.posts</td>
<td>本页文章</td>
</tr>
<tr>
<td>page.prev</td>
<td>上一页的页数。如果此页是第一页的话则为 0。</td>
</tr>
<tr>
<td>page.prev_link</td>
<td>上一页的网址。如果此页是第一页的话则为 ‘’。</td>
</tr>
<tr>
<td>page.next</td>
<td>下一页的页数。如果此页是最后一页的话则为 0。</td>
</tr>
<tr>
<td>page.next_link</td>
<td>下一页的网址。如果此页是最后一页的话则为 ‘’。</td>
</tr>
<tr>
<td>page.path</td>
<td>当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。</td>
</tr>
</tbody></table>
<p><strong>归档 (archive)</strong>：与 index 布局相同，但新增以下变量。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.archive</td>
<td>等于 true</td>
</tr>
<tr>
<td>page.year</td>
<td>年份归档 (4位)</td>
</tr>
<tr>
<td>page.month</td>
<td>月份归档 (没有前导零的2位数)</td>
</tr>
</tbody></table>
<p><strong>分类 (category)</strong>：与 index 布局相同，但新增以下变量。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.category</td>
<td>分类名称</td>
</tr>
</tbody></table>
<p><strong>标签 (tag)</strong>：与 index 布局相同，但新增以下变量。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>page.tag</td>
<td>标签名称</td>
</tr>
</tbody></table>
<h3 id="3-5-辅助函数——重难点"><a href="#3-5-辅助函数——重难点" class="headerlink" title="3.5 辅助函数——重难点"></a>3.5 辅助函数——重难点</h3><p><a href="https://hexo.io/zh-cn/docs/helpers" target="_blank" rel="noopener">HEXO辅助函数官方文档</a></p>
<p>辅助函数帮助您在模版中快速插入内容。</p>
<h3 id="3-6-国际化-i18n"><a href="#3-6-国际化-i18n" class="headerlink" title="3.6 国际化 (i18n)"></a>3.6 国际化 (i18n)</h3><p>HEXO的网站配置文件 <code>_config.yml</code> 中调整 <code>language</code> 字段值的设定，可设定多个语言来调整预设语言的顺位。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">language: </span><br><span class="line">- zh-tw</span><br><span class="line">- en</span><br></pre></td></tr></table></figure>

<h4 id="3-6-1-语言文件"><a href="#3-6-1-语言文件" class="headerlink" title="3.6.1 语言文件"></a>3.6.1 语言文件</h4><p>语言文件可以使用 YAML 或 JSON 编写，并放在主题文件夹中的 languages 文件夹。</p>
<h4 id="3-6-模板"><a href="#3-6-模板" class="headerlink" title="3.6. 模板"></a>3.6. 模板</h4><p>在模板中，透过 __ 或 _p 辅助函数，即可取得翻译后的字符串，前者用于一般使用；而后者用于复数字符串。</p>
<h4 id="3-6-3-路径"><a href="#3-6-3-路径" class="headerlink" title="3.6.3 路径"></a>3.6.3 路径</h4><p>可在 <code>front-matter</code> 中指定该页面的语言，也可在 <code>_config.yml</code> 中修改 <code>i18n_dir</code> 设定，让 Hexo 自动侦测。</p>
<p>i18n_dir 的预设值是 :lang：<code>i18n_dir: :lang</code>，Hexo 会捕获网址中的第一段以检测语言，举例来说：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">/index.html <span class="built_in">=&gt;</span> en</span><br><span class="line">/archives/index.html <span class="built_in">=&gt;</span> en</span><br><span class="line">/zh-tw/index.html <span class="built_in">=&gt;</span> zh-tw</span><br></pre></td></tr></table></figure>

<h3 id="3-7-插件"><a href="#3-7-插件" class="headerlink" title="3.7 插件"></a>3.7 插件</h3><h4 id="3-7-1-脚本（Scripts）"><a href="#3-7-1-脚本（Scripts）" class="headerlink" title="3.7.1 脚本（Scripts）"></a>3.7.1 脚本（Scripts）</h4><p>若代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。</p>
<h4 id="3-7-2-插件（Packages）"><a href="#3-7-2-插件（Packages）" class="headerlink" title="3.7.2 插件（Packages）"></a>3.7.2 插件（Packages）</h4><p>编写自己的插件；首先，在 <code>node_modules</code> 文件夹中建立文件夹，文件夹名称开头必须为 <code>hexo-</code>，如此一来 <code>Hexo</code> 才会在启动时载入否则 Hexo 将会忽略它。<br><br>文件夹内至少要包含 2 个文件：一个是主程序 <code>index.js</code> ，另一个是 <code>package.json</code> （至少包含name, version, main 属性），描述插件的用途和所依赖的插件。</p>
<h4 id="3-7-3-工具"><a href="#3-7-3-工具" class="headerlink" title="3.7.3 工具"></a>3.7.3 工具</h4><p>Hexo 提供的官方工具插件来加速开发：(可在npm上看各自包的用法)</p>
<ul>
<li>hexo-fs：文件 IO</li>
<li>hexo-util：工具程式</li>
<li>hexo-i18n：本地化（i18n）</li>
<li>hexo-pagination：生成分页资料</li>
</ul>
<h4 id="3-7-4-发布"><a href="#3-7-4-发布" class="headerlink" title="3.7.4 发布"></a>3.7.4 发布</h4><p>发布你的插件到 <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">HEXO插件列表</a></p>
<ol>
<li>Fork <a href="https://github.com/hexojs/site" target="_blank" rel="noopener">hexojs/site</a></li>
<li>把库（repository）复制到电脑上，并安装所依赖的插件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/&lt;username&gt;/site.git</span><br><span class="line">$ <span class="built_in">cd</span> site</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编辑 source/_data/plugins.yml，在档案中新增您的插件，例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- name: hexo-server</span><br><span class="line">  description: Server module <span class="keyword">for</span> Hexo.</span><br><span class="line">  link: https://github.com/hexojs/hexo-server</span><br><span class="line">  tags:</span><br><span class="line">    - official</span><br><span class="line">    - server</span><br><span class="line">    - console</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>推送（push）分支。</li>
<li>建立一个新的合并申请（pull request）并描述改动。</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue入门——黑马程序员</title>
    <url>/2018/12/22/Vue%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
    <content><![CDATA[<p>Vue入门学习课程的笔记</p>
<a id="more"></a>

<h1 id="Vue入门——黑马程序员"><a href="#Vue入门——黑马程序员" class="headerlink" title="Vue入门——黑马程序员"></a>Vue入门——黑马程序员</h1><blockquote>
<p><a href="https://www.bilibili.com/video/av27786601" target="_blank" rel="noopener">黑马程序员Vue入门教程视频</a></p>
</blockquote>
<h1 id="一、vue历史介绍"><a href="#一、vue历史介绍" class="headerlink" title="一、vue历史介绍"></a>一、vue历史介绍</h1><h2 id="1-1-vue介绍"><a href="#1-1-vue介绍" class="headerlink" title="1.1 vue介绍"></a>1.1 vue介绍</h2><p>vue于2014年诞生,作者： 尤雨溪</p>
<h2 id="1-2-Vue核心概念："><a href="#1-2-Vue核心概念：" class="headerlink" title="1.2 Vue核心概念："></a>1.2 Vue核心概念：</h2><p>组件化 、双向数据流（基于ES5 <code>defineProperty</code> 来实现的）</p>
<p>Vue代码结构：template、style、script</p>
<h2 id="1-3-Angular核心概念："><a href="#1-3-Angular核心概念：" class="headerlink" title="1.3 Angular核心概念："></a>1.3 Angular核心概念：</h2><p>模块化 、双向数据绑定（脏检测：一个数组 <code>$watch</code>）</p>
<h2 id="1-4-框架对比：学完再看（Vue官网里面）"><a href="#1-4-框架对比：学完再看（Vue官网里面）" class="headerlink" title="1.4 框架对比：学完再看（Vue官网里面）"></a>1.4 框架对比：学完再看（Vue官网里面）</h2><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">Vue 对比其他框架</a></p>
</blockquote>
<h2 id="1-5-双向数据流"><a href="#1-5-双向数据流" class="headerlink" title="1.5 双向数据流"></a>1.5 双向数据流</h2><blockquote>
<p>js内存属性发生变化，影响到页面的变化；页面的变化影响js内存属性的改变；</p>
</blockquote>
<h1 id="二、常用指令"><a href="#二、常用指令" class="headerlink" title="二、常用指令"></a>二、常用指令</h1><h2 id="2-1-常见指令"><a href="#2-1-常见指令" class="headerlink" title="2.1 常见指令"></a>2.1 常见指令</h2><ul>
<li>v-test   是元素的innerText只能在双标签中使用</li>
<li>v-html   是元素的innerHTML，不能包含插值表达式：</li>
<li>v-if     元素是否移除或是引入</li>
<li>v-show   元素是否显示或隐藏（display属性）</li>
<li>v-model  元素数据的双向绑定</li>
<li>v-bind   数据单项绑定（内存js改变影响页面）</li>
</ul>
<h1 id="三、服务器启动"><a href="#三、服务器启动" class="headerlink" title="三、服务器启动"></a>三、服务器启动</h1><p>修改 package.json 中的 script 标签，<code>dev</code> 中加入端口号：<code>--port 8888</code></p>
<h1 id="四、v-bind-的使用"><a href="#四、v-bind-的使用" class="headerlink" title="四、v-bind 的使用"></a>四、v-bind 的使用</h1><blockquote>
<p><code>v-bind</code> 用于数据的单项绑定，可以绑定元素的属性等内容；</p>
</blockquote>
<h2 id="4-1-根据可变的表达式的结果给class赋值，用-v-bind-class-“xxx”；"><a href="#4-1-根据可变的表达式的结果给class赋值，用-v-bind-class-“xxx”；" class="headerlink" title="4.1 根据可变的表达式的结果给class赋值，用 v-bind:class= “xxx”；"></a>4.1 根据可变的表达式的结果给class赋值，用 v-bind:class= “xxx”；</h2><blockquote>
<p>v-bind:属性名= “表达式”，最终表达式运算结束的结果赋值给该属性名；<br><br>class 的结果样式分类（见上面代码）：<br>    - 一个样式：返回字符串（三元表达式和 key 和 样式的清单对象）<br>    - 多个样式：返回对象（样式做key，true或false赋值）</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"isRed? 'red':'green'"</span>&gt;</span></span><br><span class="line">   单个class</span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span> =<span class="string">"&#123;'green':true,'big':true&#125;"</span>&gt;</span></span><br><span class="line">  多个Class</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="五、methods-和-v-on-指令"><a href="#五、methods-和-v-on-指令" class="headerlink" title="五、methods 和 v-on 指令"></a>五、methods 和 v-on 指令</h1><h2 id="5-1-在MyApp2-vue-上面增加一个-button-按钮，进行测试；例：v-on-click-”change”"><a href="#5-1-在MyApp2-vue-上面增加一个-button-按钮，进行测试；例：v-on-click-”change”" class="headerlink" title="5.1 在MyApp2.vue 上面增加一个 button 按钮，进行测试；例：v-on:click=”change”"></a>5.1 在MyApp2.vue 上面增加一个 button 按钮，进行测试；例：v-on:click=”change”</h2><blockquote>
<p>v-on 指令四调用格式：<code>v-on:事件名=&quot;表达式 || 函数名&quot;</code>，可以简写为：<code>@事件名=&quot;表达式 || 函数名&quot;</code>；若函数无参数，可以省略(),只给函数名就行；</p>
</blockquote>
<p>声明组件内函数，在 <code>export default</code> 这个对象的根属性上加 <code>methods</code> 属性，其中的对象：key 是函数名，value 值是函数体；而根属性上的 <code>data</code> 属性，其实是一个函数，返回一个对象：对象属性是我们初始化变量的名称；</p>
<p><strong>注意</strong>：</p>
<ol>
<li>理解data属性是一个函数，返回一个对象，而不是直接定义成对象的原因；</li>
<li>只要是在 script 中使用的变量或方法都需要加上 <code>this</code> 关键字；</li>
</ol>
<h1 id="六、v-for-指令"><a href="#六、v-for-指令" class="headerlink" title="六、v-for 指令"></a>六、v-for 指令</h1><h2 id="6-1-可以单独使用操作数组-item-index"><a href="#6-1-可以单独使用操作数组-item-index" class="headerlink" title="6.1 可以单独使用操作数组 (item,index)"></a>6.1 可以单独使用操作数组 (item,index)</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- student是一个数组对象[&#123;...&#125;, &#123;...&#125;] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(stu,index) in student"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  index:&#123;&#123;index&#125;&#125;,stu:&#123;&#123;stu.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-可以使用操作对象-value-key-index"><a href="#6-2-可以使用操作对象-value-key-index" class="headerlink" title="6.2 可以使用操作对象 (value,key,index)"></a>6.2 可以使用操作对象 (value,key,index)</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- person是一个对象&#123;...&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(value, key, index) in person"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  key:&#123;&#123;key&#125;&#125;</span><br><span class="line">  value:&#123;&#123;value&#125;&#125;</span><br><span class="line">  index:&#123;&#123;index&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-key-属性必须绑定的原理："><a href="#6-3-key-属性必须绑定的原理：" class="headerlink" title="6.3 key 属性必须绑定的原理："></a>6.3 key 属性必须绑定的原理：</h2><p>key 类似于 trank by 的一个属性，作用是告诉Vue.js中的元素于页面之间的关联，当识别删除元素时，是单个元素的删除，非全部，所以需要关联关系（key 必须设置）</p>
<h1 id="七、列表的增删"><a href="#七、列表的增删" class="headerlink" title="七、列表的增删"></a>七、列表的增删</h1><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;!-- 只有一个根节点 --&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">     &lt;li</span><br><span class="line">        v-for<span class="built_in">=</span><span class="string">"(hero,index) in heros"</span></span><br><span class="line">        v-bind:key<span class="built_in">=</span><span class="string">"index"</span></span><br><span class="line">        v-bind:class<span class="built_in">=</span><span class="string">"&#123;'A':'red','B':'green','C':'blue','D':'pink'&#125;[hero.score]"</span></span><br><span class="line">     &gt;</span><br><span class="line">      &#123;&#123;hero.name&#125;&#125;:&#123;&#123;hero.score&#125;&#125;</span><br><span class="line">      &lt;button v-on:click<span class="built_in">=</span> <span class="string">"del(index)"</span>&gt;delete&lt;/button&gt;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   Hero Name: &lt;input <span class="keyword">type</span><span class="built_in">=</span><span class="string">"text"</span> name<span class="built_in">=</span> <span class="string">""</span> v-model<span class="built_in">=</span><span class="string">"name"</span>&gt;&lt;br&gt;</span><br><span class="line">   Hero Score: &lt;input <span class="keyword">type</span><span class="built_in">=</span><span class="string">"text"</span> name<span class="built_in">=</span> <span class="string">""</span>  v-model<span class="built_in">=</span><span class="string">"score"</span>&gt;&lt;br&gt;</span><br><span class="line">   &lt;button v-on:click<span class="built_in">=</span> <span class="string">"add"</span> &gt;添加 hero&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">//列表的增删功能：类似于 todolist</span><br><span class="line">export default &#123;</span><br><span class="line">  name: <span class="string">""</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:<span class="string">''</span>,</span><br><span class="line">      score:<span class="string">''</span>,</span><br><span class="line">      heros:[</span><br><span class="line">        &#123;id:<span class="number">1</span>,name:<span class="string">'aaa'</span>,score:<span class="string">'A'</span>&#125;,</span><br><span class="line">        &#123;id:<span class="number">2</span>,name:<span class="string">'bbb'</span>,score:<span class="string">'B'</span>&#125;,</span><br><span class="line">        &#123;id:<span class="number">3</span>,name:<span class="string">'ccc'</span>,score:<span class="string">'C'</span>&#125;,</span><br><span class="line">        &#123;id:<span class="number">4</span>,name:<span class="string">'ddd'</span>,score:<span class="string">'D'</span>&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  //声明函数,属于组件对象的</span><br><span class="line">  methods:&#123;</span><br><span class="line">    // 包含多个函数，函数名做 key ，函数体做 value</span><br><span class="line">    change()&#123;</span><br><span class="line">      //在script 中能使用的对象，基本上 template 中也能使用</span><br><span class="line">      //但是 script 中使用加 this，template 中不需要</span><br><span class="line">      this.isRed<span class="built_in">=</span> !this.isRed;</span><br><span class="line">      this.student.push(</span><br><span class="line">        &#123;name:<span class="string">'ccc'</span>, score:<span class="string">'B'</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    add()&#123;</span><br><span class="line">      //获取输入框的值，压入heros数据数组 中去；</span><br><span class="line">      this.heros.push(</span><br><span class="line">        &#123;name:this.name,score:this.score&#125;</span><br><span class="line">      );</span><br><span class="line">      this.name<span class="built_in">=</span> <span class="string">''</span>;</span><br><span class="line">      this.score<span class="built_in">=</span> <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    del(index)&#123;</span><br><span class="line">      this.heros.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .red&#123;background-color: red;&#125;</span><br><span class="line">  .green&#123;background-color: green;&#125;</span><br><span class="line">  .blue&#123;background-color: skyblue;&#125;</span><br><span class="line">  .pink&#123;background-color: pink;&#125;</span><br><span class="line">  .big&#123;font-size: <span class="number">30</span>px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h1 id="八、父子组件的使用"><a href="#八、父子组件的使用" class="headerlink" title="八、父子组件的使用"></a>八、父子组件的使用</h1><h2 id="8-1-Vue工程中使用父子组件"><a href="#8-1-Vue工程中使用父子组件" class="headerlink" title="8.1 Vue工程中使用父子组件"></a>8.1 Vue工程中使用父子组件</h2><p>注意谁是使用者，谁是被用者，使用者的组件中需要引用子组件，并进行声明子组件，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入自定义的子组件</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./MyApp6-header'</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./MyApp6-footer'</span>;</span><br><span class="line"><span class="keyword">import</span> Body <span class="keyword">from</span> <span class="string">'./MyApp6-body'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 组件必须在components中注册声明</span></span><br><span class="line">  components:&#123;</span><br><span class="line">    <span class="comment">//组件名（在模板中使用）：组件对象</span></span><br><span class="line">    Header,</span><br><span class="line">    Body,</span><br><span class="line">    Footer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、全局组件的使用"><a href="#九、全局组件的使用" class="headerlink" title="九、全局组件的使用"></a>九、全局组件的使用</h1><p>全局组件不需要声明，可以直接使用，</p>
<blockquote>
<p>只需要在入口文件 <code>main.js</code> 中声明一次，声明使用格式为：<code>vue. component(&#39;组件名&#39;,组件对象);</code></p>
</blockquote>
<h1 id="十、父组件传递值给子组件"><a href="#十、父组件传递值给子组件" class="headerlink" title="十、父组件传递值给子组件"></a>十、父组件传递值给子组件</h1><h2 id="10-1-父组件通过子组件的属性将值进行传递，两种方式："><a href="#10-1-父组件通过子组件的属性将值进行传递，两种方式：" class="headerlink" title="10.1 父组件通过子组件的属性将值进行传递，两种方式："></a>10.1 父组件通过子组件的属性将值进行传递，两种方式：</h2><blockquote>
<p>常量传值：<code>prop1= &quot;常量&quot;</code></p>
</blockquote>
<blockquote>
<p>变量传值:  <code>v-bind:prop= &quot;变量&quot;</code></p>
</blockquote>
<h2 id="10-2-子组件需要声明接收的属性："><a href="#10-2-子组件需要声明接收的属性：" class="headerlink" title="10.2 子组件需要声明接收的属性："></a>10.2 子组件需要声明接收的属性：</h2><blockquote>
<p>根属性（子组件的<code>export default</code> 对象中的<code>props</code>属性），然后直接在页面中使用 定义的属性；<code>props</code>可以以数组或对象形式来声明 :</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组形式</span></span><br><span class="line">props: [<span class="string">'prop1'</span>, <span class="string">'prop2'</span>]</span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line">props: &#123; <span class="attr">prop1</span>: &#123; <span class="attr">type</span>: 数据类型(<span class="built_in">Array</span>, <span class="built_in">String</span>, <span class="built_in">Object</span>...), <span class="attr">default</span>: (填入默认值) &#125;, &#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-3-父子组件传递数据的例子："><a href="#10-3-父子组件传递数据的例子：" class="headerlink" title="10.3 父子组件传递数据的例子："></a>10.3 父子组件传递数据的例子：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父组件template中引入子组件，其中的people为向子组件传递的变量，test为向子组件传递的常量，父组件中的name变量为传递的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Header</span> <span class="attr">v-on:listen</span>=<span class="string">"deal"</span> <span class="attr">test</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//子组件Header接收父组件向子组件传递的值</span></span><br><span class="line">  props:[</span><br><span class="line">    people: &#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">'lhj'</span>&#125;, </span><br><span class="line">    test: &#123;<span class="attr">type</span>: <span class="built_in">String</span>,&#125; </span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十一、VueBus的通信，实现子组件通信父组件"><a href="#十一、VueBus的通信，实现子组件通信父组件" class="headerlink" title="十一、VueBus的通信，实现子组件通信父组件"></a>十一、VueBus的通信，实现子组件通信父组件</h1><h2 id="11-1-通过-emit-发布订阅模式来子组件向父组件传值；"><a href="#11-1-通过-emit-发布订阅模式来子组件向父组件传值；" class="headerlink" title="11.1 通过 emit 发布订阅模式来子组件向父组件传值；"></a>11.1 通过 emit 发布订阅模式来子组件向父组件传值；</h2><p>原理：子组件通过 <code>emit</code> 方法传递一个事件名，还有可以传递一个数据，父组件中通过 <code>v-on</code> 指令监听该事件名，若监听到，则触发其响应函数；</p>
<p>格式：</p>
<ul>
<li>（子组件）<code>$emit(&#39;事件名&#39;, prop1,prop2);</code></li>
<li>（父组件）<code>v-on:事件名= &quot;函数1&quot;  函数1(e){...}</code></li>
</ul>
<h2 id="11-2-子组件向父组件传递数据例子"><a href="#11-2-子组件向父组件传递数据例子" class="headerlink" title="11.2 子组件向父组件传递数据例子"></a>11.2 子组件向父组件传递数据例子</h2><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">子组件Header中：</span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // test1:this.test,</span><br><span class="line">      msg:<span class="string">"我是子组件发送的数据"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    // 子组件 Header 的methods方法中通过$emit 方法向父组件传递一个事件名和一个数据</span><br><span class="line">    send()&#123;</span><br><span class="line">      this.$emit(<span class="string">"listen"</span>,this.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父组件中：</span><br><span class="line">&lt;!-- 在父组件template中引入子组件，使用v-on指令监听子组件通过$emit 发布的事件，当事件触发时，调用父组件中后面的deal方法 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">    &lt;Header v-on:listen<span class="built_in">=</span><span class="string">"deal"</span>/&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h1 id="十二、Vue-官方API文档中的分类"><a href="#十二、Vue-官方API文档中的分类" class="headerlink" title="十二、Vue 官方API文档中的分类"></a>十二、Vue 官方API文档中的分类</h1><h2 id="12-1-全局配置、全局API："><a href="#12-1-全局配置、全局API：" class="headerlink" title="12.1 全局配置、全局API："></a>12.1 全局配置、全局API：</h2><blockquote>
<p>全局是指通过 <code>Vue.</code> 调用；还有 API 配置；</p>
</blockquote>
<h2 id="12-2-实例方法-事件："><a href="#12-2-实例方法-事件：" class="headerlink" title="12.2 实例方法/事件："></a>12.2 实例方法/事件：</h2><ul>
<li>实例指的是组件内的 <code>this.</code> 和 <code>new Vue().</code>  ; </li>
<li><code>vm.$once</code>表示只触发一次；</li>
<li><code>vm.$off</code> 表示取消事件；</li>
</ul>
<h2 id="12-3-选项（数据、DOM、资源…）："><a href="#12-3-选项（数据、DOM、资源…）：" class="headerlink" title="12.3 选项（数据、DOM、资源…）："></a>12.3 选项（数据、DOM、资源…）：</h2><p><code>options/类别</code>；options 和实例相关的，进行配置实例；还有包括 export default{} 中进行配置；</p>
<p>其实 <code>options/选项</code> 就是代表 <code>new Vue()</code> 的参数和 <code>export default{}</code> 里面的属性；</p>
<h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><ol>
<li>完整的整个项目的文件，例如包含<code>node_modules、package.json</code>等配置文件</li>
<li>创建 <code>index.html</code> 文件，观看配置信息（<code>webpack.config.js</code>),</li>
<li><code>index.html</code>中 <code>div-&gt;id-&gt;app</code>，</li>
<li>创建 <code>main.js</code> ,观看其文件和<code>webpack.config.js</code> 文件描述的关系；</li>
<li>main.js 中引入vue和相关的对象</li>
<li>new Vue(选项options),目的地 el  渲染内容 render:c=&gt;(App) 渲染App的节点</li>
<li>编写app.vue文件：script 格式是 export default { 选项options } ;style 加上 scoped 后，变成局部样式；</li>
<li>可能使用组件或者使用函数接收参数：options(根属性)：<ul>
<li>data 是一个函数，return 一个对象；</li>
<li>methods 是一个对象，key是函数名，value 是函数体；</li>
<li>components 是一个对象，key 是组件名，值是组件对象；</li>
<li>props 使用一个数组或对象，数组时元素是多个接收到的参数；对象时，key 是多个接收到的参数，对应的 value 是参数的类型；</li>
</ul>
</li>
<li>套路总结：只要是在上面 template 使用的东西，在 script 中都可以通过this使用</li>
</ol>
<h1 id="十四、复习"><a href="#十四、复习" class="headerlink" title="十四、复习"></a>十四、复习</h1><h2 id="14-1-vue-单文件方式-xxx-vue"><a href="#14-1-vue-单文件方式-xxx-vue" class="headerlink" title="14.1 vue 单文件方式 xxx.vue"></a>14.1 vue 单文件方式 xxx.vue</h2><ul>
<li>准备好配置文件 package.json(包含描述文件以及封装命令)和webpack.config.js 文件(打包的配置文件)</li>
<li>创建 index.html(单页应用的页)</li>
<li>创建 mian.js (入口文件)</li>
<li>引入Vue 和相关的文件 xxx.vue</li>
<li>new Vue(options)</li>
<li>options(选项)：data、methods、components（声明子组件）、props…</li>
<li>实例： 在组件内(xxx.vue)中的this；new Vue();事件 this.$on(事件名，回调函数); this.$emit(事件名,数据);this.$once(事件名,回调函数);this.$off(事件名)</li>
<li>全局：Vue.component(‘组件名’,组件对象)</li>
<li>组件传值：父传子（属性作为参数，可以为常量或者变量，通过props 属性传递值）；子传父组件（发布订阅模式，$emit 方法，事件名一定要一致）</li>
</ul>
<h1 id="十五、过滤器"><a href="#十五、过滤器" class="headerlink" title="十五、过滤器"></a>十五、过滤器</h1><h2 id="15-1-Vue中自定义过滤器"><a href="#15-1-Vue中自定义过滤器" class="headerlink" title="15.1 Vue中自定义过滤器"></a>15.1 Vue中自定义过滤器</h2><h3 id="15-1-1-组件内的过滤器（局部）："><a href="#15-1-1-组件内的过滤器（局部）：" class="headerlink" title="15.1.1 组件内的过滤器（局部）："></a>15.1.1 组件内的过滤器（局部）：</h3><p> <code>options选项</code> 中的一个 <code>filters</code> 的属性（一个对象）；多个key就是不同的过滤器名，多个 value 就是与 key 对应的过滤方式函数体，下面为一个组件内的过滤器定义和使用的例子；</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;!-- 只有一个根节点 --&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   请输入内容：</span><br><span class="line">   &lt;input <span class="keyword">type</span><span class="built_in">=</span><span class="string">"text"</span> name<span class="built_in">=</span><span class="string">""</span> v-model<span class="built_in">=</span><span class="string">"text"</span>&gt;</span><br><span class="line">   显示：&#123;&#123; text | myFilter &#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text:<span class="string">''</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    myFilter(value)&#123;//value 就是text</span><br><span class="line">      //将输入的内容反转，方式是先转换成数组，再反转数组，最后转换成字符串</span><br><span class="line">      return value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-1-2-全局过滤器-："><a href="#15-1-2-全局过滤器-：" class="headerlink" title="15.1.2 全局过滤器 ："></a>15.1.2 全局过滤器 ：</h3><p><code>Vue.fiter(过滤器名，fn)；//参考上面代码，与局部过滤器使用形式一样</code></p>
<h2 id="15-2-全局-局部过滤器对比："><a href="#15-2-全局-局部过滤器对比：" class="headerlink" title="15.2 全局/ 局部过滤器对比："></a>15.2 全局/ 局部过滤器对比：</h2><ul>
<li>全局（范围大，若出现同名时，权利小）；</li>
<li>组件内（范围小，若出现同名时，权利大）；</li>
</ul>
<h1 id="十六、获取-DOM-元素（ref属性）"><a href="#十六、获取-DOM-元素（ref属性）" class="headerlink" title="十六、获取 DOM 元素（ref属性）"></a>十六、获取 DOM 元素（ref属性）</h1><p>前端框架是为了减少 DOM操作，但是特定情况下留了后门，在指定元素上，添加 <code>ref= &quot;名称A&quot;</code>，再在获取的地方加入 <code>this.$refs.名称A</code>;</p>
<ul>
<li>如果ref放在元素的DOM元素上，获取的数据就是原生DOM对象【可以直接操作】</li>
<li>若ref放在组件对象上，获取的就是组件对象【获取到DOM对象，通过 this.$refs.组件名.$el  进行操作】</li>
</ul>
<h1 id="十七、饿了么-mint-ui"><a href="#十七、饿了么-mint-ui" class="headerlink" title="十七、饿了么_mint-ui"></a>十七、饿了么_mint-ui</h1><blockquote>
<p><a href="http://mint-ui.github.io/docs/#/zh-cn2" target="_blank" rel="noopener">mint-ui 官方文档</a></p>
</blockquote>
<h1 id="十八、获取网站技术的插件"><a href="#十八、获取网站技术的插件" class="headerlink" title="十八、获取网站技术的插件"></a>十八、获取网站技术的插件</h1><p>wappalyzer插件：获取当前网站使用的技术</p>
<h1 id="十九、mint-ui-介绍"><a href="#十九、mint-ui-介绍" class="headerlink" title="十九、mint_ui 介绍"></a>十九、mint_ui 介绍</h1><ol>
<li><p>根据官网，先下载 mint-ui 的包，然后在入口文件里面进行组件的全部引入：import MintUi from ‘mint-ui’;再引入样式文件：import ‘mint-ui/lib/style.css’;在进行插件安装：Vue.use(MintUi);</p>
</li>
<li><p>注意在js部分（script）所有的变量都是模块作用域，所以必须通过 import 来先引入，再使用；而若是全局安装的方式的话，在template中可直接使用组件标签；</p>
</li>
</ol>
<h1 id="二十、vue-router-的基本使用"><a href="#二十、vue-router-的基本使用" class="headerlink" title="二十、vue-router 的基本使用"></a>二十、vue-router 的基本使用</h1><ol>
<li>前端路由的核心就是锚点值的改变，根据不同的值，渲染指定DOM位置的不同；</li>
<li>vue中，模板数据不是通过 ajax 请求来，而是调用函数获取模板内容；</li>
<li>只要是以 vue 开头的，就必须用 Vue.use;</li>
<li>Vue目前的核心插件有：<ul>
<li>vue-router；</li>
<li>vuex(管理全局共享数据)；</li>
</ul>
</li>
<li>vue-router 使用方式:<ul>
<li>下载安装： <code>npm i vue-router -S</code></li>
<li>在 main.js 中引入：<code>import VueRouter from &#39;vue-router&#39;</code></li>
<li>安装插件：Vue.use(插件)：<code>Vue.use(VueRouter)</code></li>
<li>创建路由对象并配置路由规则：<code>let router=new VueRouter({ routes:[ {path:&#39;/&#39;, component:MyApp12home} ] })</code></li>
<li>将其路由对象传递给 Vue 的实例，options 中: <code>router:router</code></li>
<li>在 app.vue 中留坑:<code>&lt;router-view&gt;&lt;/router-view&gt;</code></li>
</ul>
</li>
</ol>
<h1 id="二一、vue-的学习方式"><a href="#二一、vue-的学习方式" class="headerlink" title="二一、vue 的学习方式"></a>二一、vue 的学习方式</h1><ol>
<li>vue框架的使用，多练习敲代码，了解书写格式，掌握应用；</li>
<li>组件的内容： 结构、样式、动态效果；</li>
<li>学习打包的操作，webpack的使用与搭建，webpack核心：最终理解打包的好处；</li>
</ol>
<h1 id="二二、路由命名方式使用-router-link"><a href="#二二、路由命名方式使用-router-link" class="headerlink" title="二二、路由命名方式使用 router-link"></a>二二、路由命名方式使用 router-link</h1><ol>
<li><p>需求：通过点击标签，进行页面跳转；</p>
</li>
<li><p>Vue项目中使用路由导航步骤：</p>
<ul>
<li>先创建Vue组件;</li>
<li>在入口文件中导入;</li>
<li>对路由规则进行配置，例如:<code>{path:&#39;/movie&#39;, name:&#39;movie&#39;,component:MyApp13movie}, {path:&#39;/mymusic&#39;, name:&#39;music&#39;,component:MyApp13music}</code>);</li>
<li>在具体文件中进行配置:</li>
</ul>
</li>
<li><p>有三种方式进行路由导航：</p>
<ul>
<li>a 标签导航：例: <code>&lt;a href=&quot;#/music&quot;&gt;music1&lt;/a&gt;</code></li>
<li>router-link 命名式导航(一定要掌握书写格式，注意在入口文件规则设置中加入 name 属性)：例: <code>&lt;router-link :to=&quot;{name:&#39;music&#39;}&quot;&gt;音乐1&lt;/router-link&gt;</code></li>
<li>router-link 路径式导航：例: <code>&lt;router-link to=&quot;/movie&quot;&gt;电影4&lt;/router-link&gt;</code></li>
</ul>
</li>
</ol>
<h1 id="二三、router-link-对象方式传递参数"><a href="#二三、router-link-对象方式传递参数" class="headerlink" title="二三、router-link 对象方式传递参数"></a>二三、router-link 对象方式传递参数</h1><h2 id="23-1-使用-router-link-标签："><a href="#23-1-使用-router-link-标签：" class="headerlink" title="23.1 使用 router-link 标签："></a>23.1 使用 router-link 标签：</h2><ul>
<li>方式1：<code>&lt;router-link to=&quot;/movie&quot;&gt;电影4&lt;/router-link&gt;</code></li>
<li>方式2：<code>&lt;router-link :to=&quot;{name:&#39;music&#39;}&quot;&gt;音乐1&lt;/router-link&gt;</code></li>
</ul>
<h2 id="23-2-页面之间进行通信"><a href="#23-2-页面之间进行通信" class="headerlink" title="23.2 页面之间进行通信"></a>23.2 页面之间进行通信</h2><p>在 vue-router中，共有两大对象被挂载到了实例 this：<code>$route</code>(只读，具备路由的信息的对象) 和 <code>$router</code>(具备路由的功能函数对象)</p>
<h2 id="23-3-查询字符串方式导航："><a href="#23-3-查询字符串方式导航：" class="headerlink" title="23.3 查询字符串方式导航："></a>23.3 查询字符串方式导航：</h2><ul>
<li>去哪里：<code>&lt;router-link :to= &quot;{name:&#39;detail&#39;,query:{id: 1}}&quot;&gt;xxx&lt;/router-link&gt;</code></li>
<li>路由规则、导航(查询字符串 path 不用改)：<code>{name:&#39;detail&#39;, path:&#39;/detail&#39;, component:组件名}</code></li>
<li>去了干嘛，获取路由参数（注意是query 还是params和对应的 id 名）：<code>this.$route.query.id</code></li>
</ul>
<h2 id="path-路径方式导航："><a href="#path-路径方式导航：" class="headerlink" title="path 路径方式导航："></a>path 路径方式导航：</h2><ul>
<li>去哪里：<code>&lt;router-link :to= &quot;{name:&#39;detail&#39;,params:{name: 1}}&quot;&gt;xxx&lt;/router-link&gt;</code></li>
<li>路由规则、导航( path 方式需要在路由规则上加上 /:xxx)：<code>{name:&#39;detail&#39;, path:&#39;/detail/:name&#39;, component:组件名}</code></li>
<li>去了干嘛，获取路由参数（注意是query 还是params和对应的 id 名）：<code>this.$route.params.name</code></li>
</ul>
<h1 id="二四、编程导航参数"><a href="#二四、编程导航参数" class="headerlink" title="二四、编程导航参数"></a>二四、编程导航参数</h1><p>编程导航参数用于不能保证用户一定会点击某些按钮，并且当前操作，处理路由跳转以外，还有一些别的附加操作；例如通过： </p>
<ul>
<li><code>this.$router.go</code> 根据浏览器记录 前进1 或后退-1 ;</li>
<li><code>this.$router.push(直接跳转到某个页面显示)</code>: 其中的push参数为 ：字符串/xxx、对象<code>{name:&#39;xxx&#39;,query{id:1},params{name:1}}</code>;【注意使用 <code>params</code> 传递参数一定要修改<code>路由规则routes.js</code>，在对应的路由规则上加上 <code>/:xxx</code>】</li>
</ul>
<h1 id="二五、前端路由的原生代码实现"><a href="#二五、前端路由的原生代码实现" class="headerlink" title="二五、前端路由的原生代码实现"></a>二五、前端路由的原生代码实现</h1><p>路由的原生书写方式： <code>window.addEventListener(&#39;hashchange&#39;, fn)</code></p>
<h2 id="25-1-复习之前的学习："><a href="#25-1-复习之前的学习：" class="headerlink" title="25.1 复习之前的学习："></a>25.1 复习之前的学习：</h2><ul>
<li>过滤器：定义全局过滤器或者组件内过滤器；</li>
<li>获取 DOM 元素: 在元素上面加入 <code>ref=&quot;xxx&quot;</code>，代码中通过<code>this.$refs.xxx</code> 获取其元素（原生 DOM 标签获取的就是原生 DOM 对象，而组件标签获取的是组件对象，通过 $el 继续再获取DOM 元素）</li>
<li>生命周期事件（钩子）回调函数：<ul>
<li>created: 数据初始化，DOM还没生成；</li>
<li>mounted: 将数据装载到 DOM 元素上，DOM 已经生成；</li>
</ul>
</li>
</ul>
<h3 id="25-1-路由的原生代码实现："><a href="#25-1-路由的原生代码实现：" class="headerlink" title="25.1 路由的原生代码实现："></a>25.1 路由的原生代码实现：</h3><ul>
<li><code>window.addEventListener(&#39;hashchange&#39;, fn)</code></li>
<li>根据你放 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>作为一个 DOM 上的标识</li>
<li>最终当锚点值改变时，触发 <code>hashchange</code> 的回调函数，将指定的模板数据插入到之前 <code>router-view</code> 标签作为的 DOM 标识上；</li>
</ul>
<h1 id="二六、重定向和404"><a href="#二六、重定向和404" class="headerlink" title="二六、重定向和404"></a>二六、重定向和404</h1><h2 id="26-1-重定向"><a href="#26-1-重定向" class="headerlink" title="26.1 重定向"></a>26.1 重定向</h2><p>重定向的书写格式：</p>
<ul>
<li><code>{path:&#39;/&#39;,redirect:&#39;/home&#39;}</code></li>
<li><code>{path:&#39;/&#39;,redirect:{name:&#39;home&#39;}}</code></li>
</ul>
<h2 id="26-2-404页面"><a href="#26-2-404页面" class="headerlink" title="26.2 404页面:"></a>26.2 404页面:</h2><p>在路由规则的最后一个规则，写一个很强大的匹配：<code>{path:&#39;*&#39;,component:NotFoundVue}</code></p>
<h1 id="二七、多视图"><a href="#二七、多视图" class="headerlink" title="二七、多视图"></a>二七、多视图</h1><p>多个坑对应加一个路由加多个组件（注意路由规则书写中为：<code>components</code>）</p>
<ul>
<li>多个 <code>router-view</code> 标签，让页面更加细化;</li>
<li>components 多视图 ：是一个对象，对象中包含多个 key 和 value, key 对应视图的 name 属性，value 是要显示的组件对象；还有多个 router-view，包含 name属性，默认为 default；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 在组件中留坑的地方加入下面的代码</span><br><span class="line"><span class="comment">&lt;!-- 留坑【十分重要】 每个坑都有各自的坑名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"router-bg"</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"router-bg"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"router-bg"</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置路由规则routes中的components对象，对应上面的坑中的命名</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/'</span>, <span class="attr">components</span>: &#123;<span class="attr">header</span>:Header,<span class="attr">default</span>:Body,<span class="attr">footer</span>:Footer&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二八、嵌套路由（children属性）"><a href="#二八、嵌套路由（children属性）" class="headerlink" title="二八、嵌套路由（children属性）"></a>二八、嵌套路由（children属性）</h1><p>在路由规则里面加入children，若果写上 <code>/xxx</code> 就是绝对路径，如果不写 <code>/</code> 就是相对路径，匹配到上一级目录下，然后必须记住要在含有嵌套组件中加坑<code>&lt;router-view&gt;&lt;/router-view&gt;</code>；</p>
<h1 id="二九、嵌套路由（暂时没有代码）"><a href="#二九、嵌套路由（暂时没有代码）" class="headerlink" title="二九、嵌套路由（暂时没有代码）"></a>二九、嵌套路由（暂时没有代码）</h1><ol>
<li><p>用单页去实现多页应用，就是复杂的嵌套路由，开发中会使用；</p>
</li>
<li><p>视图包含视图：注意 规则中是 components</p>
</li>
<li><p>路由父子级关系路由：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name:&#39;music&#39;,</span><br><span class="line">  path:&#39;&#x2F;music&#39;,</span><br><span class="line">  component:Music,</span><br><span class="line">  &#x2F;&#x2F;子路由中加入 &#x2F; 就是绝对路径,不加 &#x2F; 就是相对父级路径</span><br><span class="line">  children:[</span><br><span class="line">    &#123;name:&#39;oumei&#39;,path:&#39;oumei&#39;,component:Oumei&#125;,</span><br><span class="line">    &#123;name:&#39;guochan&#39;,path:&#39;guochan&#39;,component:Guochan&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三十、路由总结"><a href="#三十、路由总结" class="headerlink" title="三十、路由总结"></a>三十、路由总结</h1><ol>
<li>多进行路由代码练习，练习配置路由规则；</li>
<li>SPA 头 中（变化） 尾 变化中必须填坑<code>&lt;router-view&gt;&lt;/router-view&gt;</code></li>
<li>在 url 中做手脚：<ul>
<li>查询字符串方式/path 路径方式：（注意两者区别：query 和 params；path 路径方式在路由规则中加入 params 中的 key 名）</li>
<li>去哪里：<code>&lt;router-link&gt; :to= &quot;name:&#39;xxx&#39;,query:{id:1}&quot;&gt;&lt;/router-link&gt;</code>;</li>
<li>路由规则：<code>{name:&#39;xxx&#39;,path:&#39;/xxx&#39;,component:组件名}</code>或者<code>{name:&#39;detail&#39;, path:&#39;/detail/:name&#39;, component:组件名}</code>;</li>
<li>去了干嘛，获取路由参数（注意是query 还是params 和 对应的 id 名）：<code>this.$route.query.id</code>或者<code>this.$route.params.id</code>;</li>
</ul>
</li>
<li>编程式导航：<code>this.$router.push(去哪里,路由名称)</code><ul>
<li>页面前进/后退：<code>this.$router.go(1 |-1)</code></li>
</ul>
</li>
<li>路由的原生写法：锚点监视+ 模板替换</li>
<li>路由匹配规则按照规则顺序执行， * 是通配符去404页面，重定向；</li>
<li>vue-router是什么都可以写字符串匹配，也可以通过名称匹配；</li>
<li>让视图填充更加灵活，视图是通过使用多个 router-view ，用名称匹配，路由是 components 对象来标识；</li>
<li>嵌套路由：节约不变数据的重复渲染；适用于多页应用开发；</li>
</ol>
<h1 id="三一、vue-resource-介绍"><a href="#三一、vue-resource-介绍" class="headerlink" title="三一、vue-resource 介绍"></a>三一、vue-resource 介绍</h1><p>安装插件，之前为vue 团队开发，现已经停止维护，推荐使用 <code>axios</code> 来异步获取数据；（去GitHub上面查看文档）</p>
<h1 id="三二、vue-resource（暂无代码）"><a href="#三二、vue-resource（暂无代码）" class="headerlink" title="三二、vue-resource（暂无代码）"></a>三二、vue-resource（暂无代码）</h1><ol>
<li>下载插件：npm install vue-resource -S</li>
<li>引入插件：import VueResource from ‘vue-resource’;</li>
<li>安装插件：Vue.use(VueResource)//插件都是挂载属性，挂载在原型上<ul>
<li>以后都通过 <code>this</code>。<code>$http</code> 来使用，原理为：Vue是所有实例对象的构造函数，因而 <code>Vue.prototype.$http</code> 可以用实例的 <code>this</code> 替换为 <code>this.$http</code>;</li>
</ul>
</li>
<li>获取URL地址的数据：<ul>
<li>get请求：<code>this.$http.get(&#39;url&#39;).then(res=&gt;{},err=&gt;{})</code></li>
<li>post请求：<code>this.$http.post(&#39;url&#39;,{data对象},{options对象}).then(res=&gt;{},err=&gt;{})</code></li>
<li>post请求出现bug：options 预检请求是当浏览器发现跨域 +application/json的请求，并且发起的时候带了一个 ContentType 的请求头，服务器无法识别，则出错；解决方式是换 application/json 为键值对的形式，将options 预检请求忽略；</li>
</ul>
</li>
</ol>
<h1 id="三三、axios简单使用【十分重要】"><a href="#三三、axios简单使用【十分重要】" class="headerlink" title="三三、axios简单使用【十分重要】"></a>三三、axios简单使用【十分重要】</h1><blockquote>
<p><a href="https://segmentfault.com/a/1190000008470355?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">axios官方文档</a></p>
</blockquote>
<ol>
<li>下载包：<code>npm i axios</code></li>
<li>引入插件：<code>import Axios from &#39;axios&#39;</code></li>
<li>给Vue原型链挂载一个属性：<code>Vue.prototype.$axios= Axios</code></li>
<li>在app.vue 文件中可以通过 this.$axios 获取get/post请求数据，例：<ul>
<li><code>this.$axios.get(&#39;url&#39;).then(res=&gt;{console.log(res)}).catch(err=&gt;{console.log(err)})</code></li>
<li><code>this.$axios.post(&#39;url&#39;,{data对象},{options设置——设置headers}).then(res=&gt;{console.log(res)}).catch(err=&gt;{console.log(err)})</code></li>
<li>上面的有问题，服务器端将无法正常获取数据，而是通过以下方式，不用对象进行数据传输，用字符串方式传输数据；【注意：必须知道传递的数据 Form Data 是什么样的数据形式】</li>
</ul>
</li>
<li>简化Axios 获取的URL参数，通过 <code>Axios.defaults.baseUrl= &#39;url&#39;;</code> 提前设置就行了；</li>
<li>小结：post请求时，若数据时字符串，默认的头就是键值对，否则对象就是 application/json;<ul>
<li><code>this.$axios.get(url, options)</code></li>
<li><code>this.$axios.post(url, data, options)</code></li>
<li>针对当前的一次请求的相关设置：<code>options:{params:{id:1}//查询字符串,headers:{&#39;content-type&#39;:&#39;xxx&#39;}，baseURL:&#39;&#39; }</code></li>
<li>全局默认设置：<code>Axios.defaults.baseURL = &#39;xxxx&#39;;</code></li>
</ul>
</li>
</ol>
<h1 id="三四、总结"><a href="#三四、总结" class="headerlink" title="三四、总结"></a>三四、总结</h1><h2 id="34-1-路由是核心，以下重点："><a href="#34-1-路由是核心，以下重点：" class="headerlink" title="34.1 路由是核心，以下重点："></a>34.1 路由是核心，以下重点：</h2><ul>
<li>路由的基本使用，整体框架的搭建；</li>
<li>任选一种路由参数的方式（查询字符串方式最重要）；</li>
<li>404 页面（路由匹配规则）；</li>
<li>嵌套路由的使用（重要）；</li>
<li>编程导航的使用（重要）；</li>
</ul>
<h2 id="34-2-http-请求："><a href="#34-2-http-请求：" class="headerlink" title="34.2 http 请求："></a>34.2 http 请求：</h2><ul>
<li>axios 发起 get 、post请求</li>
<li>axios 挂载属性的方式（Vue.prototype的方式）</li>
</ul>
]]></content>
      <categories>
        <category>VueJs</category>
      </categories>
      <tags>
        <tag>Vue入门</tag>
        <tag>黑马程序员课程</tag>
      </tags>
  </entry>
  <entry>
    <title>VueAPI官方文档笔记</title>
    <url>/2018/12/21/VueAPI%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>VueAPI官方文档笔记</p>
<a id="more"></a>

<h2 id="VueAPI官方文档笔记"><a href="#VueAPI官方文档笔记" class="headerlink" title="VueAPI官方文档笔记"></a>VueAPI官方文档笔记</h2><blockquote>
<p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue API 官方文档</a></p>
</blockquote>
<h2 id="1-全局配置、全局API："><a href="#1-全局配置、全局API：" class="headerlink" title="1. 全局配置、全局API："></a>1. 全局配置、全局API：</h2><h3 id="1-1-全局配置（复制粘贴）"><a href="#1-1-全局配置（复制粘贴）" class="headerlink" title="1.1 全局配置（复制粘贴）"></a>1.1 全局配置（复制粘贴）</h3><blockquote>
<p>Vue.config 是一个<strong>对象</strong>，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p>
</blockquote>
<h4 id="1-1-1-silent：取消-Vue-所有的日志与警告；"><a href="#1-1-1-silent：取消-Vue-所有的日志与警告；" class="headerlink" title="1.1.1 silent：取消 Vue 所有的日志与警告；"></a>1.1.1 silent：取消 Vue 所有的日志与警告；</h4><ol>
<li>类型：<code>boolean</code></li>
<li>默认值：<code>false</code></li>
<li>用法：<code>Vue.config.silent = true</code></li>
</ol>
<blockquote>
<p>意义：取消 Vue 所有的日志与警告。</p>
</blockquote>
<h4 id="1-1-2-optionMergeStrategies"><a href="#1-1-2-optionMergeStrategies" class="headerlink" title="1.1.2 optionMergeStrategies"></a>1.1.2 optionMergeStrategies</h4><ol>
<li>类型：<code>{ [key: string]: Function }</code></li>
<li>默认值：<code>{}</code></li>
<li>用法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies._my_option = <span class="function"><span class="keyword">function</span> (<span class="params">parent, child, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> child + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Profile = Vue.extend(&#123;</span><br><span class="line">  _my_option: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Profile.options._my_option = 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>意义：自定义合并策略的选项。<br><br><br>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p>
</blockquote>
<h4 id="1-1-3-devtools：配置是否允许-vue-devtools-检查代码；"><a href="#1-1-3-devtools：配置是否允许-vue-devtools-检查代码；" class="headerlink" title="1.1.3 devtools：配置是否允许 vue-devtools 检查代码；"></a>1.1.3 devtools：配置是否允许 vue-devtools 检查代码；</h4><ol>
<li>类型：<code>boolean</code></li>
<li>默认值：<code>true (生产版为 false)</code></li>
<li>用法：<code>Vue.config.devtools = true  // 务必在加载 Vue 之后，立即同步设置以下内容</code></li>
</ol>
<blockquote>
<p>意义：配置是否允许 <code>vue-devtools</code>检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。</p>
</blockquote>
<h4 id="1-1-4-errorHandler：指定组件的渲染和观察期间未捕获错误的处理函数；"><a href="#1-1-4-errorHandler：指定组件的渲染和观察期间未捕获错误的处理函数；" class="headerlink" title="1.1.4 errorHandler：指定组件的渲染和观察期间未捕获错误的处理函数；"></a>1.1.4 errorHandler：指定组件的渲染和观察期间未捕获错误的处理函数；</h4><ol>
<li>类型：<code>Function</code></li>
<li>默认值：<code>undefined</code></li>
<li>用法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span></span><br><span class="line">  <span class="comment">// 只在 2.2.0+ 可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>意义：指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>
</blockquote>
<h4 id="1-1-5-warnHandler：为-Vue-的运行时警告赋予一个自定义处理函数（测试环境中）；"><a href="#1-1-5-warnHandler：为-Vue-的运行时警告赋予一个自定义处理函数（测试环境中）；" class="headerlink" title="1.1.5 warnHandler：为 Vue 的运行时警告赋予一个自定义处理函数（测试环境中）；"></a>1.1.5 warnHandler：为 Vue 的运行时警告赋予一个自定义处理函数（测试环境中）；</h4><ol>
<li>类型：<code>Function</code></li>
<li>默认值：<code>undefined</code></li>
<li>用法：<code>Vue.config.warnHandler = function (msg, vm, trace) {
// trace 是组件的继承关系追踪
}</code></li>
</ol>
<blockquote>
<p>意义：为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p>
</blockquote>
<h4 id="1-1-6-ignoredElements-忽略Vue中定义的元素；"><a href="#1-1-6-ignoredElements-忽略Vue中定义的元素；" class="headerlink" title="1.1.6 ignoredElements: 忽略Vue中定义的元素；"></a>1.1.6 ignoredElements: 忽略Vue中定义的元素；</h4><ol>
<li>类型：<code>Array&lt;string | RegExp&gt;</code></li>
<li>默认值：<code>[]</code></li>
<li>用法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.ignoredElements = [</span><br><span class="line">  <span class="string">'my-custom-web-component'</span>,</span><br><span class="line">  <span class="string">'another-web-component'</span>,</span><br><span class="line">  <span class="comment">// 用一个 `RegExp` 忽略所有“ion-”开头的元素</span></span><br><span class="line">  <span class="comment">// 仅在 2.5+ 支持</span></span><br><span class="line">  /^ion-<span class="regexp">/</span></span><br><span class="line"><span class="regexp">]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>意义：须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。</p>
</blockquote>
<h4 id="1-1-7-keyCodes-给-v-on-自定义键位别名；"><a href="#1-1-7-keyCodes-给-v-on-自定义键位别名；" class="headerlink" title="1.1.7 keyCodes: 给 v-on 自定义键位别名；"></a>1.1.7 keyCodes: 给 v-on 自定义键位别名；</h4><ol>
<li>类型：<code>{ [key: string]: number | Array&lt;number&gt; }</code></li>
<li>默认值：<code>{}</code></li>
<li>用法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.keyCodes = &#123;</span><br><span class="line">  v: <span class="number">86</span>,</span><br><span class="line">  f1: <span class="number">112</span>,</span><br><span class="line">  <span class="comment">// camelCase 不可用</span></span><br><span class="line">  <span class="comment">// mediaPlayPause: 179,</span></span><br><span class="line">  <span class="comment">// 取而代之的是 kebab-case 且用双引号括起来</span></span><br><span class="line">  <span class="string">"media-play-pause"</span>: <span class="number">179</span>,</span><br><span class="line">  up: [<span class="number">38</span>, <span class="number">87</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;</code></p>
<blockquote>
<p>意义：给<code>v-on</code> 自定义键位别名；</p>
</blockquote>
<h4 id="1-1-8-performance"><a href="#1-1-8-performance" class="headerlink" title="1.1.8 performance"></a>1.1.8 performance</h4><ol>
<li>类型：<code>boolean</code></li>
<li>默认值：<code>false</code> (自 2.2.3 起)</li>
<li>用法：</li>
</ol>
<blockquote>
<p>意义：设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。</p>
</blockquote>
<h4 id="1-1-9-productionTip：设置为-false-后可以阻止-vue-在启动时生成生产提示。"><a href="#1-1-9-productionTip：设置为-false-后可以阻止-vue-在启动时生成生产提示。" class="headerlink" title="1.1.9 productionTip：设置为 false 后可以阻止 vue 在启动时生成生产提示。"></a>1.1.9 productionTip：设置为 false 后可以阻止 vue 在启动时生成生产提示。</h4><ol>
<li>类型：<code>boolean</code></li>
<li>默认值：<code>true</code></li>
<li>用法：</li>
</ol>
<blockquote>
<p>意义：设置为 false 以阻止 vue 在启动时生成生产提示。</p>
</blockquote>
<h3 id="1-2-全局-API"><a href="#1-2-全局-API" class="headerlink" title="1.2 全局 API"></a>1.2 全局 API</h3><h4 id="1-2-1-Vue-extend-options-：基础-Vue-构造器，可以创建一个“子类”；"><a href="#1-2-1-Vue-extend-options-：基础-Vue-构造器，可以创建一个“子类”；" class="headerlink" title="1.2.1 Vue.extend( options )：基础 Vue 构造器，可以创建一个“子类”；"></a>1.2.1 Vue.extend( options )：基础 Vue 构造器，可以创建一个“子类”；</h4><ol>
<li>参数：<code>{Object} options</code></li>
<li>用法：<blockquote>
<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
</blockquote>
</li>
</ol>
<p>【注：<code>data</code> 选项是特例，需要注意 - 在 Vue.extend() 中它必须是<strong>函数</strong>】<br>3. 示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mount-point"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建构造器</span></span><br><span class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'Walter'</span>,</span><br><span class="line">      lastName: <span class="string">'White'</span>,</span><br><span class="line">      alias: <span class="string">'Heisenberg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></span><br><span class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面展示结果如下：</span></span><br><span class="line">&lt;p&gt;Walter White aka Heisenberg&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-Vue-nextTick-callback-context-：DOM-更新循环结束之后执行延迟回调；"><a href="#1-2-2-Vue-nextTick-callback-context-：DOM-更新循环结束之后执行延迟回调；" class="headerlink" title="1.2.2 Vue.nextTick( [callback, context] )：DOM 更新循环结束之后执行延迟回调；"></a>1.2.2 Vue.nextTick( [callback, context] )：DOM 更新循环结束之后执行延迟回调；</h4><ol>
<li>参数：<code>{Function} [callback] 或 {Object} [context]</code></li>
<li>用法：<blockquote>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-Vue-set-target-key-value-：向响应式对象中添加一个属性；"><a href="#1-2-3-Vue-set-target-key-value-：向响应式对象中添加一个属性；" class="headerlink" title="1.2.3 Vue.set( target, key, value )：向响应式对象中添加一个属性；"></a>1.2.3 Vue.set( target, key, value )：向响应式对象中添加一个属性；</h4><ol>
<li>参数：<code>{Object | Array} target  {string | number} key  {any} value</code></li>
<li>返回值：设置的值。</li>
<li>用法：<blockquote>
<p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’);</p>
</blockquote>
</li>
</ol>
<p>【注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。】</p>
<h4 id="1-2-4-Vue-delete-target-key-：删除对象的属性；"><a href="#1-2-4-Vue-delete-target-key-：删除对象的属性；" class="headerlink" title="1.2.4 Vue.delete( target, key )：删除对象的属性；"></a>1.2.4 Vue.delete( target, key )：删除对象的属性；</h4><ol>
<li>参数：<code>{Object | Array} target  {string | number} key/index</code></li>
<li>用法：<blockquote>
<p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-5-Vue-directive-id-definition-：自定义全局指令；"><a href="#1-2-5-Vue-directive-id-definition-：自定义全局指令；" class="headerlink" title="1.2.5 Vue.directive( id, [definition] )：自定义全局指令；"></a>1.2.5 Vue.directive( id, [definition] )：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义全局指令</a>；</h4><ol>
<li>参数：<code>{string} id  {Function | Object} [definition]</code></li>
<li>用法：<blockquote>
<p>注册或获取全局指令。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  unbind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 (指令函数)</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里将会被 `bind` 和 `update` 调用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的指令</span></span><br><span class="line"><span class="keyword">var</span> myDirective = Vue.directive(<span class="string">'my-directive'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-6-Vue-filter-id-definition-：定义全局过滤器-过滤器；"><a href="#1-2-6-Vue-filter-id-definition-：定义全局过滤器-过滤器；" class="headerlink" title="1.2.6 Vue.filter( id, [definition] )：定义全局过滤器-过滤器；"></a>1.2.6 Vue.filter( id, [definition] )：定义全局过滤器-<a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">过滤器</a>；</h4><ol>
<li>参数：<code>{string} id  {Function} [definition]</code></li>
<li>用法：<blockquote>
<p>注册或获取全局过滤器</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.filter(<span class="string">'my-filter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回处理后的值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的过滤器</span></span><br><span class="line"><span class="keyword">var</span> myFilter = Vue.filter(<span class="string">'my-filter'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-7-Vue-component-id-definition-：定义全局组件-组件；"><a href="#1-2-7-Vue-component-id-definition-：定义全局组件-组件；" class="headerlink" title="1.2.7 Vue.component( id, [definition] )：定义全局组件-组件；"></a>1.2.7 Vue.component( id, [definition] )：定义全局组件-<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a>；</h4><ol>
<li>参数：<code>{string} id  {Function | Object} [definition]</code></li>
<li>用法：<blockquote>
<p>注册或获取全局组件。注册还会自动使用给定的id设置组件的名称</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册组件，传入一个扩展过的构造器</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;))</span><br><span class="line"><span class="comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器)</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-8-Vue-use-plugin-：安装-注册-Vue-js-插件-插件；"><a href="#1-2-8-Vue-use-plugin-：安装-注册-Vue-js-插件-插件；" class="headerlink" title="1.2.8 Vue.use( plugin )：安装/注册 Vue.js 插件-插件；"></a>1.2.8 Vue.use( plugin )：安装/注册 Vue.js 插件-<a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a>；</h4><ol>
<li>参数：<code>{Object | Function} plugin</code></li>
<li>用法：<blockquote>
<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 <code>Vue</code> 作为参数传入。<br><br>该方法需要在调用 <code>new Vue()</code> 之前被调用。<br><br>当 install 方法被同一个插件多次调用，插件将只会被安装一次。<br></p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成：</span></span><br><span class="line"><span class="comment">// 调用 `MyPlugin.install(Vue)`</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">//... options</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个选项对象：</span></span><br><span class="line">Vue.use(MyPlugin, &#123; <span class="attr">someOption</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时，引入 VueRouter</span></span><br><span class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</span><br><span class="line"><span class="comment">// 不要忘了调用此方法</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-9-Vue-mixin-mixin-：全局混入"><a href="#1-2-9-Vue-mixin-mixin-：全局混入" class="headerlink" title="1.2.9 Vue.mixin( mixin )：全局混入"></a>1.2.9 Vue.mixin( mixin )：<a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5" target="_blank" rel="noopener">全局混入</a></h4><ol>
<li><p>参数：<code>{Object} mixin</code></p>
</li>
<li><p>用法：</p>
<blockquote>
<p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。</p>
</blockquote>
</li>
<li><p>示例：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  myOption: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-10-Vue-compile-template-：渲染函数"><a href="#1-2-10-Vue-compile-template-：渲染函数" class="headerlink" title="1.2.10 Vue.compile( template )：渲染函数"></a>1.2.10 Vue.compile( template )：<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a></h4><ol>
<li>参数：<code>{string} template</code></li>
<li>用法：<blockquote>
<p>在 render 函数中编译模板字符串。只在独立构建时有效;</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render: res.render,</span><br><span class="line">  staticRenderFns: res.staticRenderFns</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-11-Vue-version"><a href="#1-2-11-Vue-version" class="headerlink" title="1.2.11 Vue.version"></a>1.2.11 Vue.version</h4><ol>
<li><p>细节：</p>
<blockquote>
<p>提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> (version === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v2.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v1.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Unsupported versions of Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-选项-vm-实例对象中（数据-DOM-生命周期钩子-资源-组合-其它）："><a href="#2-选项-vm-实例对象中（数据-DOM-生命周期钩子-资源-组合-其它）：" class="headerlink" title="2. 选项-vm 实例对象中（数据/DOM/生命周期钩子/资源/组合/其它）："></a>2. 选项-<code>vm 实例对象中</code>（数据/DOM/生命周期钩子/资源/组合/其它）：</h2><h3 id="2-1-选项-数据"><a href="#2-1-选项-数据" class="headerlink" title="2.1 选项-数据"></a>2.1 选项-数据</h3><h4 id="2-1-1-data：Vue-实例的数据对象；"><a href="#2-1-1-data：Vue-实例的数据对象；" class="headerlink" title="2.1.1 data：Vue 实例的数据对象；"></a>2.1.1 data：Vue 实例的数据对象；</h4><ol>
<li>类型：<code>Object | Function</code></li>
<li>限制：<code>组件的定义只接受 function</code>。</li>
<li>详细：<blockquote>
<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 <strong>getter/setter</strong>，从而让 data 的属性能够<strong>响应数据变化</strong>。<strong>对象必须是纯粹的对象 (含有零个或多个的 key/value 对)</strong>：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。<br><br><br>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。<br><br><br>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。<br><br><br>以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。<br><br><br>当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。<br><br><br>如果需要，可以通过将 vm.$data 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象；</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 直接创建一个实例</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.a <span class="comment">// =&gt; 1</span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Vue.extend() 中 data 必须是函数</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 【注意，如果你为 data 属性使用了箭头函数，则 this 不会指向这个组件的实例，不过仍然可以将其实例作为函数的第一个参数来访问：<code>data: vm =&gt; ({ a: vm.myProp })</code>】</p>
<h4 id="2-1-2-props：用于接收来自父组件的数据；"><a href="#2-1-2-props：用于接收来自父组件的数据；" class="headerlink" title="2.1.2 props：用于接收来自父组件的数据；"></a>2.1.2 props：用于接收来自父组件的数据；</h4><ol>
<li>类型：<code>Array&lt;string&gt; | Object</code></li>
<li>详细：<blockquote>
<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单语法</span></span><br><span class="line">Vue.component(<span class="string">'props-demo-simple'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'size'</span>, <span class="string">'myMessage'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象语法，提供校验</span></span><br><span class="line">Vue.component(<span class="string">'props-demo-advanced'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 检测类型</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 检测类型 + 其他验证</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-propsData-创建实例时传递-props，主要作用是方便测试；"><a href="#2-1-3-propsData-创建实例时传递-props，主要作用是方便测试；" class="headerlink" title="2.1.3 propsData: 创建实例时传递 props，主要作用是方便测试；"></a>2.1.3 propsData: 创建实例时传递 props，主要作用是方便测试；</h4><ol>
<li>类型：<code>{ [key: string]: any }</code></li>
<li>限制：<code>只用于 new 创建的实例中</code></li>
<li>详细：<blockquote>
<p>创建实例时传递 props。主要作用是方便测试。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Comp = Vue.extend(&#123;</span><br><span class="line">  props: [<span class="string">'msg'</span>],</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Comp(&#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-computed：计算属性"><a href="#2-1-4-computed：计算属性" class="headerlink" title="2.1.4 computed：计算属性"></a>2.1.4 computed：<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性</a></h4><ol>
<li>类型：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></li>
<li>详细：<blockquote>
<p><strong>计算属性将被混入到 Vue 实例中</strong>。所有 <code>getter</code> 和 <code>setter</code> 的 <code>this</code> 上下文自动地绑定为 Vue 实例。<br><br><br>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。<br><br><br><code>computed: { aDouble: vm =&gt; vm.a * 2 }</code> <br><br><br>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 仅读取</span></span><br><span class="line">    aDouble: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 读取和设置</span></span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function (v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.aPlus   <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aPlus = <span class="number">3</span></span><br><span class="line">vm.a       <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aDouble <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<p>【计算属性 <code>computed</code> 一定要 <code>return</code> 一个值出去，区别于 <code>watch</code>】</p>
<h4 id="2-1-5-methods：事件处理"><a href="#2-1-5-methods：事件处理" class="headerlink" title="2.1.5 methods：事件处理"></a>2.1.5 methods：<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">事件处理</a></h4><ol>
<li><p>类型：<code>{ [key: string]: Function }</code></p>
</li>
<li><p>详细：</p>
<blockquote>
<p>methods 将被混入到 Vue 实例中。可以<strong>直接通过 VM 实例访问</strong>这些方法，或者在<strong>指令表达式中使用</strong>。方法中的 <code>this</code> 自动绑定为 <code>Vue 实例</code>。<br><br><br>注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p>
</blockquote>
</li>
<li><p>示例：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    plus: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.plus()</span><br><span class="line">vm.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-6-watch：监察属性-侦听器；"><a href="#2-1-6-watch：监察属性-侦听器；" class="headerlink" title="2.1.6 watch：监察属性/侦听器；"></a>2.1.6 watch：监察属性/侦听器；</h4><ol>
<li><p>类型：<code>{ [key: string]: string | Function | Object | Array }</code></p>
</li>
<li><p>详细：</p>
<blockquote>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
</blockquote>
</li>
<li><p>示例：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    d: <span class="number">4</span>,</span><br><span class="line">    e: &#123;</span><br><span class="line">      f: &#123;</span><br><span class="line">        g: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    b: <span class="string">'someMethod'</span>,</span><br><span class="line">    <span class="comment">// 深度 watcher</span></span><br><span class="line">    c: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    d: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    e: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle1</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle2</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// watch vm.e.f's value: &#123;g: 5&#125;</span></span><br><span class="line">    <span class="string">'e.f'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="number">2</span> <span class="comment">// =&gt; new: 2, old: 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code> )。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>
</blockquote>
<h3 id="2-2-选项-DOM"><a href="#2-2-选项-DOM" class="headerlink" title="2.2 选项-DOM"></a>2.2 选项-DOM</h3><h4 id="2-2-1-el：提供一个在页面上已存在的-DOM-元素作为-Vue-实例的挂载目标；"><a href="#2-2-1-el：提供一个在页面上已存在的-DOM-元素作为-Vue-实例的挂载目标；" class="headerlink" title="2.2.1 el：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标；"></a>2.2.1 el：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标；</h4><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></p>
</blockquote>
<ol>
<li>类型：<code>string | HTMLElement</code></li>
<li>限制：<code>只在由 new 创建的实例中遵守</code>。</li>
<li>详细：<blockquote>
<p>提供一个在页面上<strong>已存在的 DOM 元素</strong>作为 <strong>Vue 实例的挂载目标</strong>。可以是 CSS 选择器，也可以是一个 <strong>HTMLElement 实例</strong>。<br><br><br>在实例挂载之后，元素可以用 <strong>vm.$el</strong> 访问。<br><br><br>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <strong>vm.$mount()</strong> 手动开启编译。<br><br></p>
</blockquote>
</li>
</ol>
<p><strong>提供的元素只能作为挂载点</strong>。不同于 Vue 1.x，<strong>所有的挂载元素会被 Vue 生成的 DOM 替换</strong>。因此<strong>不推荐挂载 root 实例到 <html> 或者 <body></body></html></strong> 上。<br><br><br>如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>
<h4 id="2-2-2-template：作为-Vue-实例的标识使用，模板将会替换挂载的元素；"><a href="#2-2-2-template：作为-Vue-实例的标识使用，模板将会替换挂载的元素；" class="headerlink" title="2.2.2  template：作为 Vue 实例的标识使用，模板将会替换挂载的元素；"></a>2.2.2  template：作为 Vue 实例的标识使用，模板将会替换挂载的元素；</h4><ol>
<li>类型：<code>string</code></li>
<li>详细：<blockquote>
<p>一个字符串模板作为 Vue 实例的标识使用。模板将会 <strong>替换</strong> 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有<strong>分发插槽</strong>。<br><br><br>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 <code>innerHTML</code> 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。<br><br><br>出于安全考虑，你应该只使用你信任的 <code>Vue</code> 模板。避免使用其他人生成的内容作为你的模板。<br><br><br>如果 Vue 选项中包含渲染函数，该模板将被忽略。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87%E6%8F%92%E6%A7%BD%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9" target="_blank" rel="noopener">用插槽分发内容</a></p>
</blockquote>
<h4 id="2-2-3-render-渲染函数"><a href="#2-2-3-render-渲染函数" class="headerlink" title="2.2.3  render: 渲染函数"></a>2.2.3  render: <a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a></h4><ol>
<li>类型：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></li>
<li>详细：<blockquote>
<p>字符串模板的代替方案，允许你发挥 <code>JavaScript</code> 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 VNode。<br><br><br>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。<br><br><br>Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 <code>HTML</code> 模板编译渲染函数。</p>
</blockquote>
</li>
</ol>
<h4 id="2-2-4-renderError-2-2-0-新增-：处理-render-函数遇到的错误；"><a href="#2-2-4-renderError-2-2-0-新增-：处理-render-函数遇到的错误；" class="headerlink" title="2.2.4  renderError(2.2.0 新增)：处理 render 函数遇到的错误；"></a>2.2.4  renderError(2.2.0 新增)：处理 render 函数遇到的错误；</h4><ol>
<li>类型：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></li>
<li>详细：<blockquote>
<p>只在开发者环境下工作。<br><br><br>当 <code>render</code> 函数遭遇 <strong>错误</strong> 时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 <code>hot-reload</code> 非常实用。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'pre'</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;&#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-3-选项-生命周期钩子"><a href="#2-3-选项-生命周期钩子" class="headerlink" title="2.3 选项-生命周期钩子"></a>2.3 选项-生命周期钩子</h3><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></p>
</blockquote>
<h4 id="2-3-1-beforeCreate：vm-实例对象初始化之后，data-methods…-初始化前；"><a href="#2-3-1-beforeCreate：vm-实例对象初始化之后，data-methods…-初始化前；" class="headerlink" title="2.3.1 beforeCreate：vm 实例对象初始化之后，data/methods… 初始化前；"></a>2.3.1 beforeCreate：vm 实例对象初始化之后，data/methods… 初始化前；</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>在实例初始化之后，数据观测 <code>(data observer) 和 event/watcher</code> 事件配置之前被调用。</p>
</blockquote>
</li>
</ol>
<h4 id="2-3-2-created：data-methods…-初始化完成，但是还没有进行挂载；"><a href="#2-3-2-created：data-methods…-初始化完成，但是还没有进行挂载；" class="headerlink" title="2.3.2 created：data/methods… 初始化完成，但是还没有进行挂载；"></a>2.3.2 created：data/methods… 初始化完成，但是还没有进行挂载；</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，<strong>挂载阶段还没开始</strong>，<code>$el</code> 属性目前不可见。</p>
</blockquote>
</li>
</ol>
<h4 id="2-3-3-beforeMount：vm-实例挂载之前"><a href="#2-3-3-beforeMount：vm-实例挂载之前" class="headerlink" title="2.3.3 beforeMount：vm 实例挂载之前;"></a>2.3.3 beforeMount：vm 实例挂载之前;</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br><br></p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用</strong>。</p>
<h4 id="2-3-4-mounted：el-被新创建的-vm-el-替换，并挂载到实例上去之后；"><a href="#2-3-4-mounted：el-被新创建的-vm-el-替换，并挂载到实例上去之后；" class="headerlink" title="2.3.4 mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后；"></a>2.3.4 mounted：<code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后；</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<br><br><br>注意 <code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code>;<br><br></p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h4 id="2-3-5-beforeUpdate：数据更新时调用，组件-DOM-更新之前，用于操作现有的DOM；"><a href="#2-3-5-beforeUpdate：数据更新时调用，组件-DOM-更新之前，用于操作现有的DOM；" class="headerlink" title="2.3.5 beforeUpdate：数据更新时调用，组件 DOM 更新之前，用于操作现有的DOM；"></a>2.3.5 beforeUpdate：数据更新时调用，组件 <code>DOM</code> 更新之前，用于操作现有的DOM；</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<br><br></p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
<h4 id="2-3-6-updated：数据更新时调用，虚拟-DOM-重新渲染，组件-DOM-已经更新；"><a href="#2-3-6-updated：数据更新时调用，虚拟-DOM-重新渲染，组件-DOM-已经更新；" class="headerlink" title="2.3.6 updated：数据更新时调用，虚拟 DOM 重新渲染，组件 DOM 已经更新；"></a>2.3.6 updated：数据更新时调用，虚拟 DOM 重新渲染，组件 <code>DOM</code> 已经更新；</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br><br><br>当这个钩子被调用时，组件 <code>DOM</code> 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br><br><br>注意 <code>updated</code> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>updated</code>：</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been re-rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="2-3-7-activated"><a href="#2-3-7-activated" class="headerlink" title="2.3.7 activated"></a>2.3.7 activated</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p><code>keep-alive</code> 组件激活时调用。<br><br><br><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">keep-alive API 文档</a><br><br><br><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener">动态组件上使用 keep-alive</a></p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="2-3-8-deactivated"><a href="#2-3-8-deactivated" class="headerlink" title="2.3.8 deactivated"></a>2.3.8 deactivated</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>keep-alive 组件停用时调用。</p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="2-3-9-beforeDestroy：Vue-实例销毁前调用"><a href="#2-3-9-beforeDestroy：Vue-实例销毁前调用" class="headerlink" title="2.3.9 beforeDestroy：Vue 实例销毁前调用;"></a>2.3.9 beforeDestroy：Vue 实例销毁前调用;</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="2-3-10-destroyed：Vue-实例销毁后调用"><a href="#2-3-10-destroyed：Vue-实例销毁后调用" class="headerlink" title="2.3.10 destroyed：Vue 实例销毁后调用;"></a>2.3.10 destroyed：Vue 实例销毁后调用;</h4><ol>
<li>类型：<code>Function</code></li>
<li>详细：<blockquote>
<p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
</blockquote>
</li>
</ol>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="2-3-11-errorCaptured-2-5-0-新增-：捕获一个来自子孙组件的错误时被调用；"><a href="#2-3-11-errorCaptured-2-5-0-新增-：捕获一个来自子孙组件的错误时被调用；" class="headerlink" title="2.3.11 errorCaptured(2.5.0+ 新增)：捕获一个来自子孙组件的错误时被调用；"></a>2.3.11 errorCaptured(2.5.0+ 新增)：捕获一个来自子孙组件的错误时被调用；</h4><ol>
<li><p>类型：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
</li>
<li><p>详细：</p>
<blockquote>
<p>当捕获一个来自<strong>子孙组件的错误时被调用</strong>。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。<br><br><br>你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。</p>
</blockquote>
</li>
<li><p>错误传播规则: </p>
<blockquote>
<p>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。<br><br><br>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。<br><br><br>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler。</code><br><br><br>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</p>
</blockquote>
</li>
</ol>
<h3 id="2-4-选项-资源"><a href="#2-4-选项-资源" class="headerlink" title="2.4 选项-资源"></a>2.4 选项-资源</h3><h4 id="2-4-1-directives：局部自定义指令"><a href="#2-4-1-directives：局部自定义指令" class="headerlink" title="2.4.1 directives：局部自定义指令"></a>2.4.1 directives：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">局部自定义指令</a></h4><ol>
<li>类型：<code>Object</code></li>
<li>详细：<blockquote>
<p>包含 Vue 实例可用指令的哈希表。</p>
</blockquote>
</li>
</ol>
<h4 id="2-4-2-filters：局部自定义过滤器；"><a href="#2-4-2-filters：局部自定义过滤器；" class="headerlink" title="2.4.2 filters：局部自定义过滤器；"></a>2.4.2 filters：局部自定义过滤器；</h4><ol>
<li>类型：<code>Object</code></li>
<li>详细：<blockquote>
<p>包含 Vue 实例可用过滤器的哈希表。</p>
</blockquote>
</li>
</ol>
<h4 id="2-4-3-components：用于引入的组件进行注册；局部组件"><a href="#2-4-3-components：用于引入的组件进行注册；局部组件" class="headerlink" title="2.4.3 components：用于引入的组件进行注册；局部组件"></a>2.4.3 components：用于引入的组件进行注册；<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">局部组件</a></h4><ol>
<li>类型：<code>Object</code></li>
<li>详细：<blockquote>
<p>包含 Vue 实例可用组件的哈希表。</p>
</blockquote>
</li>
</ol>
<h3 id="未学习-5-选项-组合"><a href="#未学习-5-选项-组合" class="headerlink" title="(未学习)(5). 选项-组合"></a>(未学习)(5). 选项-组合</h3><h4 id="1-parent"><a href="#1-parent" class="headerlink" title="1. parent"></a>1. parent</h4><h4 id="2-mixins"><a href="#2-mixins" class="headerlink" title="2. mixins"></a>2. mixins</h4><h4 id="3-extends"><a href="#3-extends" class="headerlink" title="3. extends"></a>3. extends</h4><h4 id="4-provide-inject"><a href="#4-provide-inject" class="headerlink" title="4. provide / inject"></a>4. provide / inject</h4><h3 id="未学习-6-选项-其它"><a href="#未学习-6-选项-其它" class="headerlink" title="(未学习)(6). 选项-其它"></a>(未学习)(6). 选项-其它</h3><h4 id="1-name"><a href="#1-name" class="headerlink" title="1. name"></a>1. name</h4><h4 id="2-delimiters"><a href="#2-delimiters" class="headerlink" title="2. delimiters"></a>2. delimiters</h4><h4 id="3-functional"><a href="#3-functional" class="headerlink" title="3. functional"></a>3. functional</h4><h4 id="4-model"><a href="#4-model" class="headerlink" title="4. model"></a>4. model</h4><h4 id="5-inheritAttrs"><a href="#5-inheritAttrs" class="headerlink" title="5. inheritAttrs"></a>5. inheritAttrs</h4><h4 id="6-comments"><a href="#6-comments" class="headerlink" title="6. comments"></a>6. comments</h4><h2 id="3-实例-通过-vm-xxx-调用-属性-方法-数据-方法-事件-方法-生命周期-："><a href="#3-实例-通过-vm-xxx-调用-属性-方法-数据-方法-事件-方法-生命周期-：" class="headerlink" title="3. 实例-通过 vm.$xxx 调用(属性/方法-数据/方法-事件/方法-生命周期)："></a>3. 实例-<code>通过 vm.$xxx 调用</code>(属性/方法-数据/方法-事件/方法-生命周期)：</h2><h3 id="3-1-实例属性"><a href="#3-1-实例属性" class="headerlink" title="3.1  实例属性"></a>3.1  实例属性</h3><h4 id="3-1-1-vm-data：Vue-实例观察的数据对象；"><a href="#3-1-1-vm-data：Vue-实例观察的数据对象；" class="headerlink" title="3.1.1 vm.$data：Vue 实例观察的数据对象；"></a>3.1.1 vm.$data：Vue 实例观察的数据对象；</h4><ol>
<li>类型：<code>Object</code></li>
<li>详细：<blockquote>
<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-2-vm-props：-当前组件接收到的-props-对象；"><a href="#3-1-2-vm-props：-当前组件接收到的-props-对象；" class="headerlink" title="3.1.2 vm.$props： 当前组件接收到的 props 对象；"></a>3.1.2 vm.$props： 当前组件接收到的 props 对象；</h4><ol>
<li>类型：<code>Object</code></li>
<li>详细：<blockquote>
<p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-3-vm-el：Vue-实例使用的根-DOM-元素；"><a href="#3-1-3-vm-el：Vue-实例使用的根-DOM-元素；" class="headerlink" title="3.1.3 vm.$el：Vue 实例使用的根 DOM 元素；"></a>3.1.3 vm.$el：Vue 实例使用的根 DOM 元素；</h4><ol>
<li>类型：<code>HTMLElement</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>Vue 实例使用的根 DOM 元素。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-4-vm-options：当前-Vue-实例的初始化选项（包含自定义属性）；"><a href="#3-1-4-vm-options：当前-Vue-实例的初始化选项（包含自定义属性）；" class="headerlink" title="3.1.4 vm.$options：当前 Vue 实例的初始化选项（包含自定义属性）；"></a>3.1.4 vm.$options：当前 Vue 实例的初始化选项（包含自定义属性）；</h4><ol>
<li>类型：<code>Object</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  customOption: <span class="string">'foo'</span>,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption) <span class="comment">// =&gt; 'foo'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-vm-parent：当前实例的父实例；"><a href="#3-1-5-vm-parent：当前实例的父实例；" class="headerlink" title="3.1.5 vm.$parent：当前实例的父实例；"></a>3.1.5 vm.$parent：当前实例的父实例；</h4><ol>
<li>类型：<code>Vue instance</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>父实例，如果当前实例有的话。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-6-vm-root：当前组件树的根-Vue-实例；"><a href="#3-1-6-vm-root：当前组件树的根-Vue-实例；" class="headerlink" title="3.1.6 vm.$root：当前组件树的根 Vue 实例；"></a>3.1.6 vm.$root：当前组件树的根 Vue 实例；</h4><ol>
<li>类型：<code>Vue instance</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>当前组件树的根 <code>Vue</code> 实例。如果当前实例没有父实例，此实例将会是其自己。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-7-vm-children：当前实例的直接子组件；"><a href="#3-1-7-vm-children：当前实例的直接子组件；" class="headerlink" title="3.1.7 vm.$children：当前实例的直接子组件；"></a>3.1.7 vm.$children：当前实例的直接子组件；</h4><ol>
<li>类型：<code>Array&lt;Vue instance&gt;</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>当前实例的直接子组件。需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 <code>Array</code> 作为真正的来源。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-8-vm-slots：用来访问被插槽分发的内容；"><a href="#3-1-8-vm-slots：用来访问被插槽分发的内容；" class="headerlink" title="3.1.8 vm.$slots：用来访问被插槽分发的内容；"></a>3.1.8 vm.$slots：用来访问被插槽分发的内容；</h4><ol>
<li>类型：<code>{ [name: string]: ?Array&lt;VNode&gt; }</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>用来访问<strong>被插槽分发的内容</strong>。每个<strong>具名插槽</strong> 有其相应的属性 (例如：<code>slot=&quot;foo&quot;</code> 中的内容将会在 <code>vm</code>.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点。<br><br><br>在使用<strong>渲染函数</strong>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    About Me</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">    Copyright 2016 Evan You</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> header = <span class="keyword">this</span>.$slots.header</span><br><span class="line">    <span class="keyword">var</span> body   = <span class="keyword">this</span>.$slots.default</span><br><span class="line">    <span class="keyword">var</span> footer = <span class="keyword">this</span>.$slots.footer</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">      createElement(<span class="string">'header'</span>, header),</span><br><span class="line">      createElement(<span class="string">'main'</span>, body),</span><br><span class="line">      createElement(<span class="string">'footer'</span>, footer)</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-9-vm-scopedSlots-2-1-0-新增-：用来访问作用域插槽；"><a href="#3-1-9-vm-scopedSlots-2-1-0-新增-：用来访问作用域插槽；" class="headerlink" title="3.1.9 vm.$scopedSlots(2.1.0 新增)：用来访问作用域插槽；"></a>3.1.9 vm.$scopedSlots(2.1.0 新增)：用来访问作用域插槽；</h4><ol>
<li>类型：<code>{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; }</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>用来访问作用域插槽。对于包括 默认 <code>slot</code> 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。<br><br><br><code>vm.$scopedSlots</code> 在使用渲染函数开发一个组件时特别有用。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-10-vm-refs：包含注册过-ref-特性-的所有-DOM-元素和组件实例；ref-属性介绍"><a href="#3-1-10-vm-refs：包含注册过-ref-特性-的所有-DOM-元素和组件实例；ref-属性介绍" class="headerlink" title="3.1.10 vm.$refs：包含注册过 ref 特性 的所有 DOM 元素和组件实例；ref 属性介绍"></a>3.1.10 vm.$refs：包含注册过 <code>ref</code> 特性 的所有 <code>DOM</code> 元素和组件实例；<a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener">ref 属性介绍</a></h4><ol>
<li>类型：<code>Object</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>一个对象，持有注册过 <code>ref</code> 特性 的所有 <code>DOM</code> 元素和组件实例。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-11-vm-isServer：当前-Vue-实例是否运行于服务器；"><a href="#3-1-11-vm-isServer：当前-Vue-实例是否运行于服务器；" class="headerlink" title="3.1.11 vm.$isServer：当前 Vue 实例是否运行于服务器；"></a>3.1.11 vm.$isServer：当前 Vue 实例是否运行于服务器；</h4><ol>
<li>类型：<code>boolean</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>当前 Vue 实例是否运行于服务器。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-12-vm-attrs"><a href="#3-1-12-vm-attrs" class="headerlink" title="3.1.12 vm.$attrs"></a>3.1.12 vm.$attrs</h4><ol>
<li>类型：<code>boolean</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-13-vm-listeners：包含了父作用域中的-不含-native-修饰器的-v-on-事件监听器；"><a href="#3-1-13-vm-listeners：包含了父作用域中的-不含-native-修饰器的-v-on-事件监听器；" class="headerlink" title="3.1.13 vm.$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器；"></a>3.1.13 vm.$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器；</h4><ol>
<li>类型：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></li>
<li>该属性 <strong>只读</strong></li>
<li>详细：<blockquote>
<p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</p>
</blockquote>
</li>
</ol>
<h3 id="3-2-实例方法-数据"><a href="#3-2-实例方法-数据" class="headerlink" title="3.2 实例方法-数据"></a>3.2 实例方法-数据</h3><h4 id="3-2-1-vm-watch-expOrFn-callback-options-：观察-Vue-实例变化的一个表达式或计算属性函数"><a href="#3-2-1-vm-watch-expOrFn-callback-options-：观察-Vue-实例变化的一个表达式或计算属性函数" class="headerlink" title="3.2.1 vm.$watch( expOrFn, callback, [options] )：观察 Vue 实例变化的一个表达式或计算属性函数;"></a>3.2.1 vm.$watch( expOrFn, callback, [options] )：观察 Vue 实例变化的一个表达式或计算属性函数;</h4><ol>
<li>参数：</li>
</ol>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;string | Function&#125; expOrFn</span><br><span class="line">&#123;Function | Object&#125; callback</span><br><span class="line">&#123;Object&#125; [options]</span><br><span class="line">· &#123;boolean&#125; deep</span><br><span class="line">· &#123;boolean&#125; immediate</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>返回值：<code>{Function} unwatch</code></p>
</li>
<li><p>用法：</p>
<blockquote>
<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。<br><br><br>注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>
</blockquote>
</li>
<li><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键路径</span></span><br><span class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做点什么</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">vm.$watch(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.$watch 返回一个取消观察函数，用来停止触发回调：</span></span><br><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, cb)</span><br><span class="line"><span class="comment">// 之后取消观察</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>选项：<code>deep</code> <br><br><br>为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// callback is fired</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：<code>immediate</code> <br><br><br>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 `a` 的当前值触发回调</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-vm-set-target-key-value-：全局-Vue-set-的别名；"><a href="#3-2-2-vm-set-target-key-value-：全局-Vue-set-的别名；" class="headerlink" title="3.2.2 vm.$set( target, key, value )：全局 Vue.set 的别名；"></a>3.2.2 vm.$set( target, key, value )：全局 Vue.set 的别名；</h4><ol>
<li>参数：<code>{Object | Array} target  {string | number} key  {any} value</code></li>
<li>返回值：<code>设置的值</code></li>
<li>用法：<blockquote>
<p>这是全局 Vue.set 的别名。</p>
</blockquote>
</li>
</ol>
<h4 id="3-2-3-vm-delete-target-key-：全局-Vue-delete-的别名；"><a href="#3-2-3-vm-delete-target-key-：全局-Vue-delete-的别名；" class="headerlink" title="3.2.3 vm.$delete( target, key )：全局 Vue.delete 的别名；"></a>3.2.3 vm.$delete( target, key )：全局 Vue.delete 的别名；</h4><ol>
<li>参数：<code>{Object | Array} target  {string | number} key</code></li>
<li>用法：<blockquote>
<p>这是全局 Vue.delete 的别名。</p>
</blockquote>
</li>
</ol>
<h3 id="3-3-实例方法-事件"><a href="#3-3-实例方法-事件" class="headerlink" title="3.3 实例方法-事件"></a>3.3 实例方法-事件</h3><h4 id="3-3-1-vm-on-event-callback-：监听当前实例上的自定义事件；"><a href="#3-3-1-vm-on-event-callback-：监听当前实例上的自定义事件；" class="headerlink" title="3.3.1 vm.$on( event, callback )：监听当前实例上的自定义事件；"></a>3.3.1 vm.$on( event, callback )：监听当前实例上的自定义事件；</h4><ol>
<li>参数：<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;string | Array&lt;string&gt;&#125; event (数组只在 <span class="number">2.2</span>.<span class="number">0</span>+ 中支持)</span><br><span class="line">&#123;Function&#125; callback</span><br></pre></td></tr></table></figure></li>
<li>用法：<blockquote>
<p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(<span class="string">'test'</span>, <span class="string">'hi'</span>)</span><br><span class="line"><span class="comment">// =&gt; "hi"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-3-2-vm-once-event-callback-：监听一个只触发一次的自定义事件；"><a href="#3-3-2-vm-once-event-callback-：监听一个只触发一次的自定义事件；" class="headerlink" title="3.3.2 vm.$once( event, callback )：监听一个只触发一次的自定义事件；"></a>3.3.2 vm.$once( event, callback )：监听一个只触发一次的自定义事件；</h4><ol>
<li>参数：<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;string&#125; event</span><br><span class="line">&#123;Function&#125; callback</span><br></pre></td></tr></table></figure></li>
<li>用法：<blockquote>
<p>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p>
</blockquote>
</li>
</ol>
<h4 id="3-3-3-vm-off-event-callback-：移除自定义事件监听器；"><a href="#3-3-3-vm-off-event-callback-：移除自定义事件监听器；" class="headerlink" title="3.3.3 vm.$off( [event, callback] )：移除自定义事件监听器；"></a>3.3.3 vm.$off( [event, callback] )：移除自定义事件监听器；</h4><ol>
<li>参数：<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;string | Array&lt;string&gt;&#125; event (只在 <span class="number">2.2</span>.<span class="number">2</span>+ 支持数组)</span><br><span class="line">&#123;Function&#125; [callback]</span><br></pre></td></tr></table></figure></li>
<li>用法：<blockquote>
<p>移除自定义事件监听器。</p>
</blockquote>
</li>
</ol>
<ul>
<li>如果没有提供参数，则移除所有的事件监听器；</li>
<li>如果只提供了事件，则移除该事件所有的监听器；</li>
<li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li>
</ul>
<h4 id="3-3-4-vm-emit-eventName-…args-：用于子组件向父组件传递事件和参数（发布订阅模式）；"><a href="#3-3-4-vm-emit-eventName-…args-：用于子组件向父组件传递事件和参数（发布订阅模式）；" class="headerlink" title="3.3.4 vm.$emit( eventName, […args] )：用于子组件向父组件传递事件和参数（发布订阅模式）；"></a>3.3.4 vm.$emit( eventName, […args] )：用于子组件向父组件传递事件和参数（发布订阅模式）；</h4><ol>
<li><p>参数：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&#123;string&#125; eventName</span><br><span class="line">[...args]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
</blockquote>
</li>
<li><p>示例：</p>
</li>
</ol>
<blockquote>
<p>子组件 :</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'magic-eight-ball'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      possibleAdvice: [<span class="string">'Yes'</span>, <span class="string">'No'</span>, <span class="string">'Maybe'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    giveAdvice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> randomAdviceIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.possibleAdvice.length)</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'give-advice'</span>, <span class="keyword">this</span>.possibleAdvice[randomAdviceIndex])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button v-on:click="giveAdvice"&gt;</span></span><br><span class="line"><span class="string">      Click me for advice</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父组件 :</p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&lt;div id<span class="built_in">=</span><span class="string">"emit-example-argument"</span>&gt;</span><br><span class="line">  &lt;magic-eight-ball v-on:give-advice<span class="built_in">=</span><span class="string">"showAdvice"</span>&gt;&lt;/magic-eight-ball&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#emit-example-argument'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showAdvice: function (advice) &#123;</span><br><span class="line">      alert(advice)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="（未学习）-4-实例方法-生命周期"><a href="#（未学习）-4-实例方法-生命周期" class="headerlink" title="（未学习）(4)实例方法-生命周期"></a>（未学习）(4)实例方法-生命周期</h3><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></p>
</blockquote>
<h4 id="1-vm-mount"><a href="#1-vm-mount" class="headerlink" title="1. vm.$mount"></a>1. vm.$mount</h4><h4 id="2-vm-forceUpdate"><a href="#2-vm-forceUpdate" class="headerlink" title="2. vm.$forceUpdate"></a>2. vm.$forceUpdate</h4><h4 id="3-vm-nextTick"><a href="#3-vm-nextTick" class="headerlink" title="3. vm.$nextTick"></a>3. vm.$nextTick</h4><h4 id="4-vm-destroy"><a href="#4-vm-destroy" class="headerlink" title="4. vm.$destroy"></a>4. vm.$destroy</h4><h2 id="4-指令操作："><a href="#4-指令操作：" class="headerlink" title="4. 指令操作："></a>4. 指令操作：</h2><h3 id="4-1-Vue-指令"><a href="#4-1-Vue-指令" class="headerlink" title="4.1 Vue 指令"></a>4.1 Vue 指令</h3><h4 id="4-1-1-v-text：更新元素的内容（整个内容全部更新），内容原本输出；"><a href="#4-1-1-v-text：更新元素的内容（整个内容全部更新），内容原本输出；" class="headerlink" title="4.1.1 v-text：更新元素的内容（整个内容全部更新），内容原本输出；"></a>4.1.1 v-text：更新元素的内容（整个内容全部更新），内容原本输出；</h4><ol>
<li>预期类型：<code>string</code></li>
<li>用法：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和下面的一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>意义：更新元素的 textContent。如果要更新部分的 textContent ，需要使用 Mustache 插值。</p>
</blockquote>
<h4 id="4-1-2-v-html：更新元素的内容（可以解析HTML代码内容）；"><a href="#4-1-2-v-html：更新元素的内容（可以解析HTML代码内容）；" class="headerlink" title="4.1.2 v-html：更新元素的内容（可以解析HTML代码内容）；"></a>4.1.2 v-html：更新元素的内容（可以解析HTML代码内容）；</h4><ol>
<li>预期类型：<code>string</code></li>
<li>用法：<br><code>&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</code></li>
</ol>
<blockquote>
<p>意义：更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p>
</blockquote>
<h4 id="4-1-3-v-show：条件渲染（display属性）；"><a href="#4-1-3-v-show：条件渲染（display属性）；" class="headerlink" title="4.1.3 v-show：条件渲染（display属性）；"></a>4.1.3 v-show：条件渲染（display属性）；</h4><ol>
<li>预期类型：<code>any</code></li>
<li>用法：<br><code>&lt;div v-show=&quot;表达式&quot;&gt;&lt;/div&gt;</code><blockquote>
<p>意义：根据表达式之真假值，切换元素的 display CSS 属性。<em>当条件变化时该指令触发过渡效果。</em></p>
</blockquote>
</li>
</ol>
<h4 id="4-1-4-v-if：条件渲染（是否加入DOM节点）；"><a href="#4-1-4-v-if：条件渲染（是否加入DOM节点）；" class="headerlink" title="4.1.4 v-if：条件渲染（是否加入DOM节点）；"></a>4.1.4 v-if：条件渲染（是否加入DOM节点）；</h4><ol>
<li>预期类型：<code>any</code></li>
<li>用法：<br><code>&lt;div v-if=&quot;表达式&quot;&gt;&lt;/div&gt;</code><blockquote>
<p>意义：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code> ，将提出它的内容作为条件块。<em>当条件变化时该指令触发过渡效果。</em><br>【注：当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。】</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-5-v-else：条件渲染，类似于if-else中的else部分；"><a href="#4-1-5-v-else：条件渲染，类似于if-else中的else部分；" class="headerlink" title="4.1.5 v-else：条件渲染，类似于if-else中的else部分；"></a>4.1.5 v-else：条件渲染，类似于if-else中的else部分；</h4><ol>
<li>不需要表达式</li>
<li>限制：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</li>
<li>用法：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>意义：为 v-if 或者 v-else-if 添加“else 块”。</p>
</blockquote>
<h4 id="4-1-6-v-else-if：条件渲染，表示-v-if-的-“else-if-块”，可以链式调用。"><a href="#4-1-6-v-else-if：条件渲染，表示-v-if-的-“else-if-块”，可以链式调用。" class="headerlink" title="4.1.6 v-else-if：条件渲染，表示 v-if 的 “else if 块”，可以链式调用。"></a>4.1.6 v-else-if：条件渲染，表示 v-if 的 “else if 块”，可以链式调用。</h4><ol>
<li>预期类型：<code>any</code></li>
<li>限制：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</li>
<li>用法：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span> A <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span> B <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span> C <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span> Not A/B/C <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>意义：表示 v-if 的 “else if 块”，可以链式调用。</p>
</blockquote>
<h4 id="4-1-7-v-for：列表渲染；"><a href="#4-1-7-v-for：列表渲染；" class="headerlink" title="4.1.7 v-for：列表渲染；"></a>4.1.7 v-for：<a href="https://cn.vuejs.org/v2/guide/list.html" target="_blank" rel="noopener">列表渲染</a>；</h4><ol>
<li>预期类型：<code>Array | Object | number | string</code></li>
<li>用法：<blockquote>
<p>2.1 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名：</p>
</blockquote>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.2 另外也可以为数组索引指定别名 (或者用于对象的键)：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key, index) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.3 v-for 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：需要为每项提供一个唯一 <strong>key 属性</strong>。理想的 <strong>key 值是每项都有的唯一 id</strong>。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值 ；</li>
</ol>
<h4 id="4-1-8-v-on：事件处理器；"><a href="#4-1-8-v-on：事件处理器；" class="headerlink" title="4.1.8 v-on：事件处理器；"></a>4.1.8 v-on：<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">事件处理器</a>；</h4><ol>
<li>缩写：<code>@</code></li>
<li>预期：<code>Function | Inline Statement | Object</code></li>
<li>参数：<code>event: click/keyup/keydown/mouseup/mousedown...</code></li>
<li>修饰符：</li>
</ol>
<ul>
<li><code>.stop</code> - 调用 event.stopPropagation()。</li>
<li><code>.prevent</code> - 调用 event.preventDefault()。</li>
<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
<li><code>.once</code> - 只触发一次回调。</li>
<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>
<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>
<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>
<li><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</li>
</ul>
<ol start="5">
<li>用法：<blockquote>
<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。<br><br>用在普通元素上时，只能监听原生 DOM 事件。 用在自定义元素组件上时，也可以监听子组件触发的自定义事件。<br><br>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：<code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。<br><br>从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。<br></p>
</blockquote>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThat('hello', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  串联修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"onEnter"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"onEnter"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击回调只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">"&#123; mousedown: doThis, mouseup: doThat &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis(123, $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件中的原生事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">"onClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-1-9-v-bind：-属性（类-样式…）绑定"><a href="#4-1-9-v-bind：-属性（类-样式…）绑定" class="headerlink" title="4.1.9 v-bind： 属性（类/样式…）绑定"></a>4.1.9 v-bind： 属性（类/样式…）绑定</h4><ol>
<li>缩写：<code>:</code></li>
<li>预期：<code>any (with argument) | Object (without argument)</code></li>
<li>参数：<code>attrOrProp (optional)</code></li>
<li>修饰符：</li>
</ol>
<ul>
<li><code>.prop</code> - 被用于绑定 DOM 属性 (property)。(差别在哪里？)</li>
<li><code>.camel</code> - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)</li>
<li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</li>
</ul>
<ol start="5">
<li>用法<blockquote>
<p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。<br><br>在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。<br><br>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。<br><br>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imageSrc"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"'/path/to/images/' + fileName"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">"someThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-bind</span>=<span class="string">"$props"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- XLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- .camel 修饰符允许在使用 DOM 模板时将 v-bind 属性名称驼峰化，例如 SVG 的 viewBox 属性： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">:view-box.camel</span>=<span class="string">"viewBox"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。 --&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-1-10-v-model：双向数据绑定；表单控件绑定"><a href="#4-1-10-v-model：双向数据绑定；表单控件绑定" class="headerlink" title="4.1.10 v-model：双向数据绑定；表单控件绑定"></a>4.1.10 v-model：双向数据绑定；<a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">表单控件绑定</a></h4><ol>
<li><code>预期：随表单控件类型不同而不同。</code></li>
<li>限制：<code>&lt;input&gt; &lt;select&gt; &lt;textarea&gt; components</code></li>
<li>修饰符：</li>
</ol>
<ul>
<li><code>.lazy</code> - 取代 input 监听 change 事件</li>
<li><code>.number</code> - 输入字符串转为有效的数字</li>
<li><code>.trim</code> - 输入首尾空格过滤</li>
</ul>
<ol start="4">
<li>用法：<blockquote>
<p>在表单控件或者组件上创建双向绑定。</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-11-v-pre：跳过这个元素和它的子元素的编译过程；"><a href="#4-1-11-v-pre：跳过这个元素和它的子元素的编译过程；" class="headerlink" title="4.1.11 v-pre：跳过这个元素和它的子元素的编译过程；"></a>4.1.11 v-pre：跳过这个元素和它的子元素的编译过程；</h4><ol>
<li><code>不需要表达式</code></li>
<li>用法：<blockquote>
<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-1-12-v-cloak：该指令保持在元素上直到关联实例结束编译，隐藏未编译的-Mustache-标签直到实例准备完毕；"><a href="#4-1-12-v-cloak：该指令保持在元素上直到关联实例结束编译，隐藏未编译的-Mustache-标签直到实例准备完毕；" class="headerlink" title="4.1.12 v-cloak：该指令保持在元素上直到关联实例结束编译，隐藏未编译的 Mustache 标签直到实例准备完毕；"></a>4.1.12 v-cloak：该指令保持在元素上直到关联实例结束编译，隐藏未编译的 Mustache 标签直到实例准备完毕；</h4><ol>
<li><code>不需要表达式</code></li>
<li>用法：<blockquote>
<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>意义：不会显示，直到编译结束。</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-13-v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新。"><a href="#4-1-13-v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新。" class="headerlink" title="4.1.13 v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新。"></a>4.1.13 v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新。</h4><ol>
<li><code>不需要表达式</code></li>
<li>详细：<blockquote>
<p>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
</blockquote>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单个元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `v-for` 指令--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注：请留心这会影响到该节点上的其它数据绑定；</strong></p>
<h2 id="5-其他部分-特殊特性-内置的组件"><a href="#5-其他部分-特殊特性-内置的组件" class="headerlink" title="5. 其他部分(特殊特性/内置的组件)"></a>5. 其他部分(特殊特性/内置的组件)</h2><h3 id="5-1-特殊特性"><a href="#5-1-特殊特性" class="headerlink" title="5.1 特殊特性"></a>5.1 特殊特性</h3><h4 id="5-1-1-key"><a href="#5-1-1-key" class="headerlink" title="5.1.1 key"></a>5.1.1 key</h4><ol>
<li>预期类型：<code>number | string</code></li>
<li>详细：<blockquote>
<p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。<br><br><br>有相同父元素的子元素必须<strong>有独特的 key</strong>。重复的 key 会造成渲染错误。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 结合 v-for 的用例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>key</strong> 也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：a. 完整地触发组件的生命周期钩子; b. 触发过渡;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 text 发生改变时，&lt;span&gt; 会随时被更新，因此会触发过渡。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-ref：给元素或子组件注册引用信息，信息将会注册在父组件的-refs-对象上；子组件Refs"><a href="#5-1-2-ref：给元素或子组件注册引用信息，信息将会注册在父组件的-refs-对象上；子组件Refs" class="headerlink" title="5.1.2 ref：给元素或子组件注册引用信息，信息将会注册在父组件的 $refs 对象上；子组件Refs"></a>5.1.2 ref：给元素或子组件注册引用信息，信息将会注册在父组件的 $refs 对象上；<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">子组件Refs</a></h4><ol>
<li>预期类型：<code>string</code></li>
<li>详细：<blockquote>
<p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例；<br><br><br>当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。<br><br><br>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在普通的 DOM 元素上使用，引用指向的就是 DOM 元素 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在子组件上，引用就指向组件实例 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-slot：用于标记往哪个具名插槽中插入子组件内容；具名插槽"><a href="#5-1-3-slot：用于标记往哪个具名插槽中插入子组件内容；具名插槽" class="headerlink" title="5.1.3 slot：用于标记往哪个具名插槽中插入子组件内容；具名插槽"></a>5.1.3 slot：用于标记往哪个具名插槽中插入子组件内容；<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD" target="_blank" rel="noopener">具名插槽</a></h4><ol>
<li>预期类型：<code>string</code></li>
<li>详细：<blockquote>
<p>用于标记往哪个具名插槽中插入子组件内容。</p>
</blockquote>
</li>
</ol>
<h4 id="5-1-4-slot-scope-2-5-0-新增-替代了-scope-：用于将元素或组件表示为作用域插槽；作用域插槽"><a href="#5-1-4-slot-scope-2-5-0-新增-替代了-scope-：用于将元素或组件表示为作用域插槽；作用域插槽" class="headerlink" title="5.1.4 slot-scope(2.5.0+ 新增,替代了 scope)：用于将元素或组件表示为作用域插槽；作用域插槽"></a>5.1.4 slot-scope(2.5.0+ 新增,替代了 scope)：用于将元素或组件表示为作用域插槽；<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" target="_blank" rel="noopener">作用域插槽</a></h4><ol>
<li>预期类型：<code>function argument expression</code></li>
<li>详细：<blockquote>
<p>用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。<br><br><br>此属性<strong>不支持动态绑定</strong>。</p>
</blockquote>
</li>
</ol>
<h4 id="5-1-5-scope-2-5-0-中被-slot-scope-替代"><a href="#5-1-5-scope-2-5-0-中被-slot-scope-替代" class="headerlink" title="5.1.5 scope(2.5.0+ 中被 slot-scope 替代)"></a>5.1.5 scope(2.5.0+ 中被 slot-scope 替代)</h4><ol>
<li>详细：<blockquote>
<p>用于表示一个作为带作用域的插槽的 <code>&lt;template&gt;</code> 元素。</p>
</blockquote>
</li>
<li>用法：<blockquote>
<p>除了 scope 只可以用于 <code>&lt;template&gt;</code> 元素，其它和 slot-scope 都相同。</p>
</blockquote>
</li>
</ol>
<h4 id="5-1-6-is：动态组件-DOM-内模板的限制"><a href="#5-1-6-is：动态组件-DOM-内模板的限制" class="headerlink" title="5.1.6 is：动态组件 / DOM 内模板的限制"></a>5.1.6 is：<a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">动态组件</a> / <a href="https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">DOM 内模板的限制</a></h4><ol>
<li>预期类型：<code>string | Object (组件的选项对象)</code></li>
<li>详细：<blockquote>
<p>用于<strong>动态组件</strong>且基于<strong>DOM 内模板的限制</strong>来工作。</p>
</blockquote>
</li>
<li>示例：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-内置的组件"><a href="#5-2-内置的组件" class="headerlink" title="5.2 内置的组件"></a>5.2 内置的组件</h3><h4 id="5-2-1-component-：渲染一个“元组件”为动态组件；动态组件"><a href="#5-2-1-component-：渲染一个“元组件”为动态组件；动态组件" class="headerlink" title="5.2.1 component ：渲染一个“元组件”为动态组件；动态组件"></a>5.2.1 component ：渲染一个“元组件”为动态组件；<a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">动态组件</a></h4><ol>
<li>Props：</li>
</ol>
<ul>
<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>
<li><code>inline-template</code> - boolean</li>
</ul>
<ol start="2">
<li>用法：渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</li>
<li>示例：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"componentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"$options.components.child"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-transition：单个元素-组件的过渡效果；过渡：进入，离开和列表"><a href="#5-2-2-transition：单个元素-组件的过渡效果；过渡：进入，离开和列表" class="headerlink" title="5.2.2 transition：单个元素/组件的过渡效果；过渡：进入，离开和列表"></a>5.2.2 transition：单个元素/组件的过渡效果；<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">过渡：进入，离开和列表</a></h4><ol>
<li>Props：</li>
</ol>
<ul>
<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：name: ‘fade’ 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 “v”</li>
<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 false。</li>
<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。</li>
<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 “transition” 和 “animation”。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>
<li><code>mode</code> - string，控制离开/进入的过渡时间序列。有效的模式有 “out-in” 和 “in-out”；默认同时生效。</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>enter-to-class</code> - string</li>
<li><code>leave-to-class</code> - string</li>
<li><code>appear-to-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
<ol start="2">
<li>事件：</li>
</ol>
<ul>
<li><code>before-enter</code></li>
<li><code>before-leave</code></li>
<li><code>before-appear</code></li>
<li><code>enter</code></li>
<li><code>leave</code></li>
<li><code>appear</code></li>
<li><code>after-enter</code></li>
<li><code>after-leave</code></li>
<li><code>after-appear</code></li>
<li><code>enter-cancelled</code></li>
<li><code>leave-cancelled (v-show only)</code></li>
<li><code>appear-cancelled</code></li>
</ul>
<ol start="3">
<li><p>用法：</p>
<blockquote>
<p><code>&lt;transition&gt;</code> 元素作为<code>单个元素/组件</code>的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。</p>
</blockquote>
</li>
<li><p>示例代码：</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简单元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span> <span class="attr">appear</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事件钩子 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"transition-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> @<span class="attr">after-enter</span>=<span class="string">"transitionComplete"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    transitionComplete: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 传入 'el' 这个 DOM 元素作为参数。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;).$mount(<span class="string">'#transition-demo'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-transition-group：-多个元素-组件的过渡效果；过渡：进入，离开和列表"><a href="#5-2-3-transition-group：-多个元素-组件的过渡效果；过渡：进入，离开和列表" class="headerlink" title="5.2.3 transition-group： 多个元素/组件的过渡效果；过渡：进入，离开和列表"></a>5.2.3 transition-group： 多个元素/组件的过渡效果；<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">过渡：进入，离开和列表</a></h4><ol>
<li>Props：</li>
</ol>
<ul>
<li><code>tag</code> - string，默认为 span</li>
<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>
<li>除了 <code>mode</code>，其他特性和 <code>&lt;transition&gt;</code> 相同。</li>
</ul>
<ol start="2">
<li>事件： 事件和 <code>&lt;transition&gt;</code> 相同。</li>
<li>用法：<blockquote>
<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 <code>DOM</code> 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 tag 属性配置哪个元素应该被渲染。<br><br><br>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有 独立的 key ，动画才能正常工作<br><br><br><br><code>&lt;transition-group&gt;</code> 支持通过 <code>CSS transform</code> 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类 (通过 name 属性或配置 move-class 属性自动生成)。如果 <code>CSS transform</code> 属性是“可过渡”属性，当应用移动类时，将会使用 FLIP 技术 使元素流畅地到达动画终点。</p>
</blockquote>
</li>
<li>示例代码：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"slide"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="5-2-4-keep-alive：保留组件状态或避免重新渲染；动态组件-keep-alive"><a href="#5-2-4-keep-alive：保留组件状态或避免重新渲染；动态组件-keep-alive" class="headerlink" title="5.2.4 keep-alive：保留组件状态或避免重新渲染；动态组件 - keep-alive"></a>5.2.4 keep-alive：保留组件状态或避免重新渲染；<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></h4><ol>
<li>Props：</li>
</ol>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
<ol start="2">
<li><p>用法：</p>
<blockquote>
<p>主要用于保留组件状态或避免重新渲染。 <br><br><br><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><br><br>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
</blockquote>
</li>
<li><p>示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个条件判断的子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-a</span> <span class="attr">v-if</span>=<span class="string">"a &gt; 1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-b</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【注意，<code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt;</code> 要求同时只有一个子元素被渲染。】</p>
</li>
<li><p><strong>include 和 exclude 属性(2.1.0 新增)：允许组件有条件地缓存；</strong></p>
</li>
</ol>
<blockquote>
<p>include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逗号分隔字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"/a|b/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"['a', 'b']"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>【匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。】</p>
<ol start="5">
<li><strong>max(2.5.0 新增)：最多可以缓存多少组件实例；</strong><blockquote>
<p>最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>
</blockquote>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:max</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【<code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。】</p>
<h4 id="5-2-5-slot：插槽分发内容；"><a href="#5-2-5-slot：插槽分发内容；" class="headerlink" title="5.2.5 slot：插槽分发内容；"></a>5.2.5 slot：插槽分发内容；</h4><ol>
<li>Props：</li>
</ol>
<ul>
<li><code>name</code> - string，用于命名插槽。</li>
</ul>
<ol start="2">
<li>Usage：<blockquote>
<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。<code>&lt;slot&gt;</code> 元素自身将被替换。</p>
</blockquote>
</li>
<li>详细用法: <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87%E6%8F%92%E6%A7%BD%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9" target="_blank" rel="noopener">使用插槽分发内容</a></li>
<li>示例代码：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component('alert-box', &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-alert-box"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Error!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">// 子组件实例化使用</span><br><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VueJs</category>
        <category>VueAPI官方文档</category>
      </categories>
      <tags>
        <tag>Vue入门</tag>
        <tag>Vue官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue官方文档笔记2——深入了解组件</title>
    <url>/2018/12/21/Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>Vue官方文档笔记2——深入了解组件</p>
<a id="more"></a>
<h2 id="Vue官方文档笔记2——深入了解组件"><a href="#Vue官方文档笔记2——深入了解组件" class="headerlink" title="Vue官方文档笔记2——深入了解组件"></a>Vue官方文档笔记2——深入了解组件</h2><h2 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1.组件注册"></a>1.组件注册</h2><h3 id="1-1-组件名"><a href="#1-1-组件名" class="headerlink" title="1.1 组件名"></a>1.1 组件名</h3><p>在全局注册的时候,组件名就是 Vue.component 的第一个参数,组件命名采用驼峰式命名法或者短横线分隔命名法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-全局注册"><a href="#1-2-全局注册" class="headerlink" title="1.2 全局注册"></a>1.2 全局注册</h3><p>通过 Vue.component 来创建组件，在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'component-a'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-局部注册"><a href="#1-3-局部注册" class="headerlink" title="1.3 局部注册"></a>1.3 局部注册</h3><p>通过一个普通的 <code>JavaScript</code> 对象来定义组件,然后在 <code>components</code> 选项中定义你想要使用的组件； <code>components</code> 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意:局部注册的组件在其子组件中不可用;</p>
<h3 id="1-4-模块系统"><a href="#1-4-模块系统" class="headerlink" title="1.4 模块系统"></a>1.4 模块系统</h3><p>在模块系统中局部注册:<br><br>首先需要在局部注册之前导入每个你想使用的组件，然后再加入到组件属性中,例如在ComponentB中引入ComponentA和ComponentC 组件，进行逻辑处理后在 <code>export</code> 出去；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础组件的自动化全局注册：<br><br>可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件；在应用入口文件 (比如 <code>src/main.js</code>) 中全局导入基础组件的示例代码(加载顺序以及正则的相关知识):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 剥去文件名开头的 `./` 和结尾的扩展名</span></span><br><span class="line">      fileName.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">'$1'</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生；</p>
<h2 id="2-Prop"><a href="#2-Prop" class="headerlink" title="2.Prop"></a>2.Prop</h2><h3 id="2-1-Prop的大小写"><a href="#2-1-Prop的大小写" class="headerlink" title="2.1 Prop的大小写"></a>2.1 Prop的大小写</h3><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你使用字符串模板，那么这个限制就不存在了;</p>
<h3 id="2-2-Prop-类型"><a href="#2-2-Prop-类型" class="headerlink" title="2.2 Prop 类型"></a>2.2 Prop 类型</h3><p>可以以字符串数组形式或是以对象形式(对象中可以指定的值类型)；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'title'</span>, <span class="string">'likes'</span>, <span class="string">'isPublished'</span>]</span><br><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br><span class="line">props: &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    type:<span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-传递静态或动态-Prop"><a href="#2-3-传递静态或动态-Prop" class="headerlink" title="2.3 传递静态或动态 Prop"></a>2.3 传递静态或动态 Prop</h3><p>静态：<code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code></p>
<p>动态：使用 <code>v-bind</code> 指令动态赋值，prop可以接受任何类型的值；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title + ' by ' + post.author.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不仅可以传字符串，还可以传入数字、布尔值、数组、对象、一个对象的所有属性(使用不带参数的 v-bind (取代 v-bind:prop-name))等等；</p>
<h3 id="2-4-单向数据流"><a href="#2-4-单向数据流" class="headerlink" title="2.4 单向数据流"></a>2.4 单向数据流</h3><p>所有的 <code>prop</code> 都使得其父子 <code>prop</code> 之间形成了一个单向下行绑定(父组件传向子组件),每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值,若在子组件中修改props值，Vue 代码会出现警告；</p>
<p>我们一般通过两种方式接收父组件向子组件传递的 <code>prop</code> 属性的值：</p>
<ul>
<li>方法1： prop 用来传递一个初始值，子组件将其作为一个本地的 prop 数据来使用，则定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：prop 以一种原始的值传入且需要进行转换，则使用这个 prop 的值来定义一个计算属性：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// trim() 方法去除字符序列左边和右边的空格；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态;</p>
<h3 id="2-5-Prop-验证-为组件的-prop-指定验证要求"><a href="#2-5-Prop-验证-为组件的-prop-指定验证要求" class="headerlink" title="2.5 Prop 验证:为组件的 prop 指定验证要求"></a>2.5 Prop 验证:为组件的 prop 指定验证要求</h3><p>可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组,例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 匹配任何类型)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组且一定会从一个工厂函数返回默认值</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告;</p>
<p>类型检查：<code>type</code> 可以是下列原生构造函数中的一个：<code>String Number Boolean Array Object Date Function Symbol</code>； <code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认;</p>
<h3 id="2-6-非-Prop-的特性"><a href="#2-6-非-Prop-的特性" class="headerlink" title="2.6 非 Prop 的特性"></a>2.6 非 Prop 的特性</h3><p>一个非 <code>prop</code> 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性;</p>
<ul>
<li>替换/合并已有的特性；</li>
<li>禁用特性继承，如果你不希望组件的根元素继承特性，你可以设置在组件的选项中设置 ：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义事件"><a href="#3-自定义事件" class="headerlink" title="3.自定义事件"></a>3.自定义事件</h2><h3 id="3-1-事件名"><a href="#3-1-事件名" class="headerlink" title="3.1 事件名"></a>3.1 事件名</h3><p>事件名不会存在自动化的大小写转换，而是触发的事件名需要<code>完全匹配</code>监听这个事件所用的名称（如：子组件通过发布订阅模式向父组件传递数据<code>$emit()方式</code>）；</p>
<p>推荐事件的命名方式为 <code>kebab-case</code>中划线命名 方式；</p>
<h3 id="3-2-自定义组件的-v-model"><a href="#3-2-自定义组件的-v-model" class="headerlink" title="3.2 自定义组件的 v-model"></a>3.2 自定义组件的 v-model</h3><p>组件的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件的 value 特性用于不同的目的；<code>model 选项</code>可以用来避免这样的冲突；例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">"lovingVue"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code>触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的属性将会被更新;</p>
<h3 id="3-3-将原生事件绑定到组件（有点儿难）"><a href="#3-3-将原生事件绑定到组件（有点儿难）" class="headerlink" title="3.3 将原生事件绑定到组件（有点儿难）"></a>3.3 将原生事件绑定到组件（有点儿难）</h3><p>在一个组件的根元素上直接监听一个原生事件,使用 <code>v-on</code> 的 <code>.native</code> 修饰符,例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，该元素不是根元素，此时父级的 .native 监听器将静默失败，也不会报错,但是 <code>onFocus</code> 处理函数不会如你预期地被调用;不过Vue 提供了一个 <code>$listeners</code>属性解决这个问题, <code>$listeners</code> 它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-sync-修饰符"><a href="#3-4-sync-修饰符" class="headerlink" title="3.4 .sync 修饰符"></a>3.4 .sync 修饰符</h3><p>对prop进行双向绑定，推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：<br><code>this.$emit(&#39;update:title&#39;, newTitle)</code>；然后父组件可以监听那个事件并根据需要更新一个本地的数据属性；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上面代码等价于： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。</p>
<h2 id="4-插槽-有点儿难"><a href="#4-插槽-有点儿难" class="headerlink" title="4. 插槽(有点儿难)"></a>4. 插槽(有点儿难)</h2><h3 id="4-1-插槽内容"><a href="#4-1-插槽内容" class="headerlink" title="4.1 插槽内容"></a>4.1 插槽内容</h3><p>将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<h3 id="4-2-具名插槽"><a href="#4-2-具名插槽" class="headerlink" title="4.2 具名插槽"></a>4.2 具名插槽</h3><p><code>&lt;slot&gt;</code> 元素有一个特殊的特性：<code>name</code>。这个特性可以用来定义额外的插槽;</p>
<p>插槽用法：例如，一个假设的 <code>&lt;base-layout&gt;</code> 组件的模板如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以在一个父组件的 <code>&lt;template&gt;</code> 元素上使用 <code>slot</code> 特性：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>另一种 <code>slot</code> 特性的用法是直接用在一个<code>普通的元素</code>上：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述两个示例渲染出来的 HTML 都将会是：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="4-3-插槽的默认内容"><a href="#4-3-插槽的默认内容" class="headerlink" title="4.3 插槽的默认内容"></a>4.3 插槽的默认内容</h3><p>在 <code>&lt;slot&gt;</code> 标签内部指定默认的内容；(如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。)</p>
<h3 id="4-4-编译作用域"><a href="#4-4-编译作用域" class="headerlink" title="4.4 编译作用域"></a>4.4 编译作用域</h3><p><strong>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</strong></p>
<h3 id="4-5-作用域插槽（不怎么明白）"><a href="#4-5-作用域插槽（不怎么明白）" class="headerlink" title="4.5 作用域插槽（不怎么明白）"></a>4.5 作用域插槽（不怎么明白）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in todos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>若希望每个独立的待办项渲染出和 <code>todo.text</code>不太一样的东西。这也是作用域插槽的用武之地。为了让这个特性成为可能，你需要做的全部事情就是将待办项内容包裹在一个 <code>&lt;slot&gt;</code> 元素上，然后将所有和其上下文相关的数据传递给这个插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in todos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们为每个 todo 准备了一个插槽，--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:todo</span>=<span class="string">"todo"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 回退的内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当使用 <code>&lt;todo-list&gt;</code> 组件的时候，可以选择为待办项定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以通过 <code>slot-scope</code> 特性从子组件获取数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">"todos"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为待办项自定义一个模板，--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过 `slotProps` 定制每个待办项。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"slotProps.todo.isComplete"</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 2.5.0+，<code>slot-scope</code> 不再限制在 <code>&lt;template&gt;</code> 元素上使用，而可以用在插槽内的任何元素或组件上。</p>
<p>解构 <code>slot-scope</code>: 如果一个 JavaScript 表达式在一个函数定义的参数位置有效，那么这个表达式实际上就可以被 <code>slot-scope</code> 接受，可以在支持的环境下 (单文件组件或现代浏览器)，在这些表达式中使用 <code>ES2015 解构语法</code>，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">"todos"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; todo &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"todo.isComplete"</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-动态组件和异步组件"><a href="#5-动态组件和异步组件" class="headerlink" title="5. 动态组件和异步组件"></a>5. 动态组件和异步组件</h2><h3 id="5-1-在动态组件上使用-keep-alive"><a href="#5-1-在动态组件上使用-keep-alive" class="headerlink" title="5.1 在动态组件上使用 keep-alive"></a>5.1 在动态组件上使用 keep-alive</h3><p>曾经在一个多标签的界面中使用 <code>is</code> 特性来切换不同的组件：<br><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。</p>
<p>解决方法：可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来，将那些标签的组件实例在它们第一次被创建的时候缓存下来；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-异步组件-不明白"><a href="#5-2-异步组件-不明白" class="headerlink" title="5.2 异步组件(不明白)"></a>5.2 异步组件(不明白)</h3><p>Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。</p>
<h4 id="5-2-1-处理加载状态"><a href="#5-2-1-处理加载状态" class="headerlink" title="5.2.1 处理加载状态"></a>5.2.1 处理加载状态</h4><p>异步组件工厂函数也可以返回一个如下格式的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：若在 <code>Vue Router</code>的路由组件中使用上述语法的话，你必须使用 <code>Vue Router 2.4.0+</code> 版本。</p>
<h2 id="6-处理边界情况（有点儿难）"><a href="#6-处理边界情况（有点儿难）" class="headerlink" title="6. 处理边界情况（有点儿难）"></a>6. 处理边界情况（有点儿难）</h2><h3 id="6-1-访问元素-amp-组件"><a href="#6-1-访问元素-amp-组件" class="headerlink" title="6.1 访问元素&amp;组件"></a>6.1 访问元素&amp;组件</h3><p>在绝大多数情况下，我们最好<code>不要</code>触达另一个组件实例内部或手动操作 <code>DOM</code> 元素。不过也确实在一些情况下做这些事情是合适的。</p>
<ol>
<li>访问根实例：在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> 属性进行访问；所有的子组件都可以将这个实例作为一个全局 <code>store</code> 来访问或使用：<code>this.$root.foo // 获取根组件的数据</code></li>
<li>访问父级组件实例：<code>$parent</code> 属性可以用来从一个子组件访问父组件的实例；它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 <code>prop</code> 的方式传入子组件的方式。</li>
<li>访问子组件实例或子元素：可以通过 <code>ref</code> 特性为这个子组件赋予一个 <code>ID</code> 引用；</li>
<li>依赖注入：<code>provide</code> 选项允许我们指定我们想要提供给后代组件的数据/方法；然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的属性；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><h3 id="6-2-程序化的事件侦听器"><a href="#6-2-程序化的事件侦听器" class="headerlink" title="6.2 程序化的事件侦听器"></a>6.2 程序化的事件侦听器</h3><p><code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>
</li>
</ol>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>一般不会用到这些，但是当你需要在一个组件实例上<code>手动侦听事件</code>时，它们是派得上用场的；它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="keyword">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，</span></span><br><span class="line"><span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个潜在的问题：</p>
<ul>
<li>它需要在这个组件实例中保存这个 <code>picker</code>，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。</li>
<li>建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。</li>
</ul>
<p>因而应该通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了这个策略，甚至可以让多个输入框元素同时使用不同的 <code>Pikaday</code>，每个新的实例都程序化地在后期清理它自己：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'startDateInput'</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'endDateInput'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件，更多程序化侦听器的内容，请查阅<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">实例方法 / 事件</a>相关的 API；</p>
<h3 id="6-3-循环引用"><a href="#6-3-循环引用" class="headerlink" title="6.3 循环引用"></a>6.3 循环引用</h3><h4 id="6-3-1-递归组件"><a href="#6-3-1-递归组件" class="headerlink" title="6.3.1 递归组件"></a>6.3.1 递归组件</h4><p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 <code>ID</code> 会自动设置为该组件的 <code>name</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：稍有不慎，递归组件就可能导致无限循环，要确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-组件之间的循环引用"><a href="#6-3-2-组件之间的循环引用" class="headerlink" title="6.3.2 组件之间的循环引用"></a>6.3.2 组件之间的循环引用</h4><p>若需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个 <code>&lt;tree-folder-contents&gt;</code> 组件，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若使用 <code>Vue.component</code> 全局注册组件的时候，可以解决这两个组件的父子组件关系；或者是经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在例子中，把 <code>&lt;tree-folder&gt;</code> 组件设为了那个点，那个产生悖论的子组件是 <code>&lt;tree-folder-contents&gt;</code> 组件，所以会等到生命周期钩子 <code>beforeCreate</code> 时去注册它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，在本地注册组件的时候，你可以使用 <code>webpack</code> 的<code>异步 import</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-模板定义的替代品"><a href="#6-4-模板定义的替代品" class="headerlink" title="6.4 模板定义的替代品"></a>6.4 模板定义的替代品</h3><h4 id="6-4-1-内联模板"><a href="#6-4-1-内联模板" class="headerlink" title="6.4.1 内联模板"></a>6.4.1 内联模板</h4><p>当<code>inline-template</code> 这个特殊的特性出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component's own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent's transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>inline-template</code> 会让你模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板；</p>
<h4 id="6-4-2-X-Templates"><a href="#6-4-2-X-Templates" class="headerlink" title="6.4.2 X-Templates"></a>6.4.2 X-Templates</h4><p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 <code>id</code> 将模板引用过去。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.component('hello-world', &#123;</span><br><span class="line">  template: '#hello-world-template'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-5-控制更新"><a href="#6-5-控制更新" class="headerlink" title="6.5 控制更新"></a>6.5 控制更新</h3><p>Vue 的响应式系统始终知道何时进行更新；</p>
<h4 id="6-5-1-强制更新"><a href="#6-5-1-强制更新" class="headerlink" title="6.5.1 强制更新"></a>6.5.1 强制更新</h4><p>你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 <code>$forceUpdate</code> 来做这件事</p>
<h4 id="6-5-2-通过-v-once-创建低开销的静态组件"><a href="#6-5-2-通过-v-once-创建低开销的静态组件" class="headerlink" title="6.5.2 通过 v-once 创建低开销的静态组件"></a>6.5.2 通过 v-once 创建低开销的静态组件</h4><p>渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 <code>v-once</code> 特性以确保这些内容只计算一次然后缓存起来，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VueJs</category>
        <category>Vue官方文档</category>
      </categories>
      <tags>
        <tag>Vue入门</tag>
        <tag>Vue官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue官方文档笔记1——基础</title>
    <url>/2018/12/21/Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Vue官方文档笔记1——基础</p>
<a id="more"></a>

<h2 id="Vue官方文档笔记1——基础"><a href="#Vue官方文档笔记1——基础" class="headerlink" title="Vue官方文档笔记1——基础"></a>Vue官方文档笔记1——基础</h2><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue官方文档网址</a></p>
</blockquote>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h2 id="2-Vue-实例"><a href="#2-Vue-实例" class="headerlink" title="2. Vue 实例"></a>2. Vue 实例</h2><h3 id="2-1-创建一个Vue实例"><a href="#2-1-创建一个Vue实例" class="headerlink" title="2.1 创建一个Vue实例"></a>2.1 创建一个Vue实例</h3><p>每个Vue应用都是通过vue函数传建一个新的实例开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<code>根Vue实例</code>，以及可选的嵌套的、可复用的组件树组成；</p>
<h3 id="2-2-数据与方法"><a href="#2-2-数据与方法" class="headerlink" title="2.2 数据与方法"></a>2.2 数据与方法</h3><p>当一个 Vue 实例被创建后，它向 Vue 的响应式系统中加入其 data 对象中能找到的所有属性，当这些属性的值变化时，视图将会产生“相应”，即匹配新的值；</p>
<p>若使用 <code>Object.freeze()</code> ,则会阻止修改现有的属性，意味着响应式系统无法追踪变化；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: 'bar'</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#app',</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"foo = 'baz'"</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue 实例还暴露了一些有用的实例属性和方法，加以前缀 <code>$</code> ,以便与用户定义的属性区分开；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-实例生命周期钩子"><a href="#2-3-实例生命周期钩子" class="headerlink" title="2.3 实例生命周期钩子"></a>2.3 实例生命周期钩子</h3><p>每个Vue实例在被创建的时候要经过一系列的初始化过程，这个过程中会运行一些叫做 <code>生命周期钩子</code> 的函数，给用户在不同阶段加入自己代码的机会；</p>
<p>生命周期钩子的 <code>this</code> 上下文指向调用它的 <code>Vue实例</code>；<br><strong>注：不要在选项属性或回调上使用箭头函数；</strong><br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line"></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, newValue =&gt; <span class="keyword">this</span>.myMethod())</span><br></pre></td></tr></table></figure>

<p>这是因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，系统会报错；</p>
<h3 id="2-4-生命周期图示"><a href="#2-4-生命周期图示" class="headerlink" title="2.4 生命周期图示"></a>2.4 生命周期图示</h3><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">生命周期图:</a></p>
</blockquote>
<p><img src="/2018/12/21/Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/life-circle.png" alt="生命周期图片"></p>
<h2 id="3-模板语法"><a href="#3-模板语法" class="headerlink" title="3. 模板语法"></a>3. 模板语法</h2><p>Vue.js 使用了基于HTML 的模板语法，允许开发者声明式地将 DOM 绑定到底层Vue实例的数据；</p>
<p>在底层实现上，Vue将模板编译成虚拟 DOM 渲染函数；若你熟悉虚拟DOM且偏爱JavaScript原生力量，可以直接写渲染函数（render函数），使用JSX 的语法；</p>
<h3 id="3-1-插值"><a href="#3-1-插值" class="headerlink" title="3.1 插值"></a>3.1 插值</h3><ul>
<li>文本：数据绑定的形式就是使用<code>“Mustache语法”</code>，采用双括号的文本插值；<br>或是通过 <code>v-once</code> 指令，执行一次性插值，若数据改变，插值处的内容不会更新；</li>
<li>原生 HTML：双大括号将数据解释为普通文本，非 HTML 代码，若要输出真正的 HTML， 则使用 <code>v-html</code> 指令；</li>
</ul>
<p><strong>特性</strong>：<code>Mustache</code> 语法不能作用在HTML特性上，则需要使用 <code>v-bind</code> 指令进行属性绑定，如<code>title、src、disabled</code> 等属性；</p>
<p>使用 JavaScript 表达式：对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持；</p>
<h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>指令是带有 <code>v-</code> 前缀的特殊特性，指令特性的预期是单个JavaScript 表达式（v-for 例外），指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM；</p>
<ul>
<li>参数：位于指令名称之后以冒号表示；例：<ul>
<li><code>v-on</code> 指令：参数是监听的事件名；</li>
<li><code>v-if</code> 指令：根据表达式值的真假来<code>插入/移除</code>元素；</li>
<li><code>v-bind</code> 指令：用于绑定 HTML 标签的属性，如<code>href、img、title</code>等；</li>
</ul>
</li>
<li>修饰符：以半角句号(<code>.</code>)指明的特殊后缀，用于指出一个指令应该以特殊方式绑定；</li>
</ul>
<p>例如： <code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>，阻止默认事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-缩写"><a href="#3-3-缩写" class="headerlink" title="3.3 缩写"></a>3.3 缩写</h3><p><code>v-bind</code> 指令缩写为（<code>:</code>）;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-on</code>指令缩写为（<code>@</code>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-计算属性和侦听器"><a href="#4-计算属性和侦听器" class="headerlink" title="4.计算属性和侦听器"></a>4.计算属性和侦听器</h2><h3 id="4-1-计算属性"><a href="#4-1-计算属性" class="headerlink" title="4.1 计算属性"></a>4.1 计算属性</h3><p>基础例子：从该实例中，可以看出，计算属性用于复杂的逻辑中，只要 <code>computed</code> 钩子函数中声明的计算属性所依赖的值发生变化，那么该属性就会更新，而所有依赖该计算属性的绑定也会更新；</p>
<p>现在我们已经以声明的方式创建这种依赖关系：计算属性的 <code>getter</code> 函数是没有副作用的，使得它更易于测试和理解；</p>
<ul>
<li><code>计算属性</code> Vs <code>methods方法</code>：<ul>
<li>将一个函数定义为一个方法或是一个计算属性，两种方式结构是完全相同的；</li>
<li>区别是：计算属性是基于他们的依赖进行缓存的；计算属性只有在它依赖发生变化时才会重新求值；而 <code>methods</code>则是通过触发事件来调用的；</li>
</ul>
</li>
<li><code>计算属性</code> Vs <code>侦听属性</code>: <ul>
<li>侦听属性(<code>watch</code>)用于监测某个数据变化而触发，而计算属性原理是其数据依赖发生变化时才触发；</li>
</ul>
</li>
<li>计算属性的 <code>setter</code> ，例全名的例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-侦听器"><a href="#4-2-侦听器" class="headerlink" title="4.2 侦听器"></a>4.2 侦听器</h3><p>Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.debouncedGetAnswer()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，有点儿象节流函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    getAnswer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span></span><br><span class="line"><span class="actionscript">        .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Class与Style绑定"><a href="#5-Class与Style绑定" class="headerlink" title="5. Class与Style绑定"></a>5. Class与Style绑定</h2><h3 id="5-1-绑定-HTML-class"><a href="#5-1-绑定-HTML-class" class="headerlink" title="5.1 绑定 HTML class"></a>5.1 绑定 HTML class</h3><ol>
<li>对象语法：给 <code>v-bind:class</code> 传一个对象，可动态切换class，是由于数据属性的 truthiness；也可以在对象中传入更多属性来动态切换多个 class；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.可以在对象中传入更多属性来动态切换多个 class</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.绑定的数据对象不必内联定义在模板里：</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.也可以在这里绑定一个返回对象的计算属性：</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组语法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.可以把一个数组传给 `v-bind:class`</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 也可以用三元表达式:</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 当有多个条件 class 时,数组语法中也可以使用对象语法：</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用在组件上:<br>当在一个自定义组件上使用 <code>class</code> 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖，用法和上面的用法一致；</li>
</ol>
<h3 id="5-2-绑定内联样式"><a href="#5-2-绑定内联样式" class="headerlink" title="5.2 绑定内联样式"></a>5.2 绑定内联样式</h3><ul>
<li><code>v-bind:style</code> 的对象语法其实是一个 <code>JavaScript</code> 对象。CSS 属性名可以用<code>驼峰式</code> (camelCase) 或<code>短横线分隔</code> (kebab-case，记得用<code>单引号</code>括起来) 来命名，如下:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>或直接绑定到一个样式对象：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"styleObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法：<code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- baseStyles, overridingStyles 为样式对象，参考上面的styleObject --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自动添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>的<code>-webkit- -moz- -o- -ms-</code>前缀；</li>
<li>多重值:可从 2.3.0 起,可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值,例如：<code>&lt;div :style=&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;&gt;&lt;/div&gt;</code></li>
</ul>
<h2 id="6-条件渲染"><a href="#6-条件渲染" class="headerlink" title="6. 条件渲染"></a>6. 条件渲染</h2><h3 id="6-1-v-if-指令："><a href="#6-1-v-if-指令：" class="headerlink" title="6.1 v-if 指令："></a>6.1 v-if 指令：</h3><ul>
<li>在 <code>&lt;template&gt;</code>元素上使用 <code>v-if</code> 条件渲染分组；</li>
<li><code>v-else</code> ：v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别；</li>
<li><code>v-else-if</code>：充当 v-if 的“else-if 块”，可以连续使用；</li>
<li>用 <code>key</code> 管理可复用的元素: Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染；而添加一个具有唯一值的 <code>key</code> 属性,使得复用的元素是完全独立的，不要复用它们，</li>
</ul>
<h3 id="6-2-v-show-指令：根据条件展示元素的选项"><a href="#6-2-v-show-指令：根据条件展示元素的选项" class="headerlink" title="6.2 v-show 指令：根据条件展示元素的选项"></a>6.2 v-show 指令：根据条件展示元素的选项</h3><p><code>v-show</code> 的元素始终会被渲染并保留在 DOM 中, <code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display: none/block;</code>;</p>
<h3 id="6-3-v-if-对比-v-show"><a href="#6-3-v-if-对比-v-show" class="headerlink" title="6.3 v-if 对比 v-show:"></a>6.3 v-if 对比 v-show:</h3><ul>
<li><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;</li>
<li><code>v-show</code> 元素总是会被渲染，并且只是简单地基于 CSS 进行切换;</li>
</ul>
<h3 id="6-4-v-if-与-v-for-一起使用"><a href="#6-4-v-if-与-v-for-一起使用" class="headerlink" title="6.4 v-if 与 v-for 一起使用"></a>6.4 v-if 与 v-for 一起使用</h3><p>当 <code>v-if</code> 与 <code>v-for</code>一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级；<strong>尽量不一起使用</strong></p>
<h2 id="7-列表渲染"><a href="#7-列表渲染" class="headerlink" title="7. 列表渲染"></a>7. 列表渲染</h2><h3 id="7-1-用-v-for-把一个数组对应为一组元素"><a href="#7-1-用-v-for-把一个数组对应为一组元素" class="headerlink" title="7.1 用 v-for 把一个数组对应为一组元素"></a>7.1 用 v-for 把一个数组对应为一组元素</h3><ul>
<li>v-for 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名;</li>
<li>在 <code>v-for</code> 块中，拥有对父作用域属性的完全访问权限;</li>
<li><code>v-for</code> 还支持一个可选的第二个参数为当前项的索引;</li>
<li>可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它是最接近 JavaScript 迭代器的语法；</li>
</ul>
<h3 id="7-2-一个对象的-v-for"><a href="#7-2-一个对象的-v-for" class="headerlink" title="7.2 一个对象的 v-for"></a>7.2 一个对象的 v-for</h3><p>用 <code>v-for</code> 通过一个对象的属性来迭代，也可以提供第二个的参数为键名,第三个参数为索引；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      firstName: <span class="string">'John'</span>,</span><br><span class="line">      lastName: <span class="string">'Doe'</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="7-3-key"><a href="#7-3-key" class="headerlink" title="7.3 key"></a>7.3 key</h3><p>尽可能在使用 <code>v-for</code> 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升; 因为它是 Vue 识别节点的一个通用机制;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-数组更新检测"><a href="#7-4-数组更新检测" class="headerlink" title="7.4 数组更新检测"></a>7.4 数组更新检测</h3><ul>
<li>变异方法：Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：<code>push()、pop()、shift()、unshift()、splice()、sort()、reverse()</code>；</li>
<li>替换数组:<ul>
<li>变异方法：会改变被这些方法调用的原始数组；</li>
<li>非变异 (non-mutating method) 方法，例如：<code>filter(), concat() 和 slice()</code>这些不会改变原始数组，但总是返回一个新数组,可以用新数组替换旧数组：</li>
</ul>
</li>
</ul>
<p>注意事项：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>
<ul>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue;</code> </li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength;</code></li>
</ul>
<p>解决上面第一类问题，以下两种方式都可以解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>解决上面第二类问题，你可以使用 <code>splice</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-对象更改检测注意事项"><a href="#7-5-对象更改检测注意事项" class="headerlink" title="7.5 对象更改检测注意事项"></a>7.5 对象更改检测注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除；对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)<span class="comment">//或者使用 vm.$set 实例方法，它只是全局 Vue.set 的别名，格式一致</span></span><br></pre></td></tr></table></figure>

<h3 id="7-6-显示过滤-排序结果"><a href="#7-6-显示过滤-排序结果" class="headerlink" title="7.6 显示过滤/排序结果"></a>7.6 显示过滤/排序结果</h3><p>有时我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性，可以通过 <code>filter</code> 函数进行过滤，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个 <code>method</code> 方法进行数据过滤；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-一段取值范围的-v-for"><a href="#7-7-一段取值范围的-v-for" class="headerlink" title="7.7 一段取值范围的 v-for"></a>7.7 一段取值范围的 v-for</h3><p><code>v-for</code> 也可以取整数。在这种情况下，它将重复多次模板:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>= <span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-8-v-for-on-a-lt-template-gt"><a href="#7-8-v-for-on-a-lt-template-gt" class="headerlink" title="7.8 v-for on a &lt;template&gt;"></a>7.8 v-for on a <code>&lt;template&gt;</code></h3><p>利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 渲染多个元素;</p>
<h3 id="7-9-v-for-with-v-if"><a href="#7-9-v-for-with-v-if" class="headerlink" title="7.9 v-for with v-if"></a>7.9 v-for with v-if</h3><p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <strong>v-if 将分别重复运行于每个 v-for 循环中</strong>;</p>
<h3 id="7-10-一个组件的-v-for"><a href="#7-10-一个组件的-v-for" class="headerlink" title="7.10 一个组件的 v-for"></a>7.10 一个组件的 v-for</h3><p>自定义组件里可以像任何普通元素一样用 <code>v-for</code> ；然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域，为了把迭代数据传递到组件里，我们要用 <code>props</code>，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span></span><br><span class="line">  v-bind:item=<span class="string">"item"</span></span><br><span class="line">  v-bind:index=<span class="string">"index"</span></span><br><span class="line">  v-bind:key=<span class="string">"item.id"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>不自动将 item 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用；</p>
<h3 id="7-11-todo-list-的完整例子："><a href="#7-11-todo-list-的完整例子：" class="headerlink" title="7.11 todo list 的完整例子："></a>7.11 todo list 的完整例子：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"addNewTodo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"new-todo"</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"new-todo"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">"E.g. Feed the cat"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="8-事件处理"><a href="#8-事件处理" class="headerlink" title="8.事件处理"></a>8.事件处理</h2><h3 id="8-1-监听事件"><a href="#8-1-监听事件" class="headerlink" title="8.1 监听事件"></a>8.1 监听事件</h3><p><code>v-on</code> 指令：监听 DOM 事件，并在触发时运行一些 JavaScript 代码；</p>
<h3 id="8-2-事件处理方法"><a href="#8-2-事件处理方法" class="headerlink" title="8.2 事件处理方法"></a>8.2 事件处理方法</h3><p><code>v-on</code> 可以接收一个需要调用的方法名称 ;(方法在 <code>methods</code> 中定义 )；</p>
<h3 id="8-3-内联处理器中的方法"><a href="#8-3-内联处理器中的方法" class="headerlink" title="8.3 内联处理器中的方法"></a>8.3 内联处理器中的方法</h3><p><code>v-on</code> 还可以在内联 JavaScript 语句中调用方法；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若需要在内联语句处理器中访问<code>原始的 DOM 事件</code>，用特殊变量 <code>$event</code> 把它传入方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-事件修饰符"><a href="#8-4-事件修饰符" class="headerlink" title="8.4 事件修饰符"></a>8.4 事件修饰符</h3><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节;</p>
<blockquote>
<p>Vue.js 为 <code>v-on</code> 提供了事件修饰符，包括：<code>.stop .prevent .capture .self .once .passive</code>事件修饰符；</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播（冒泡事件传播） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：使用修饰符时，顺序很重要</strong>；例如用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击；</p>
<p>Vue 2.1.4 新增：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue 2.3.0 新增: Vue 还对应 <code>addEventListener</code> 中的 <code>passive</code> 选项提供了<code>.passive</code> 修饰符:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告；</strong></p>
<h3 id="8-5-按键修饰符"><a href="#8-5-按键修饰符" class="headerlink" title="8.5 按键修饰符"></a>8.5 按键修饰符</h3><p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 / enter 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>全部的按键别名：<code>.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right</code>；</p>
<p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-系统修饰键"><a href="#8-6-系统修饰键" class="headerlink" title="8.6 系统修饰键"></a>8.6 系统修饰键</h3><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器：<code>.ctrl .alt .shift .meta</code>；</p>
<p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 <code>keyCode: keyup.17</code>；</p>
<h3 id="8-7-exact-修饰符"><a href="#8-7-exact-修饰符" class="headerlink" title="8.7  .exact 修饰符"></a>8.7  .exact 修饰符</h3><p>允许你控制由精确的系统修饰符组合触发的事件；例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-8-鼠标按钮修饰符：-left、-right、-middle"><a href="#8-8-鼠标按钮修饰符：-left、-right、-middle" class="headerlink" title="8.8 鼠标按钮修饰符： .left、.right、.middle"></a>8.8 鼠标按钮修饰符： .left、.right、.middle</h3><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮;</p>
<h3 id="8-9-为什么在-HTML-中监听事件"><a href="#8-9-为什么在-HTML-中监听事件" class="headerlink" title="8.9 为什么在 HTML 中监听事件?"></a>8.9 为什么在 HTML 中监听事件?</h3><p>使用 <code>v-on</code> 有几个好处：</p>
<ul>
<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>
<li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li>
<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</li>
</ul>
<h2 id="9-表单输入绑定"><a href="#9-表单输入绑定" class="headerlink" title="9. 表单输入绑定"></a>9. 表单输入绑定</h2><h3 id="9-1-基础用法"><a href="#9-1-基础用法" class="headerlink" title="9.1 基础用法"></a>9.1 基础用法</h3><p><code>v-model</code> 指令可以在表单 <code>&lt;input&gt; &lt;textarea&gt; &lt;select&gt;</code> 元素上创建双向数据绑定,它会根据控件类型自动选取正确的方法来更新元素:</p>
<p>注意：<code>v-model</code> 会忽略所有表单元素的 <code>value、checked、selected</code> 特性的初始值，而总是将 <code>Vue 实例</code> 的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值；</p>
<h3 id="9-2-文本示例："><a href="#9-2-文本示例：" class="headerlink" title="9.2 文本示例："></a>9.2 文本示例：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-3-多行文本示例："><a href="#9-3-多行文本示例：" class="headerlink" title="9.3 多行文本示例："></a>9.3 多行文本示例：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-复选框示例：单个复选框，绑定到布尔值；"><a href="#9-4-复选框示例：单个复选框，绑定到布尔值；" class="headerlink" title="9.4 复选框示例：单个复选框，绑定到布尔值；"></a>9.4 复选框示例：单个复选框，绑定到布尔值；</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-5-文本示例：多个复选框，绑定到同一个数组；"><a href="#9-5-文本示例：多个复选框，绑定到同一个数组；" class="headerlink" title="9.5 文本示例：多个复选框，绑定到同一个数组；"></a>9.5 文本示例：多个复选框，绑定到同一个数组；</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-6-单选按钮示例："><a href="#9-6-单选按钮示例：" class="headerlink" title="9.6 单选按钮示例："></a>9.6 单选按钮示例：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-7-选择框示例："><a href="#9-7-选择框示例：" class="headerlink" title="9.7 选择框示例："></a>9.7 选择框示例：</h3><p>单选时:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>多选时 (绑定到一个数组)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-6',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-8-值绑定"><a href="#9-8-值绑定" class="headerlink" title="9.8 值绑定"></a>9.8 值绑定</h3><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code>绑定的值通常是静态字符串 (对于复选框也可以是布尔值);如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以用 <code>v-bind</code> 实现把值绑定到 Vue 实例的一个动态属性上,这个属性的值可以不是字符串;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当选中时：vm.pick === vm.a --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择框的选项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时：</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure>

<h3 id="9-9-修饰符："><a href="#9-9-修饰符：" class="headerlink" title="9.9 修饰符："></a>9.9 修饰符：</h3><ul>
<li><p><code>.lazy</code>：默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy 修饰符</code>，从而转变为使用 <code>change</code> 事件进行同步；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.number</code>：自动将用户的输入值转为数值类型，给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.trim</code>：自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="9-10-在组件上使用-v-model"><a href="#9-10-在组件上使用-v-model" class="headerlink" title="9.10 在组件上使用 v-model"></a>9.10 在组件上使用 v-model</h3><p>Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用;</p>
<h2 id="10-组件基础"><a href="#10-组件基础" class="headerlink" title="10. 组件基础"></a>10. 组件基础</h2><h3 id="10-1-基本实例"><a href="#10-1-基本实例" class="headerlink" title="10.1 基本实例"></a>10.1 基本实例</h3><p>组件是可复用的 Vue 实例，可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//在根实例中使用</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123; el: '#components-demo' &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="10-2-组件的复用"><a href="#10-2-组件的复用" class="headerlink" title="10.2 组件的复用"></a>10.2 组件的复用</h3><p>组件可以任意次数复用，因为你每用一次组件，就会有一个它的新实例被创建；</p>
<p>注意：组件定义时， <code>data</code> 必须是一个函数，而不是一个对象,若 Vue 没有这条规则，点击一个组件的实例就可能会影响到该组件其它所有实例；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-组件的组织及组件注册"><a href="#10-3-组件的组织及组件注册" class="headerlink" title="10.3 组件的组织及组件注册"></a>10.3 组件的组织及组件注册</h3><p>组件是以一棵嵌套的组件树的形式来组织；为了能在模板中使用，组件必须<code>先注册</code>以便 Vue 能够识别；</p>
<p>组件有两种组件的注册类型：<code>全局注册和局部注册</code>;</p>
<ul>
<li>全局注册：通过 <code>Vue.component</code> 全局注册例：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>局部注册：通过对象的形式创建组件，引入组件后在 <code>component</code> 属性中进行注册；</li>
</ul>
<p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中；</p>
<h3 id="10-4-通过-Prop-向子组件传递数据"><a href="#10-4-通过-Prop-向子组件传递数据" class="headerlink" title="10.4 通过 Prop 向子组件传递数据"></a>10.4 通过 Prop 向子组件传递数据</h3><p><code>Prop</code> 是在组件上注册的一些自定义特性，当一个值传递给一个 <code>prop</code> 特性的时候，它就变成了那个组件实例的一个属性；</p>
<p>例如通过父组件向子组件传递数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> 在父组件中的创建的该子组件的实例上加入 <span class="attr">title</span> 属性 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Blogging with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Why Vue is so fun"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件在通过 Vue.componen 全局创建的时候，props属性中包含 title 属性，用于父组件的传值</span></span><br><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'title'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个组件默认可以拥有任意数量的 <code>prop</code>，任何值都可以传递给任何 <code>prop</code>，在子组件的 <code>props</code>属性中接收父组件传递的数据；</p>
</blockquote>
<h3 id="10-5-单个根元素"><a href="#10-5-单个根元素" class="headerlink" title="10.5 单个根元素"></a>10.5 单个根元素</h3><p>每个组件<code>&lt;template&gt;</code>必须只有一个根元素,将模板的内容包裹在一个父元素内，来修复这个问题;</p>
<h3 id="10-6-通过事件向父级组件发送消息"><a href="#10-6-通过事件向父级组件发送消息" class="headerlink" title="10.6 通过事件向父级组件发送消息"></a>10.6 通过事件向父级组件发送消息</h3><ul>
<li>方法1：父组件中加一个 <code>postFontSize</code> 数据属性（暂时不了解）</li>
<li>方法2：调用内建的 <code>$emit</code> 方法并传入事件的名字，来向父级组件触发一个事件；例：在子组件中通过点击事件添加一个事件名,再在父组件中监听这个事件,来实现子组件向父组件数据传递：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件通过 $emit() 方法加入一个事件名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text')"</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件上通过 v-on 指令来监听这个事件</span></span><br><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=<span class="string">"postFontSize += 0.1"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>同时<code>$emit()</code>方法还可以给事件传递一个值，父组件中使用 <code>$event</code> 访问到这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件通过 $emit() 方法加入一个事件名，并传一个值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text', 0.1)"</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件上通过 v-on 指令来监听这个事件，并通过 $event 访问到被抛出的这个值；如果这个事件处理函数是一个方法，可以将该值作为参数传入方法中使用</span></span><br><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=<span class="string">"postFontSize += $event"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法3：在组件上使用 <code>v-model</code>传值，在输入控件中调用 <code>v-model</code> 的原理如下：(此处没有弄懂)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"searchText = $event.target.value"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用在组件上时，<code>v-model</code> 则会这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"searchText = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因而在组件内的 input 标签必须：将其 value 特性绑定到一个名叫 value 的 prop 上；在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出；</p>
<p>组件中使用的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件全局创建时</span></span><br><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="10-7-通过插槽分发内容"><a href="#10-7-通过插槽分发内容" class="headerlink" title="10.7 通过插槽分发内容"></a>10.7 通过插槽分发内容</h3><p>Vue 自定义的 <code>&lt;slot&gt;</code> 元素,只要在需要的地方加入插槽就行了;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'alert-box'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="demo-alert-box"&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-8-动态组件："><a href="#10-8-动态组件：" class="headerlink" title="10.8 动态组件："></a>10.8 动态组件：</h3><blockquote>
<p><a href="https://jsfiddle.net/chrisvfritz/o3nycadu/" target="_blank" rel="noopener">官方范例程序</a></p>
</blockquote>
<p>通过 Vue 的 <code>component</code> 元素加一个特殊的 <code>is</code> 特性来实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述示例中，<code>currentTabComponent</code> 可以包括: 已注册组件的名字 或 一个组件的选项对象;</p>
<h3 id="10-9-解析-DOM-模板时的注意事项"><a href="#10-9-解析-DOM-模板时的注意事项" class="headerlink" title="10.9 解析 DOM 模板时的注意事项"></a>10.9 解析 DOM 模板时的注意事项</h3><p>有些 HTML 元素，诸如 <code>&lt;ul&gt; &lt;ol&gt; &lt;table&gt; &lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt; &lt;tr&gt; &lt;option&gt;</code>，只能出现在其它某些特定的元素内部; Vue 中特殊的 <code>is</code> 特性给了我们一个变通的办法，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- blog 为一个自定义组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"blog"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意: 如果我们从以下来源使用模板的话，这条限制是不存在的：</p>
<ul>
<li>字符串 (例如：<code>template: &#39;...&#39;</code>); </li>
<li>单文件组件 (<code>.vue</code>); </li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>VueJs</category>
        <category>Vue官方文档</category>
      </categories>
      <tags>
        <tag>Vue入门</tag>
        <tag>Vue官方文档</tag>
      </tags>
  </entry>
</search>
